<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"37ef36938aba5626c176c1366972cb35bf788fe5f6f2f1dde0b4141328586e382c73d778cc3c90fd64f0c6187b79462fe5858d70bb62fc1711062c089e9f25ccff961be90895abda4a7b2017d51cca4f3c8329c45494d86380c9b7fa5cf91f8fc2d3700facb2ed056a508d25e4389d5bbcb0c0ccab608e84f88938cb3aac8d8f66e6da09e15b75084a5a987cf29a2c51c15c2a87787d90e099149f4fb4707a7c73195c75d61694de5cc8397f09fcc8d8e0ec5f322f3ca2425dd5589a4b158d4c3fbcc7e5a895734bb8f19f2e38a13a0ca8f22acbcf895fa2ccb0a21b4c1c9242676c08601c9ec6d6ed873ba749ff8228196c6ccf0b898f540ebdabd2c8320cd3390b292d7556fd43138db25c11f1980af87738c8263aba00147bee5ea014f24ab39ad7061f56e98a7fa66dc36ed9cfb79851baa3e5158fb5753e7fddc5345686e5a88f1726a2282233988477926356921ad5a2f76a89e091a07594d2f73759db5fffea665fb36709f7815f57d59bbceda317fac2bdace4996a360a96cf3e423d2f6feac5e74b7173f8efc07d18b3d60b5b5479c0ab755039d06e43986d04f28ba1ee8751184b0cd5d31505dd8150eb929bdd59fc9d1aaf4624a3b542532ff9a513e0db0b9f7c2dde8f6c8df9954ff76bb939ba4dcf6d80f27edc15a561acc5ae4f4815170026d531c0fe66de8160d379cd01d2cd7e8a7f885aa13dc808be0d4b3f818d7c88f84b3f12c920e7e12844c69545dc6ac0279fce57fa4020be1fc84d4cb0e203f70d9aa971197fc55c0a71d74f15cd90d27b3d28c5aa4ded8ed8fe60f3b6a67aea7a3c6e66ef3fdae72fb402368fda0ce38b86ddc0e8319d629c6871b737d19f88d7e9ebbfe5e480438d4246deed4e773a2299d6935e6014a653bea6c140b476854e8bc728d1c71061cfdcc0282ee434ad02888606b614b59b78883a727745d4d74191f7e29e8fe6db95d29ee7d330c06029beee5d17b62ecba7fba2db9218dc5526c80732853a3d38c2f0614bbee3924e32518ad976acb8d23126c3e8c10e8148fd35725c9c33527c18342a242d227ace3725deab22275e53ed1c2a5dd336c3e71d4bd9d8f158c1ee4b320094fea79368ab7eb46ff8b0d72b0a6a0b098255a56371f07b6da409b69e179f3cdd74007ba959fc6d465e1b12f02d7fd11e38e9454c49416b56ccd5da051a4bca356e974ac70e9b7075efab22d0a140067bf642fbbdb597f3781d67aec08b06e24c8c3fdc6586594f20a60c6f36cbcce052668203c014aaa2e8f87b19b117d99c511e49d99453012ba1b55fbc011f6d793715064e29da9b66c980e7c0788a17078571324d9741625a42af8182012a6fa22ee54cbffa058ca96c54e2a01c74a7075c64287c3f5db5bd5498181f4e6deb157b3eadcfd8e0c0f5d2f34b4ee8804194c8f4edffdcf79a5dae78ca4cfc0befcd78a6326d4b7e6284a879da3d2ecb5fdda6f4b0a32aa430659470c635bfdb89cbb3fe7f5f3630cca9e83992d8b0556d8f7bbe9aaba64bc693afe6bbc365193d0007632707a9ca5374292baf84569a8ef6a503c5e66903931c4df7fe145c3acd37b828fdb68db243a533eeaf69629fe5fe960214fbf541deb66617668de6b516a9c1b6d4fdaa30bb413c41ea11309e18b99905b24adabbdf4988c34ec5d3511d3356790deaddd5ffb217b72cf66dec5e93f922ffcf13ce1d8b6d1ddea03c8ffdc81e6d1261656e14d48f04ea4629840d84e90193381a9a4ae2d624e8e2f965890c907ff6f61b2b3b3835b0a517bb2e93764dbdad9f6dc27a00543318c8cf0a8701d3dc60939f0a8ba4344d77663433212c49dd0c17911d782722a66a929d58debd0f18d07163cc7ce26218f4fba48b2ce3284824a0fabae49ccb4a18957c5511572b34ae9e3354db9ba5f64b0393edaf786d5d6c15de0d8e637b5dea34965f84ca2cb6f26645c07d3420cd0d7eab43d348842786cac85c16602fd7724f3c725672f99af1532af0b272af2fc8398941ab0ce3d7264f0f93010f07f727efd019ed3af3bd2b3d9989f650fde26d4250a663b22d2ed759827eab7f575186c74abf5dd096ed7e8488541e75c424fb983f40647538708c04716d83071e4b66f6259501f840b07fc21b8ebd8c46f6a9f3de2faea0d6993d6b4516a10e025a486133aca25b0190f2dd04b81bb994824cd3f404969eebbc40f71e326a4c6797edd9597e4f14b68e121c15df461db121d73b15fcb59c9299c820bdc52b5f7ec2f13c6bae238cd9d044a2e4e5d2fdc96e0eb87c2c5ea5ba58c6cdbe08680886af181a35d3ee7d6b9440771cd21e80b113d1521015a2983c995e54e37a44005083f8f8358477c9698a0db42aedfd3f4ce7966e31d2754e402ff345460fd1ce2aba9ab285579ee69b93c7903b2037fbc68cc5950f0385a712f8d10e0abfb31ee8c0b2f67994a41266ce9a587ba72d80f004fcffdd78a0df03f272723079f3a588189d2f66f49111376eaa4ea81804ebe829a3e365560fe15a12517766a426671e8f1c721cd8c09f2f965ff7c9d5249de5d00f16449a09150762b65feba9cf78b59c807297115dc3a5bc9e1091eb395617e05bd51b40decc12c4c2ab00418720c121c3f5fecc75c806b3fe770bbe18193835279d2cfe187083f9440fced57236a74363b7a00d5f67df862e47b1441e9729d14fe513073641fe606848d4ea068fe94cd5d691f092480d54a547d92b71b117a8e867b3d40c966efef6adb8b2199251d2fef14235dccacde0575b3a7536096e318c94de91860e2df73803f751ac94296c615bd1d1e756dc4a80867050c9736a8bbf15134b85da55cf7c22aab23fef9f024f6e9e8439511ac2b1f22eecb0225c9525e4a336f40020218f81e59e68fdf7def2180a1cdcb2ab3130e60f70e569d6909ce7e97048f8ba01268b24cd0d61aa6a905983d223a8cfb1493f1bcfe2633131bde6726f2a451ae1413f7e9fb91beba9824a72569738d2be997b72458382f0b7a7789236eb8ce92d36b14230a6feca38ab310a450811abfbbb14b4578e204c8e30d5cde080e0604168a8de2378a833ecea0d38f874a410853b9789b4cf93c0bcf719934ef678accb5a96e8444248ed7a9915b99e02e7521f88629387599ece216ff487eb1a308966ba07ef99beeb5cab58fc607b61c0d2b670f006573b184ffd1698cf9bfdc0faf3e62a02d65be9e5b2c1d3f6a0f12f7d5ff186c235c848631173d00970e1a0367df3fb6f77ab09764648b4dbb84982e047e342c4983d4ee2bbc4bc55ad9383577f29bd0f302f578e44e7f7ad8670cf5a9bead84dad6500fd524d4fe23996c3bdf643583cb6b33dc01cc3a3e19f91282db1ab638d2ce196483c0b577584ce213de89c42ff045cd19ea7cba20b983bc3856dab4f5d33783b194a5a4de82d291189226b2f0e60600c7ccb8e2e33cb5c5ecb2f52cfe6e62b0e5b5ba2d2a5f10a2bfd479b3a0e006a820f362bdcaffeaf7dc08d0008b82dce258af15f2f49b31c43828888567039abb9e7fb0cb4efe015a358aba17d6531277d585142f1dd33aeb3bb30e23a401a83e1aa3cfdd1902d6af25339b64ed5342c0148b05f2753637198cc56277a1e49ebf9bbd1f6beff227ef5e8f199b928d4c43bb1891ff25d6bae6e2b3e53221c9f4dba0424487a52e85308c7fa070e9c35dc0bd1a2c58fdcbaa00db17ebadfd309571e5dc0c7a8daf8e53d5741c391673bd2b6d1ce8bbfb05b7eacd0cd22b1d19ead042d523aa869729c6ed8ce7fce3ec753ea5a399981fc64a5ade886e9f3c64bd80da1ae97c3a3e06b5547325de4c2d77a165ad48a8087ac52c40fde261c8ca99aad601e2ce0017353a8edc010f7ec19fae37e3e45b00f08cff5b7a97edd5a9da6f9e50c9e2eae26ef8085797094afbcaf599cf6d33028b786f022ef73538c5b306de7d1f30c8cb8ccdbc8e532ffa61f778e93d21aebcfdb0317f3192333afadae40becf4df2c980fd7ebabdb03fd61c115a0f316d0593fb022cd435656d8d5fd75dde59531891c7bb6aea0f24208ccf1bca1e333cf57dd0445cdadd9e3643a93012bcc5dc76e7cf6c643eab4402cdcd8e73bc6a30f729bcc84392fe7cc0908b6f46eb1c9dea019c66e497311fc713ccb763599eeab15670c6a0ca0f730eefdebbc457b3f897902d96da110be8df37446435ddfce38d8f94573f27c1fb5f50f4f10c06bdbe395bd8815eff878ee93c6915b7858215879a76bb710ae228993ec908aa88c98bf00159f2d3562d9881a4a78c95693d97e1f354f541675f15f4b8c65846c9ddeca1fc508137d02750b68fc3713de99fb56681533e55974cd723b12001eeebc521552baaa7c5bfaf6ced3c597a8cb196694ef15a9e71a92eff6200a9c9eee9f7a90eded7b7139c48322e2808a83d5ea0c3c7904a130399616e40334a757e5d825947ad961db5a2de157109f0764e83696e89d29cd0c52cb736b0b443be8321e6d23125d745a14e3261f881b80994132e3b30ee8f5193f581c8c8003f95a17a6256f6c55b3550f9b43669ef5f5d7675bb02191d8127fe87ce0f01a10d8ea7a0d30f6889b4bf8973cb5bef4595ae34f6d48148b572a4eefa54466e08fd9c915e20079e86de6b4ef2fb411d520526442ae2a07512227969e40ad881cacde1ec18fafc2a5a59fb6fa59e6bd891140eb63b77308821e24841c2c5017a9214c4a71f3f96e31e53e61a2547b6ddab7425ee765b7839054c3fda676f154499a5de87ab9e84dc010afe163916bb405b6a64339b7d835763a9c11a0cb6c757e31cbe55f70be3e3f62482798514cba5fa80be4112283d2adb04fb218fbcb4583f6c00a20681b9ffb133f0d0e7111e3362bebf26cf2aa234c97811114d6c31e3efa739b0a4ae7834673132c5c62ccfed26650dcc5122d04f616e3e35cb0562ae1605f189a0280de89d503b7a5f829ea45cb52614141d2406fc6d5302e6a72d0fadca6e3ef87df96ded64cb0fea20f7aec2c5efd4a65bab5ad78bc145e6d7d86cc6f55011af3d1e027bb0ce0b362251b0c90a7b56bd0ec5d4462ce8f9f3aea16c2249c03aa0c8ea33c3daa6917aa8e217abfe0a589890be650d44b89b2452dacca8e5f8e75a7d68fc450530b662b9eb1ea18119e1ff7416ce344d3ef29cc1e2c928945b10c3dae7c0442ff3436c9ae85124b54e10e6c0f3ec9e1855db534301d16a7d4b16256a0474c6f14c33b926878d6418df00e3d0b96b8e6ceeaf09de06f8ad1436f26cc6b7c75ec7ac870ebc720af6b04ebb155624403bbd2cfa64e5c20c55c195212bc23e8d7f28a8bf086945f2cfd9a79660b53f078817553922482a0515578bf24d686e431525f840dbad3b9d2705cac96a19c02ef4a2d9d43a881e12b095aac1a4ba453fefbb34b23a7566ee267c46025bfe248226c90b1ef340783a803d581b3f92d1aa6c73efce0d2f18c992bb811fa01a66da75fd8b991cbca32fe2056f9a449a3084a07ca02d219f5c6a6894777ed0584b0088ce0e346088557fe69d78a3604556fe6e58fd406310ea1c191ac884031293691bf5ce531a0e8d2ee504ae076848a4e82b18e51366a66167c10cde8df8123267475adb1ec7f4d62cf1df9c8746331f60e4a2c93594a65d5f22b6d16d2aaf5212bd276dbfda5eee3e57cc14e46e3e95a58d37f1bb6da9823734d8918c3690bbce9689d4aac0b883eb01b45ad22794b6374296a85144142985fd2a0014cac8268d9ba473ea50a2ebd9263149e971043ee72f0dd66d3c06c658e5b942e8b3be60c05fb8cc4f8e6accdeb1aa0b13c02cc12ee19cd5057672239ebb00dc729de92c181cf49a54fa33d65b3b91be555dc938d19e0e8fc42a635bdea1d338975485b66c962e21352fc28c80cdb8f7e5d24d142574c50fc1a54d4f7eab605d48bffc7ebf9ad83aaa9c508148f8af5a9b40619c6e53e62258bbb303aa6b23b008a5ff632670f580e578f58a3d1de728ab0a622599914ff90b31c1ac6ba253170c40af3c69066f066a6b665dfda9aa7da73b83551c2053aae0390f686af0cda28527901a15ab164e09d27d58a3e291d3dac00e3b4e4703f5186ebabb95903ee1184e137412a9250245323c0d389153fcbc9d62bc2c79d6d415773446acdb2616b9707954d98e109f63233e5f33ebdc56809971bdc7fe364931b850eec57be381536b20fb8e8e90770191a3653223bc3c70a0846ecfb2260e584fa86faaea19e1ba972517fbb23b9160dd1ace3e6e11f6ca711dd941347622f91c013ac5dd73d41d469070a3bec9e71bc9ed9136f477c91e8a024dc53631f8f27cef74f46a59c8d210279876bad40331d2c3f0acff907f0dcac392ca3921d634a54990095fa826d1bfaedb45741f47ed5aa202c45cdc192c8d7e210655293c07f672db8196df57075692e7916802f51e36de1c015be0f54d56e5062991c7fe838cffe3d5973377e7255f3ab89a3a381f926da7216bcf5cf42412c68e5430cb40a589e0329f15f4f7570977a670a4de8ed5e6f5211d24fc09a4634e31ac44c13fbaacf42dc4001e582647f48f786ce51edd9599dd36d5fef76764666b734040553e53ae8a4172be2e594479f80d44018ed30bf0427454172e905a3349e3ebf829ba735e2b89a0afe5a1a32385ffac4b5175d6870c7117d8a41e661301d4ffd4bd9224e24dab451e6e962050043fb57a13122f6e0b1138a0b4c8181995e5c4cff6bac5bd5ffb4a722a3bf2533d570e6e03a30fe1c1aac672c65e14eaf13adfe0d2d449ac8e5feb64d58102562602f7e36d69fce8cb8681e73fee96182156ed302e393b2dde2601c480165bcf23040791ec040686fc8cf4233ffdc06ff91e2a67d1ab9c081bf2f7d9bcc8c4313a3904b86eaa81d466e040c42c0c4881a1441052f37c1512a336e9c4478c4922d1b187dbf930ad87ddc62dadb9e99420417c7eba253a22b3a2b1feff31b4a24780bdc9a82fa7c8b6066656ecd854f79a5551bc3557653c30a1635e2ca8da81b456b78b097c60a0ca43e5f6443e9e3f2ac94433c31a5212df7f6177f54d9a6d3dcb170a99dce16302c88e69a117794c7a952550590ac419751945e7ce57929c48410b10958bc7b333e1dabc094bffb16c5a9ca53e0f083bfb6dac197edb37ded89713d5c4f05dd0018a44afca48f96e83fd5385ad3ee0be2fee39c3c1c792990c7fc674af3dce97ed246d60ba8ba58cddbf18de2d68d8d0497b4b6689276f0550f41270bf2a20d8e31fac269bc328dacd6ec89aaa1fc9ce31b064f61d379ac2da79debcf49af09746cb34b57dbb228a6db92688294eb895ffba0122280605a9c73248dfd5ba4238b48f92c18611530c6d0436417a700ae702842b513a712863e4179489a0f46ecad3c7174677c46fb974dc02541554f6cbcb89a491244b8e6e303df6f96b28e6a6cb919c697a74672c619c470b212ca1232c442a0bcb42130915e82fe0ff7a3b581898b810efcb750d4f71942c28518c9167118b43c2e3ce8909475e00d0bd02f08449cc32be331bf12ace1c9e61f30a67f3f9d3afb4e51ff6f4db7f681e64c3bb76df0de55cec4f410e7e04ddb623a2f2fbb6781b68ad6f3070e440000a26be833cdae1cf5bfdac713cc1bbacf3640d15603f8b2a41ff308219cbba06483b1930332f0907632ee672db2ffd0dc7112050d469de4ee0350a1615883f767122c9742577dcdb06af5f97db1cb1af891a05d56d4d6a08c2ecc31921adf5db761f0861025e0c1ef5a0f347b96e24518c13df61b273751726da247cd4472f29ae29523f8cf28d8dec3350e4c6f6e39e6029646cc2d19330e4e4159cb58d7a6c07b3033e5b60b5d8d131de8d6842807a729c9fe1d1f02228be5098843a7823a13b53d62a477215617ade9ad4fd7b0645e8ee1ed22202efbf178e6ece29490bc3b10a58b9797e9efa9fd4b0c44c2916ea672c138dba5d3f96d8ecb96b3321a2a1014ab04e9f7cd377979b190f728f44ecca5e4d38e71689cae489a4ec566293b43867c6b0503d4b5f094013a043a45a666633b1f2279b693612509e3182c93d6410b560886043ac4ae0688cf18aa68f41d82ce551e20862cf85d61c920651e9c443c8e58bc64a87ae789a86fb9d59b79b67374538d5af0590af47ac99881017b1fdb14828521d1c69293e67163bdee260a65625da9d039d13442b72652c4f2bbb26a737a584e6ffd019e2338aa0a2670f81e5640dceab464be457405cae8cc5c7359e4cc10f374b14c2681ef18135d6d296624d80e4a56526fc127dfd2ad3f293b114d3fd10be775a0a3d507391b3e6f3be18c1a331161861f6d954235e9355775d20a741442e7ce0c54529f44d8719c469dd8e2a2d2101f7f201bdd174d09b19bb741c62355587dd03e46777b0d8c19358be1d64931e71e5843d6e3d4c38bfec8e5ac1dbb9bcf871483f95c0ef9580a9e883a34a5408312115975d759e8347e973e35b2d5fbba46092a8ada7a9b6d68a95d61fd0364855c800122509bfea8a029f92caade909449c01b50090d49bc90b5c2fe244577f93577a5f741f8c867fbd9c141d75770e965beb2d81b826b68ba6cd304fa4fb544566b0b27bc8f136bdac12f01bddf01d0a0605284ad302b2061bc9a7f4a206b27ee824cb99773f3033b704d21fb0f4d24f78b2983ae038582a7ea52b1a2c5a575dbe41ac194170085523c42a0863f3868c4056c0571a601fe62f3f346852fc1b8390fc0cc2e68f7ef76ce732caf70464d3337b5dda7626b008fe1c92a90ae4f0717d55cd20e8423ff1e4cac5fb28959f00bde49d64b902f58b6ee98284bc6d6115c38e0ed00d6b41b6163b060ddf55d421766d9e3e7883d93fbaf966323bffabeeb470c1cae8a78251a7bb07095a4f450a7bca53007d966b25945a7c03bb7e373f3a645dce9ffb1e9b3c4b85dc5acb5d4a257bfa42aed5ac7ecd7cfec43dc1486c7320c82be2ed1601398daf650bf35fb7b4a65f45e9ebaff5275d70063f2059d19e708dabe8eab19c5b96ebe9902081c692f377a63031729647700990ab5009f1e2a9cb828221c48cd2ae6c121860b4f24ecd6a7e12ddfe4b4e74d21ebc7f967099666995ada57fce2fb7a3db123b57ffd816c356b5dcabd3e3244f69501a60f4ebda792ac1ba1acfc887f0c5db6eba2238aa051f182c72af8e32840b7f7d3585fcb1df229be785c25e40e4e5413a151e95f1633dcc4d44d37d4cf0271edbf61825e63936d8368a737a54fa86d92d224b140bc24a70d9736da1d3bfdcf071ff17b43d80b2db376c57eea74b1c575f28724309fcc15ccdf9350c2499f116aee23ffbba66f3bbb1df23a039f815047b082f15fd5259d6ba2eec50218cd789522320f5c490945e88123ccb78b95d829b30f97bd3f91b16e7c5ae511c9e51e4afb765bb3ec4cc8666e8939f0e23876fcdf0180264138961a8f454cb045c55b889e5681e4e1485d6fb4d87f386d585e5e6c5b28bc437fb1099477956679ffca5cef25258f9629c67c3a6a85500d30866b77858a5107038cade4a84f0cc905566e6e297a075281fc238ee288a9e8bbb95a80abe079a9899c96297317105d7523123db26a4411cd88a6e5a34a14825d78dc0ef4e016dd0e7a9775195294d7d52b50380a608a48cf5042faa9e68233015b0f14c034e4a462d20f8ef880229bc9ebc9a5d3ddb57d952bc34d7d3909b65c6a0d3623dc9170d308aa168e0ed791d3976a18756db5a48281f8d70f00a19ccfb653151c7d8e4a633a1d885b7b8222b01e52754d8d4528055f7379927540f62828e7a58d16390a84c2ab24c0c213fa9a5dd6058d2c5a05ae51bc086fd53de80337c6070bd1fc351355c065e878adeedc5dc1aa75c7f0c8e60198a048cd3bc96fc434d5a6fd1a8461e1aa80c6b26f151654cbfbf827f1a4f2c4f1e517cee9faa713c72a33a3d6f5c183756061698dce9135e11d790f46503ea4df95f229d04a3498ff8ef276ac77f2ade9b570c33bece74b1164d95f38fad867170cc87bbcd8b733434da4f1006b7d4330ba97605fa6b8f5f83f097203308e29880b3ac553971c70889a4f63e17192c56bc73d74fa5669965a9301cad2cd3db33d7cab5cb5d3b39be05605c0cb86cec1e8a1da678d041bf4f9e2cda35c842e30de5b578dd4481597457ec907393baace8695fd15402b8fc93ce1fe3019fab59cc1c58d8918d8891ba5fb715a2c5be20e0bd895b5aa8f2570e75b67b8a2255a2f8a8c6627cddd11814cf3a793a0cd5335f37586291d0094253bf52cc179fbfe94328ceb426d55a3cdd1d5474e154f6faf04fb05c4501a82484dd0ab4f931fae8071196b8655f3cb7c1966858bbfd4dd9931d9462d463d550e00eb42d5b15a2a29e138f921c9319d226fc746398c2e8b53da15c8be7dff85f2b31ade52a809ca2b8bff832b93c9f70be61b80be1837004ceb56ba89da712624f2400d07d95174f352416ce286485b02c89f67cb6eba5e0526a3d3d267f1e87ea30391badd67b04bfb866e044ee838d16643ed6622fee753b87796ae95a152bcf4ed2a123087c2e8b6804aba861d96afee473880362e34a3eceb901c9f4f1d0984aec5cbb7e387c0a5650240e27a582b675783901a33e93c4fc71a2a0b0123a1d5d4b9b39c513c811b863dd4a92b328f426ea3e5a9e14854f1c581e1223edb5642a99e38b59eef9ce9db75b48282d5f9102957b9209119228c79a4cb993f4bea58bfdc914892f9ae90dc71cab9d540a867de4d45e5d1d541a510cf691d3fe8bde05fca8c9e1de887664da588fbd86e73138250dbfefd29534e9f70a6e6dcbad84925ae7a562c9452a55600d48f048a9238ccdc66477a5a83fae1ce4bc98036bf6c96aa08bed1b8addd23f3cfc7c40663749fa6c23ca31cd6b63fb44794fef781e485a9f5e36c9a83e72bd873065ab14a73a3baa27a3bc8463935b78935c6bd9d090f98e2dfaa6947a3550b5aa9985f0022b35a4e903617dd44cf6f026ff4d8cb0ab791c613212c7382b8fa8648cabee8697b3b4de8976eb8725507bf5c4581d5bce5285d50aece718c1a0070c375143ae0a7e4949bf240fa0592b0903fb6fecbd8a6782f4fa0931fe9a8f3ac7d2e27e55de914b4244510fd5e01d81381c06e7d8eab9c675c19c0538950a34a03a23c3b6cd47ec49b0f4bfe803edd9cdeb41fa092c77bcfffa95ee54ddf58e3a32d76eaaff90210fb5a61f1e16ea459d0c515d2e18ccad482bbc827718b66bf89dde637ea466825d407d324f5ef87d40f4e49ca421b3a19f032ce8ceea0077ec97acc8627c6b8c011cde551b7469098f210445bcc1cea1e42d7301a4b4aa7aa6bfa7d4e3a86955b0e86e2a02dd87db5280f2c609b92c6b2226030db68c31dd523b10f8e1d8cb26d5f9528b5391f667d0fce9693d5acabd95b670e7ed12464fb4e9afee8a435625959e80fe0425a880d80ad0be4f9377febc7e3ef6093265df1612f4740dcc957c0351eae9b171c4cce60c793aa53761e78105f95ddaddddfa9989fb4fe7bda528f0c9d3ab0a3ecf7d15043d1b3f4fbd74a18f698d342247cf88dfb7d31f08ae8250e8ca3dc1e53a02d0b40d15159316404775c6a63b83109b0ff91ec44953be0f9356058a10bfa940ddddedad6986335b5eac789d7a439732814980242197dd79d1ba40d0d1869551525e0159fdb907b43ee16f2a6b5b471ea78f449f82f8c407081e04c6bed1211111680328d22e7499137e871f2972c94a81086401d23674a7e788e515fed5296f2a899e2301a902add694591949b9fcb16f71150ecf75c3db2a1ea55fc919a86ca7f204d5f5f336af7f7db35c2b82e266b679b80e9ee38cd5ebd328acb2341b5a981281d1a68b48a3bfec9bb6030fc500a5c9291aeffe37b256c0e5f4f206bcfcef1254d164d5a829371fafc0f5b0a2dc079a961de170efb7ad5d6b664a87676338f07202b07d0a83f9458a3305d6635a8c8ad8d94717fc9a20a8d8a433030d6585633561874a910e311aa585bcb092c8323285fb614140c8b8c3a187ffb88c176e5f4d14d7aa91cf0259ceaab2163712c65f3b0f2166b275c31aa419a33dea6fa5e682e1d833a86ae52561c7e29bdac24d8d496076f910bb29537665e88179b26ff7c10dcb777213fd851b101a1c583adc55034f5f3ac859c6de8a0428b70d82c2a9022898bf1af9c0be23389247c5d79fd931708d50a6d58c49504547b2662f1f3eaff6c5523da9c040ed098f0ed8633b9f1023a8e2024bead4dee569aedc0f56b82bab157ee0addf65794ab6773d9b3f4721c1152d9c5e47a560e8f72e48e9b544b18891212ca611ed36ab1e8da0e6aa818961fc91f2a6eea3b2b9fb3fa8503b9784c6c2661b02f54a747640105ab8ebe405cdbd1f2e4bbdaf082e0708ab5314f96d34240a24a9314f77795f3604a7a28b0b27e5c49e398e38400c924ad7e7745b0e568bb9ecb841493e31aa27c8045168e041ed1ae5a358ae4dee50ffbea60d5d79e84fbc27c42647d627c80cb32922fa163d571b7d3823921e1fd12b2bacc076e1153eabbda66cfc7c42eb8dac37445e0460ee15bbae832a4886f8632f0b53525e3a601e9a1a8d6e10030080257711634cbffbee3e6ae98e669b55e6762803052b5ae3ff4c58670da1b0339c20fc8cece6a06b7da0131e076247c653121b1d21e95a63f31a9135de3479f0ecf973b069ca70ae2a6afc6dc0d1fb8a9f14e1a63de82187e7f9fb7e693dde21424501413cd1b1777278a4fe481a916094eb775316154c358bb13d0a1d27844249bf7dc0c33196d3cd28331b70ed883815874e63c2ea870f89ee05f39a3fc66fa9116ba6142aec357eea30503137ea9a1988b839501be11bbfaf3ec133f414ad21fb1fb1f03919198b515043be7c5c11278c7c25dabeec56a238df20d76bf6047c55a91734f422a09bc8c9367879465034d178b9f59c19da8ed9b1b3d44566aa4d243aa8558caa93748633ac49d08fc7b4f48d0f023b1eb545afc9320fe85db88829a89ca621","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
