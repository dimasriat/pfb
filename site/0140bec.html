<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e3ab89b526879863037d1118d680f46bdb171fa96fccb968611a5ba83cb83c2671e758374376074dfe465d13840bd06f1dc3c7fc70df0ac61d093b349511ea5b596ac90233c1bfef2bcfe5e055b73331a69244a70522fee71bd923eadea6892e8ecf97b8e977d1ca5ba8a2a9a39313b51c8b014b20c294291088f42a44926763704910d7eeb0bbd3eaab4652f33f5f4c60ca3de3dc54489c400e5851a6a2673410837413c7c387641c61aadf4f8d9436bd1b79979273b38d5b2b36fa92b70b6b6bc92b6c136967b5444bfc798fb755ff43d559741328cac8e401de8feafb7370c8ce344c263100d4f2d8e664affc0f6d10edffef4a07556a8e76ebf9b07088396a787297a61351ad2c0c3878ba554727010b3c448a7798e4150d59602d1ce1c9072ed18d062c9bf1cf9c7346f075c723d9e6b2553f7676cec7fbc82d7cc92774e66a77e37c210d647a4a5cfdbd2625e086c14d5edf0007a9d479b78e99a9f2acbd87dd5308accf9060bf7721656336580bf0484f3ea9f42fbc467966012d4922ddef753b870900073a016c8e4554464d7185192cb25351ef43d4c2a90c9d6bb66ea92578846368e9ac4ffc7c6e38eaa15484e7aa53e13ec83d79a3f682eb2c7addd76be837e0ab84ced19e57da928132d40340df6042d298bdc8c9471fdb82bd9a2d8babeb8e02665c5e8c62985ac29de04b89d51bb04cad04c15424f090a3bb9fa3cc4e7842319802f754b71d66634d251eafc05f264dec2074453b28ec45fa317d818a44a4ff800d1d477ec18c9c1d7dd65ba893984f1995c409c71fb2fe522dc9c961283c75292209ac685018df43349ff4354fb32222141525bf9e92923ca2503eb2bcafb9afc518ae829272d11ff77a80e49a747ff179fbef3e6f8d862efb4b1f3ac056c0ccfa0a6d56b2a188f6bb9c6d8eebbcc39a06954c5a1b5afa3c3cd39e592fdcc43d61cf8a2fd08e485c02586cc7fa3861edf115163270e65434465e07e1cd4cb49d577fc759c7e6b8130bfe28cdead39cfcbe2b0db63800cd0a95d86e6ccd2ddb7d0922d2ff7a4a755b2dd4b5693da8abf8dfcc454a8b3cc81f4a6ab4702699eae13cecfd7556956558d82ffb9ce8602e2bc9a6ef8d29f7b6e432e8ef697a6c08a0fad07371ce684ec56609d6f9ab71d47dead8200f88a485d555a2ac2087309c1fb439dcb0cf3c4baea183d7ce8ef603999bb79077694495e016a41adeff31be0ef98f6f3811b532eb3c4a9cb0e3b74baf706ebbf34ceb277109da34a8344cdf2a95d3971c08d54d0533a29b64ed6abd9374ca7685c58223d7badd004c67031fcc96748146e8468802be8df1c008b7f4d36327701f9852261f03ba94b3e67ebecd86ac936da08677a607fbae9ced58018b485839501ee2d25821c9c9d21674c3bdac37a58428a791b3c499d282e4b1a7a9785da4149c9aab090a09df9c9dc569bd898f8bab9921de73463533940ca20b4ca1506d2911f62b8d84c0369fbf03bf5519f0d7e230539f125f23b4ff70ffc7c6c0b99e26fc8424364cade3b4adeed977326840c4ec0190c8c0843375fbd91fde1afdeaabfe65fd20d83d7872846e7c15c61f1f628450d3e3b5b0156ee6bcddb6e8691c9c30a5f425ed647ebd0b28222e9ee24c1a84a1d0b2948216faa8a5d4b0e1e11a145b684deadaec62a12b7d5a7ffcbe108c9b1899774ef4cfa8e4bfe54a50d00eb633ad06989e5f404721647df7b88564b94a275320bf06ed3705326ff272cbba9c2ba8ff24924595ea7d4343420010e4c521a22b1358f7751d47d611fec4ce1ba4ad4e658ce94b2cb3295c2d391eafde16de9eb536844300e76982dee9981e52149f72461e8acbd31be56d6c41bf785dbda2e2cf364049d8c4c5df5102965f9b58d5e695b332cb9df7ee7acf4dd728631515283f292acc40120e0134444d72124d2f20b8d04bfcf5e1c507087fbca1bb440a0c216b9c4f93bca8ef1e9c5643101b922bdacc8706c7f2f9056ab22a911e792c900fa8c70648ca568a43652c6da494f54e05398a526d7dfe5a106faa5a6e27ec29754933bd95b50fd8434eb4ee59ca0c1a55fb05b33804b6d8681e584d46a24b7b0995d65cad6269028fdcea4e16305d6aeee5f584d0ce05ee90b8810eeeb34bbf8d39cb49b9c62f75eb77edfaa46fcb6bcf5cc4191b830886fbf671859e3aa6258fa5fcae8ce7bb9aec714ffe1471b6a4f5d665ff5dbe43d54af4e9fc8af75372d784afc4d0a9ca312e27fbbc91ef77f278e5bfb4dd3bad76a80821f80deed0e3fd25512b27fb33b22848167242fa2ccd6f9cb267dcad6e660ba3319b13722db2e59c73911f8176c4dea5fffd391bb21bdff1c51d08e128b8cfe159fb24c616f5d55c1c2458384c21f2b403b0ea6a975e8232344a97a34de7472f9d754a6dd36ae8fc01cf0b8a3ffc37ae63a4e3bb8bfcfd3221e12847ef7bb0901fada5d177b056305a7113471231e5e7c0dd0e971f836f4dc2636c145417576499b3331c7e8255d96d46118e475db5cfdd833fbbc4108cdbfb0f025ea3bcac323040e8a45c0afe773ea33c82bff87a6853ce55a53ef000e56a5d92d21ee7665523af19e62ca15ac9a01ce404acacbb3f71e6809191cc778d14dcd1c6382bf99c59d47d466f6740bf82a66b21020cea58a5ff5a32c3bb0cf512c7fc3588319258c40e82fdb025c1f4476b210d9f39c8e1b2ad2f3b3165b07f29d59045d80f9e9fc3848c974344d8d80b808a5cfece7571cd29218f255d3ea0941857149d082dc981b8a1de8e41bec29892f4efbe7d2da707b3746b841969a4f8150d2de523ad67c7889a1dcd37864c4d92b21db6d234f964775572c7394365edb529b4d9b5fd3f259a3b008c5af54cb966819e691f4d923566eb95374a55af5dbcc6593ce0f99f2b2dfc7e13e5184c2c9c5cc5df2168f817d64ee60f68c0e15ab5e535c2214bbf4436d2866d43b7524677ed111e8f1a47a03027267e2e1fc937f2da04dfb4141a7c471b0cbf431616587b052a5af3c98082c6a7339b908193bba3fcbef5416d2593fc1ca5b1211afc9f180f5366d1862020776941827ce7b833614cd6bbbcde4c5f77380cdf1c98238fa0452f52b9c4c44957a1c3e65ba2f712d86caaeb2730a398f9245b0a744d6cb1707f9cfe9e87a15c36812d7815eac79a6d2e2012ae421f50077b2f8e169c093c942dd4a9f1bb38840d79428bae61ddab9f5b71cfb8ba0414b4b4e742f6954297bbbc830fba474ed52ff1d20d3e60a8004f3901c6eac16e51f83b8fc95320a72f706267f61a30ea2e0e0a08d71107284c51eda23682445cbcf401f60ea9cbda746ad0b7b22021312cd80ef434e4d0060de37cff2c3028d123a786e220f7849745ec0d6d8045de52af2c3678fb978d9af20e61013b9ce07713acccb9bd818f194763ad469a72a338e028396e6b9a1e9abe0aee001eb200e38d6ba07f0a1db0aa8aba38526500d8d31da2d9b0f7d26746684fdae69e27caafdf8899b6b72730c53de068ea0725ba8a46d7fadda3ea3382abb5ba85c8c5b336f74c6d1e3ba0cb0323a674f145dd7748853fd12eb5fb6a2038ed7b3456d8ee8ad1254269fb5455802e6d6062061ed1bec31f46f13077be9ca11eb02fdddbfab84910889a3bd124264b1a5b43089a823ff85834b5281479dd930c8b64b48acbc478528a336df8cc218196d64fa90a5dd46d077677f8df6510511a5ed2d1e05c68f79084e04f1cbe192e8845fef04dd6308d05b8810d372271eea1ec29232c62a2a4aefbc9367214ec55c3beb7b88d524c25dbf8bbf04e17cb9066375e4bf9a8a65adc946c5f583a1058dbb18fe4f7ee6c774d2679033a18d73d9c860896759258a81a983b49de9083cc12915b273575a36c11c8795cd14932923de965852709466525a3947ee70e6510eb31a77de8f160d08de1f3bb43123c7adb8c937b358f131888ac900bafc5e21c3dcb4294a31582d7d7573f82ee39db08fe4bb64260d58dee109d8e5c0dd0f54b6f299fa967bdc494af8a8a09df4ee4d18a9f5816162b15f350b8db426edad1b2a6883238c29065e4f775264b88827decc7f024af0ccbe0ca1ce2a52126fed1edff1ba2a51462c157e477c56ea6b6d2505233655303c7ca7c4dfcc37193f0340fcce560e6dceb7861fd86cb10b19606a086cb0ff11978eee6c989b5630c124a5a6ef4fdae42ed771510f20c89591d2577934a20071b13f81aee06cdd15af378c159f2dde2cadf8df196cf9d06991216362ced357bca0a79bae939dfbf902b53046a88c5a7bebbebb826c7ed74bb01764eb6069a5f8970ec13c9a29c1c3826f26c4d81278dc1f2609aa32fc9a259047f3a92d7c87c5535f6b32990a98785769f3fe245af9d63c0e11701f3dd69d3b89cb5285466b7d75749f8be6c639345efa2f08d645f6f5ce91785005ee2429bd2590067a8e1dda24a7bfaeea75205c11d5f9b52ea44801c8510c2fc22fde6c0ba4037e2b658d3b37961c334962cb71be7cce517298bba72d49407970f6745c291abbbb3584bc83a35ddfabac2bb4f75975f913b68df3d4e5feb0745ae1c18270da1382d0caffc4a7d8b9196f620f0b698995134cd28372a1551f7cd41f7eb71e5e63ffdb0d640dbfdaf7607f0afcec72cb107e44a0ddf14c94c08d63c9cca7bd58588ad39e9122304b81fd54fb2b7c46d4eb9de5abefc61db8ee7e26b654e4fda0c9ea9ca7de9225f84c10e77ad54e5ecda23e8dd14e26e6e1486e486579016e25c65157259dd90d62ad356295f0e682dc6494d4f47c1197b9daaffbecf06d374596d570f43782addf2ea7a323033b5d7d16609e9acd64d399ed597c514b96e73c306cec46af0841d1ae9b66f5122cb1f0dc7fc283e4fb5211d1ef3f64bfb58ca47b1adbd36534fa5de6925750a2e1f1aa602d43f55428a5062a91b3f00481cebd3a74514ea84b6bfc91e5e35824da022aa0c4e046d5e230f6dd74b9a04c9069e7d36dc5a33869a3a834b9ae86ca9f6a2f5d1a614877fc2d4377c5c8ee5a9263ca5dc0bdf3310df8f59fff5b8f1279fcae33ae2d205e752558dfe1b2ee843c28f7933017cffc609543792d995a5166ced13319cf5f4b1cffc5abee6afdf10d3cd842a14f48a1af5b674770f78d1f9cc986410f9845df125cb44e6fb5c803e7fbebdc92559aae0709f09dc608eea0d6af2ea808c54235ca6f822539dc8ef99c41169db7f89468182ead0ea1fb8828cf230d49722ef10b85f44a7b22410f9693f00ecedfba4f905aee5eaa5717e56fb9c230c5f2beee23293b293eccf2990c732e26d3c6c5555f23457f2ea79bc7cf01c48b6087aa6c562df6a1db95edf0e99ff68c7e4bf9bcedd79b851cd1bf0a6ad1c95795158d37a960347fa08cc06b2dc69d49bfda9b256e4e845be175c640881929cc3196522bd918b55d263b461239c41aa6179a8e7669bed68fea33a6b23082aa6cff17d7fcc3777d47e03c2ba28a61bb034caa87af0360a2c4fecfed2bbd961864232a4f0573b8d010f1e02362110c8d9fa2ea406940f83de87e0273fd35d75550cf8d921c57a410470eed11c439ccdbcf7d75d89b22602505a79f0a7d8c34085d80060fd82f6cc6385fdbbe2b73acefc5494476dcde2096e88d6fb0b2dc16baa26ef5e22cc68b3c249d36b8aae4260988107b51f081d7c081cbd8c8d2c59490e8dd9487486c0ac964c2d4111fb6e0661c4f8910b0186b82fe58105d910ccd68eecf0d62821f340675e909d2fe9eae5e04e57e8167292b237dde3f214a0c6f3fb22e4e261942645a15e10fcbc7983bef2e9c79ebea8f5bfd801422651da00e985637764e9c0c6310bec0ee0c2f0619b4599c392abf601708b9594c72ad05ec601b2c3e44acc616f1ce52e11c916c1abaef6fca9eef547eec7179e60ac1a462bbc2deecfee9e745871b29cd3903cf48df23da62d17146f826dab40c6d2befb4869ad33c011fc325cf6dbdbe26f930955d35b4748a3456b01f25dfa6058e430d9cb2aec02c57e53e8df22295d21fb347b30b046b1c578c9e3a661b1ae10f967dabd512f04bb5187a1ecfb232e21ff298eac3932a0aed2ddfe8ec6be0ed4b5e660b412492fac8e9e593b92520f24376c89c580b7d31792c423896d05622bcd205676cc59b6eba69c5f79ac6b1493d29bd59cf7df338c2318772c0b4b5fa1880bda9af23a5a5c7c31461a65c8c5469e9290bc6c3e411a3c9216aa2d2a574a086dc5016b313e29a2b2621dbb6b5f3e160d57ce0576782fc09707e095c4b52a90be493e495bb7291acbb7591f3d6619fd2abdf30e5d596a1bf7e0e8b99bb7c1e1ef24cce923d5420117a0aa44a67dd7d5ed99cdc6dec86b4188e0e2d333d61bb93e196ae4ce3d2e8c08e80062a565e0e45eb110ae3872c107af719d663e04f804b9af54d9de4aebc7e69678630bf1c5640e46188962f524d25c090b81840c5c979b483106fccf2cb8613784c2b56a962bd0b163ba1b10a72390b3ed6ab2a447603da1807bfe67f640b26f0aa5f9565afff44708036a0a6db195ba62a054b3fe974ccbe7dbd9c5dd19501e15a48c9c277e39a32be9e00f6b3774f79f50195af411ff6c6b51e10bfb0a202d2c7d5106c3fba0c887020985261f59fc5b1a3384f7efe9b2fb871469ac65794c0a41d9a7127ca93fc9fca8af857efc976ea85a83d1597e47472f9aeaa3764f979b67c28dd8665e5752985ddded3df4bc5296205aaf89845d449dd6a909c3873b9224496d3f5340618a799abde218184bb4feef6a747611bb3d7bcc4e1958d2f0f5c41b601b88e48a64a2c3dc518e853237471ae09c1c1d51c3184f9f0754da5898e8389332d229ebe17979b977877f7eb2eb8ef3157a0f67366d684d4e5e3e14c5ee7fe86532495ea9eabeef5d8f8024f3d6210641ab47192546419251d4b125934b38aa8c0bf6b4ca3e22259fca8180ed8e5185efc4b589fa314ccfc2cfe56a8a42e343f05deeea7b7096e82be5f10f2651210bc163a16a177a140a89b8c4ef9f5ca49b8942f3efbe368ea3ac75bed266b157377d10a4f686856b71ec0d7070345b5992e46da94f44a48b081d8a2193360ee0ed73575e22eabd370096dc8f0f1b54ed24c51e30c3854aaf6417d74812d88a18f9adb3e5e10245f92b61d3a458c33036bb0dedad5f36b162fcbf85376987eb3121ab752fc151a082783d28953fe5e407c5d793f613ae51d14bdfb7e29cb01975c9acda2194b6e2a1e1e4ad5d197081547183d7d2de52a7d001e55bd034fef17a46c6607221b0f84d029bbe0916b6448886f22d16b2cd17d12a0717883239598d9da67cf646bec7ccf9f2b5a487fcb3c40b08186346995aabcc5ec7a830a252fd2fa5694f3cdb08702f8ff6af58873c81fc62272f0b9cf4b0ca90d2bc8ae2d387be70b05bc723790a32449619c7ffe2c9af8bcc83e9e2934eedf4f05dcfc1811089e8a934727c45224782475ddb5b8ac00792c47a34980889e6a7337d3a1e0eb9fc16aa03695dbbd8f1016c579c09ab9b3bb36b74a27e8b7cd09263a45068f05163792a22ea3c9ec60abf27cdbd7dc132cc60a379de2f58b27229137aa728aaa7b862a5c005e12d2f16fc20f06952380e0849f438dd605551066798babbe77914edd295f9aa8af7ea26942f41c73596e9ed9a31c48d694a6bc4b8ea2c2fac8c4cf9d556cf0c295cca75d0302f37116ca1af6ef2311ba171323bd4fb3ee27021511d2f216858da76b57c20ea0b77aa11f02d0f82f6abf8ee140c5e7a7d2647589f83f93dd912747e7f42f840ab8405a51e07dcb6eebb523594ca3c00e05151f5def53d025060ef6c9f3d4245e4363f4841344d9556114bc5f3d1b702574d6b9d75384272cbacd2b122ed878295f24ff7e3c8037ed9df436c0b0689934a3a285f36ce226e2249d51ae04e01354aa7805e36f232631a2f73a231f67e3be7a7fd0be40e986fc3fb3be5eaf64d8a92d7b309d8008ad3ca3154e4dbc67e8ddc811e6b30af39a45a73147512f39a2d154d65caf85a80530683523bf960ad299fd78099f3ee68cecd3305d3d9772f703a631a2aac157f3fe0fad7037e91fadeaeb769734004ffa78d371ac7c06e12a9571f7f0acf8afa679596403bd4db6f60ecceba4bef7b0b3b0f1fa08dbb7e341f789d495605683a797a5cd0d7aaeadbd94f2d033041fbd249d21cfc192f57e2655f20f5ff0124b4ba0e23cf834e3582afd53e3468ccae246d53470f7f7cfd90e587551622aebc266b45ca8e02ad563a72dbd29dd18786af306bbb31a9e6a3b7d2e033c753390564f79dfa2dd6a4b05a1f9e57bdacd31f39ae3c2dec4aaea4998589d9b815cc22e6a237d9be49735e52aad01a7cbd847b8890e6a0cb2ce323fbff66944cc3fd90203ef98f95c96e59a82f33b308f56142f8ed620c40afd32b223df685d2a05728559bc0fc87bdb3995fbdd353b5e59fb113c7ee9c6441544dc9bf5b77ac046d7be2382808f6946307373cfcaaff856f24b481cf937bedcc504eddbc37f3d7ce2dbff19b2d4baced3c1a94eaee53f9ab615c876ec63353605ea87ca06520ce66d8d89e949e488c01a6912742b306360da4ec5dc12aadcb26a5026b47506fd7301f42773952f2df397b9f10459d09e4abf278eafb9088e2ee9201172946c2426c09d7d2a8860933a5c6e28668240007b396ff6b8a14246090b078b1f6577910eb4894dacd665ab8b88c48fa77a5452faf5706a132ff5a0bec7085d7de95bfac2130ffb393af8493a20ba5af8acd9bf1df6dd42d464c83677ef5d60d18773948ee3941508f53a46f5641947a376842f6425fbaed7332c905856ac5e2a62770c884401294e8a6a99c12a113f13cbbb2e17627c5b6729f505b2769ae92421583a75d4e7a7dfc4f50a14b54df036241164eaab9699db37b056ce8dd1681ae99664660ea9c68420d4b2860660c6bf07c0465dc0930cbf05be810ba164763c5fe05753ff6b16a03dbb6f6a81c8f09a87f0cd09939a7db94999d3f22e7b339ffc15a937049ed84a73ffb28623658ca1e62c7a9975a2ad14931831b9a0f188cea6e954864be3dfcd2be3b1c55b93149cf823fd172583bfa14cee33a1e411b24bf5887feac5f8e13637574501d9054eaa6cb1de1464b02e7e64b163d590e41a39ac0141c34ccca2c5c3dae062728682ed3129c681a309cacb22a3eb14fa7fc731799828574279b84124180179b8a1cc911f8569e358afd43d8cc44dcaacd166d6f089eab414835f5fa372addd0dd82e3b63d7688dfe1ac45672274057946b134114735b61e45171e29c3f401ddc3c0edfc871d7f7608146868ad7953c86b5b7e8cba86190c41dc181de689699d553843d9ba354037a6461bb297fdf75b92048b3d9eb5c2714a9724a6009ae99d30a7b7355d47d6bf6ec4016025aeee9261e8450e4f39a75da265ade392175a90c82332e3c753ce92ac75884670b458c6d568f76d9ad4fc946cbde9ff2d3efd5092c8b4680f037bb52dc323864515bb61b3005850a961d67c868119d161647b271b3ca706438df9a29fc0b8be41ccaf7faf076655463440c83cb150d6308c28ac64cfd6b9f9abab4f2c04d56504ec0139faa0343364ff2ad676616ee4279f30ca6828bf5aba86772be8f2c2641da67900d67ea985f62b251fe90abb7d27cc8546befd8beb9d0f7b166123c872e874a102296bcbc49269b66e2904f500058986ecba225f09bf445a4c4c55f8be53a82f8828032dcff0ceb5ede4ad207f11c1d04cc31c2768dc85f4ec0f9d43ddd75df54ffc1150d4ff05ba3868bf92f9608575469a70ca4b36e64ab70fac8d596e6c3b415e455755bf9c30c99020a5103adf26975c43fce710a3d9f970ccac437f2818e87560a062c304306de03567f9d67bcc526466fa60be660c487c092ba114f3f84bcb148f1a9bd81f8bb1a88064ebc7a34f491b0cf483222525738e0a667686dbf5358ca146f5e9830f8af9562b09b160e92e7e18ea5bbfc41b932aac42448ab62953e4096bfcb6742dcd4e46037f29722bb98d58f9b081a0a2b048635be7f738de8d3ebdf07c5952a854e11c9e150c2ee969562ca33e2eee73ff97dbfff9401b566cf43b8a5cfaf3a7d288d142d7127fa80e25bfc78db0cf3da13ad989a2f14fd2b0e9d0ae9047e706f132f06f7f83bce24fd85a2d1948ea99368392d633780379f4084e8eaab4d49bed090b22083b091497244582da0324d29018cc89e80b01fdcd8aec19a7de7525102eeb1604c85fb4edfa438ed54e8f2bd1983e3f6eb28311c1e7773086e3111719bb73232d3162da3fcc16e7ebeb111adf0da975bc59ff204fad40b9bf9209c5ea51e1aba306b999cc92f43a121fe80d400bb32b1f5a6e0abf42ceb5de954a53597f61a29242a31bfe6c32c824ab45748bc9e74ab6da4cd3ade230aae3fd456413a8a82094e54851f4f626b60ac715ebd3ced1d1797cbc43f4954e42a9f31eb0922a751feb4129473b6c5a6dff652f97529fee76c0620cdfc3fb62d6066549332d207d022558e7c09843bc23ed2e60928842639729810706128b1abefd94affcda3e4a596faf1ef9182edf3499bd428210071fe2c929dc55f49690fb4b8eb74bf1db9d817c13ac923680b140b062ab27b87422a352911e9f4383bdaf0ab145ab92eb65fae035d23de9e36b795efbcd67f7d4fe293a4fd544915cd4940561827f0163dbee375157082e27aa93de91428db0efe01e7c197dfd49745b547c156ab145822a17255ac44eb53edd2640564410fd5ff47d0854a8a3164ff35172b584db929b7e58cb7b23f782d8b8069413239166d4357f43fb2016721f5a662c4f1be2d4524ed99f8531996582ff11bdb31a1ce2bb3752d650141c46447315ad5ef5b0fe22bb0f8a554563bd87d9462b93ca96769f5f7ab37f62328cbdf0f65098cd18c2048b74c306d59971379bb2863f24e7e64b2757eb07d1bd5a7f778865b5b9fa7425021d0d6fad65bcc4cba156894e3691117a6ff91f2de3539ec995bb6c41cfe005af58d7e48ac92f29bdf77886ad49067f0f9a4b7ac61f0400e48cd971202ba106dcba4095e7adff298e8b58dbfaec44541a5e7c1bbf51f5939291d5b4cfe365e724789be3e5c835662b12dfa2669bc6e13347073d7586d8102e28b5de7c14d7568249be51dc7fe73603829deb4ccc130a9f937039be723ff603a6746f5abf1f1ddb32fc0c8545b1fa2c9be82faf162ed75bdf81d897ce1f11547499dd470a04022c911a704cdd2eefb2f44c2f33320eae7d29bc6df052e799e435ad61c7822a854bc8cbef98669c3748e432cc17e3cb51d64407be644e1c2b088bcf935bc5153e8c64442e9cf7b639454f27cd074843ed8b994f6f0f129530c8249ab9fa54857b006aa95d3200315ba0aed20a5cff684ed98e51dd637a27ebef20480f491c1111a8da0a53e789ed5b96344628d4361e7a361a4155d9f817df30dd343e61d0e4e74377e7ca3cc3f5dad3f91c1eb0ddf6753164e25606b71798bae47db1069cdd92773b149978cf7eff931885b07469b39ff76132dd712967d5179a64a05b80043a74860a82c5236b7835a21843c5df8a63b6409726561c35d9b91fa1e7fcde5b69446bf65dfb304034ebbe07d345e550d90a98159d870504c43f80bf847ed967b85914879fb4bcff0f0a8403d20c6d2555ea6169aca480153a932bac5359df698037993e779b8cb870a109a337a1d7b42769510d9ba3e535c77fb65ac845dfc8077f5efbc6a84046feb4d08bdccac244b7bacc7f27be7ff3f06bcb5f4e13f2f4c00e393832e4ca42c38609ec39b875ce3782ad980f2ebc47ccea450f304f9c55042b0b2bc01cc2840e4b024bd77f9882648a84dbd418543329625e5f1f4168c0fe6673acf2e2ac521c5b1acf6176c79f93dc17de2ab22f78a89431867a3af4118bd68fa583ca1649dd9eb0bf58ad05df36366242376e35a15084b64e72433cc03831f24305ff72469fb583726e340d225f7f5298b16ae11c6d18a09f3427ff7885512db53c300054c133a0beb1580d18bb895b428825e01692118c865138a5109a804b3d453d3f93b44e9aeeec01e5ca1d87f8726a9407ad8bfaf9477c4250cb8094fb4673b0b52ae4138625a6bfd26b9ee3b57e32d0b37789a5f57206c227187c7463e567602225c39a273321d90a576c057bf99c6ea6c743a4c0fb9a6dbfb74c6e20fe8a8a67a9024bb4de4d598670203610522bee3d2f520bb7841394542ede0324a0c2c973d84fa90d1c56cd240a9c395211bd56b1abbd800b7a9a3840330c12a07f7f05bf1ef9e341432a652718394770c0210bae87a9d1a2b7f192f288a3f3e7dc3c58c02ec4f1509bb8c3a6f045edc5b69cd9fb7d361e3f735a220f3b521fb0847a6a0a842d703900f4fe22f69e4e27c86bca0e9e5deb7b133de0cf7d38b8b4d79852","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
