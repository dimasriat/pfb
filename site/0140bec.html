<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"39b7e49c948d99d68d616926819b80f210ea3b48b67a39a3a5e92a9c2f046033ff289342fa6c9a4604ebe7c4a9b61c5f5098478c2b2ea95df1957f9180cf9fb00913a0c3f3a265aa061061d3d543eae183f6b9ade75006fabc13f647be8337acecfdd3ee070bb16932183e27e5b33d3a1c007f1a32383f1986810f736e98b451baaf252ba99d2611fb23619a332afedd320e3d40207802f06dbb6a819b9f3956f1a20210a0bb40d1886d6b5cd93d702b7eedb0dc5603c0a72354f66c9efda46c5c780cbb2e3b991f63fb80675077f28f4941ef24a6902f2f7a59712714502fe69118dbccc8670784c243a267f112b13bdc0662e9872bd56962a3998b6625bb1db26bff1f758991f0606a552d9ec0890084d4b54f44b9bde00b4967077e9b9b7d39e0568a3954b8589f4131fb4b6ff2051ba42c4eeb8057a56c4d6cb91656b410ba220e4b4d9fd7db1256f9d5c1900268dfba3a40a9286994c360d00f2148e1604e7248d8ea717737afd9e3a33866883fac7f94bd4f4addf90dde2d547ad9f6766631bd398534946371b500ad60dea79bdd104f43fb7a7e72750d7e4b9727484c2b92f3bffb0c5a4ad75bb63421f7fe3161d75fa41e0c20efdb76e24105dd8d0fb9c89b14c8274ece4b2489b57e0eb34c231cfcd5e45239f956a0b4093f22930144968fff699fcde888d040c184c429427bad3eae6fce4a0aa28b34d97e58506c0d879dd70ed74f6bd1dbd643408ef389ac70b2047fcaf59d47da11218ddf0850edaf2d8ac71c88004ac5b3a52eb84d42517f90a38568b2f12f8a2efaba6325777bfc87a40bdd7c86a24ee0daf73bd46571ac9a0370904f38019d093cc2ad2c79538b1002f0c7c73e0b6bdb906f436dda354efb3ca5dd99645af4d7482b3b3c3dbe45ad541335d222511ee245a4c903f0f3ac6887eb5d94bbe57c614465e3245e411b227711d009d8e4d8656477cacea2b593f41b1eb87cdf282ab158cd9178fc7045091e6299b837f38da1cb0233ade6479bebf6394581d8805b76fae44885fd160e3e79ab83b46cc215aec96362fe057e303177e9a95160bbb3e79f471312198b760a40ec86b9f82f05ad757f104ffb9dc27966c0eb621c246a09e2ce3f431c1b9018cddf931a156545a4bc58bb8b63ed090696349445984caf943448ee7add4d1d5fe4a4a27eadfac3fbebc75e2eac8eddb6343d79fc7bc5ec02bf545b8b6eda38780e48b6b4d131bdccbe7fa1b6167bdf75af6d9d6c566fdb809aad8251d362062b0efa716f6778b5d2447e955fd493b864679c0226e2b3f9ab7c765c13e0467e70f52062d0ef9bd88adacb33b15fcc5f66b3220ade0a1e89def103520753b62018ce2aa77f25cb67bcf735036184f8aed34b91a5ddabff4087705ee1db4b204a8bdc3cdea97015898175fa88f9747cb91bda9d08aa114ac1e2d72cec780f1bf6720001905da4a1117aa674ec34b142e194066e6a5848042974cc1065d4a99acd5e7a9531dee088a81ead53139b962d28aa6807e3d59ece9c7de9fc995569b9b08596ffef805ceb1113840d29167256c14013e32a8abad41386647dcf1c59d358312fc1b630fa9208ab903e06134ff1207102ad9f9b0a4f66de8d6f79ee622f6499d371b3093c9b6dc58a4c052df5252b20dc3223a191d29cdd4c7b869e2ec7227d161d1be010876fd18927339203bd0ea6201abce1c6ed3e31c79574efc29e90d73b6babdd136d03a0cedf4c3985d990ba887dd4cad4512b24775c4e6ef775c371cf3a060fbd18a4b8d74de9cdb193c5b759743230b098988bfad600dec7e86c53e0d1c7984e598dce541480950f8249b663c959975e60845f90099aa47b994e9dd582bf47a692944cee38c5a3a61ceeb409b78b760874f228f1cb79ebbb9d0d53ea6a7c981afeadef092211574eebf1f9effbd037ba2fa77ad2d84bd2242199f50d1fc0927f3c0b2c7e57640611cd764f22f2837528278a03067c9533e2a46ef7bcb9e76e057768332259b17d41d0b6babea77afb6e421e13461c8cc453b6bf9076cb04e481bfed9068a509b21120e884695190f5f0e5bf14ea2026d48e6327f639884429c5d324a8761eec9772df38f12846141df217658a5145a4facb1f9f295cca618d805a15bd664f24c49c07107b3f41ea40238d6e9db88024eeaa8433c6c640e80e60d730445d87e637a90b2a43497e89203be71e83659d873f02836cff51b02b84d388002a98b2e61ee6dd77e9d310328401a69e755300859bda8a6443a3e196f92d5266e7deaf2405498fbe5504bde8318c492bdd039dbca035c2548b4e53a6a2217c9827925c504eaf82c9dd56ff05afc50779717a30d80674312677a66697b1c8682a86a5f0cd83d61e63ce02686c46d2c352f527648046df32af2ad91fe724dbb4008b6003297aea604085360b8330a4fb002266be82aaf2939e9e5d98abf10d09c7caac12acc6f80d98c321b9570f6d946757242a22f4da887aa55c1b35968e28947f345b7f62ac7f90b3d8124e84e1855a0dbc108e07d52366d869eb7ea0270cbafc89afaf1a7a55d3f07daffd0a72e9310619c61e9b0deb17567c3d07024b794b947ab14e09be05b3e76a289c7c4ef4a2a64ed955709e71ab38503ad49dabd1efff9a543aaf5fcf2a3e730c29f39a22089079c48393bcd7f3946e4d6f6bca5701ef840ef372bf64dd0edb37cbd50e04de10fbe4af573e5a03bccd706b20011ed0c2f7422f47f5eea183ce819b3b608d4f94859d0865521fe30d8c4f2d4dbd38f355bc8f25eff223b1c0032c89eec285c774ed34c5bf3952f4d981147904e47833ec7cf41d9450b1535fc1d67e48496f2df42fb3665a887ae23f7eae406ac0c85bb7b685141706df2b24e8c2596736d38d784cebefd3d0403bcab29c719b77446e44fb59bc76b6a77beabd667cafb92d0674c2943343e9ca68275c58154353e2a2591b45fc91d67a98a3f08b2c02e691eeeaa37499832bc84857232e3780df675c30452fe05153c93665f8336bf924dc6e9698aee1616d437221acb7ed3b82923969fcdb9ec0858091b87928c0bde405a688ce30d80036f724b0f7b925caeed6062e799d6ae732cef2199aa243cf57c67407eb14ee2552a39d2927514df2beec4751b6f637c4ac225804d6f8f8dd1225b6222ed0bfa9cbb9050ad98419b5131fec5e2b0b78778060c83e6f522f80d9e6732e62f6478da5cadddff8a6fd8d297a02e7885bbfb1eb87cd6411f09b0e07d1893242007cb142f49f31ff6fc406b55c3c08ecbb6d8ca93c7f6709167f1867827d0ec0aec4e82503d322b6e8e97a45f8789a407b3ebe0944b7444cb4c261e97e3272dea7bbd8241b39de333d78f44a3be5a14ad94572e62ba50c623b7b7288771643f2212a9df035d128f73975f4a71720aecea95371417290323f009a22a2605f683f256620d32ad16266ff840712dd347d5ecc96cc21122dae6740298b21b1af0fc25ada2f89ca38af77ce69c66a0227ebb64e02c199c6a6a90c5371eca71a308cc45d1fd0194ac552394d049404863e0209d4d775734737864a5aa58c5988326ab13c3754b426628355156b27ea52fd43c1e0e0e41e4919b2c6cf51dc778e9e81fc900d151dcbd7e3003d4ebbc5c529c7cf16f9312e515712760861eb2c50d6652b53fbbcda5c1cf60b4bad4bd63f0affe2a13f698c47f92056a94b21a7e2caa857dfe3f446fe228adc3b2ea8c5ee14338dbd19d1159e77260af513bb9ef79bee59c1cf401359cbb2f5631e46b7dce769ad3d7fbd00a7a71af36242ea1bb0134ff6a4e0d483085617da7469d2bbfa3c53d9b35fd996909f66d2bf417485965a9ac675a58151c0da46d76997b85398f128a3e484240bb9dcdd8c4d3640a5d4a527e915671b954707451f03affddeb13775eb9536853517830237f18ecf81ffaa1455345437720f1fcef2b6e8e487d4e500998fec3d21a571e87d0b19c34e2889bdee1ee37486e8833d8db73c468744826b5b7532a0908139ec4ac4a1a0014d0da83bb13c1d45eb57390c820b71618c35de1eb5504cd3b9026257c01847dccf809ed6b68606e955ab3ef96e9755e5a75ce07e1e147e74ea25e493d08835fbf5dd267a0f5a74ac1bd9cddef90b436df5fb23e7acf9fcaf775d6ea244ad8eddb5a1a54e8a1c99dff85ff8b8be09e5137c0d38722aea67c4be42dd46ee3ac3dc164536afe47121343e7bc45209fb928147f5ba1faf465efafa384bab03cee414d325a0171bcda26b4659071075dde96b2ca04550ec9742a597b7701cf8a90d19253dfed3290f3be93567129d35bc944ed22582b10c83647311e749530ecd9475f438c38ca04f842229831f6e504801c4d8ec07205ea19aa06b83d487a998693abe14e7970c1d5fc6b902c976ac769e7019ddc817ad27a35173142f822a3705568e0fd91528aba135b230d06da543402812259131d4ff2d26ff64d2efe3a9064ef5f5dcf6d654b346620ccb95fc1f5802c36e7c09653f6e2873e08170a82e27e3764185257978df3012a45262d96f7cc50a6bf39db2930b86956357b7efbde8e2548a4b4eb94f0565b4d36cba0915fa8efeaf6c7063de7874670bd0ab4c2e10fd460dc79d14b2898c63a452f4897a485ce72d6b28f9137d3a4d94da75a432f6587c22c06cc3994649301bd9b9582bb4bf47ea100ebf56b8610b0d81b959fcf4b37964e4c79df9266f77f118b05e6597f1ca0f12ad9512887585511d38d89dafc448ecf5576b896938f92d78bc079954e9860f722c90629633b0ef4379ee70cc0a681a130a7030df01578157663d92e9a322b6f61c8f9964cdc50f62123ac8ef42413175d533c970e4ce275e4dcad60e64da9a48c314b95d36cd183568e2e3ae0aaee19b4894463c42c123a63a02dbe48aac3688abfdc8ec69c46c5a450619858a7fa0f4397efbc99d01a64bfd2ec3c6bfb9724870e05d56ef287d2a1382dc44fa4f342bab56dc058ac086df4c7d4a16bcfb90d1b67b9e3064e39bb4ae6555e267e6530f0e97f46fb007d97f332a77c0ed1fe21a2e0db87ceef515e97ef0eca52651dc603af75511ce3dffc45aa00ad183368fdd6c2bd7f795d613dec78537d74ce1a1db183d46d30d1dec40f7d56dc620bd1ded6c82550c11f81d3b1948c321ef021303d8147002361a406aaf23b223b4378545d2aed8f28f59aad811b7d38afb5b8df4300631cde09e12d2b3a66d1d0c5ca32578199fe3d517404d40699a36237e12bcc119bde760c2f2bf7804835f194237e2e8053981ce48688ee9ad69d867bfb95f7c8dce8a46cfd6bedc918b229539b140b851d6cbfd0c6d59edc36e7b498d336c4af8b1035811785f9f38e9ca3540daf5f0bdd61be381fbf06b39b396c922910c0ba0b4f1213972b7b568b693a9a4d18e9481793660ee7736994e8d7aff865a46859bb4091379792750ab897dc5c602037e55d8e52a785e7c0f7b225568fc42f94888bc55583a1f7aa2dc4176728cb57a2a0cf25a2e0a18c61a56253bdcee381208fabfe79ff65b9b58cfdcae4a63a62606a90e6c3d026dea0d12d4d20f92a99147e87f22a815dcc17a266a3788c224fc6150d83608561bd95c91fcdd2dfa4ccec4dedd62b480bb250284ce57db79c211341bc7aed0f96218f224c9f6bd70cdc687c7edd5f84770adf653ba488f23920b370c823cffd746b758fd9f0af4688c9a16bad2bdfdf8cf60ddd6de1c38c9566695143c8aef7682a12ef72822ca617cdd00c5aea29c27aef60617ed4bde08cbcb14e5181140f25ca081c8564e14e66138c9406bdec41f2cf857cae69767687f0d89ef26a3d98e8e06567d72335eb0686a2159bdd9e78dc0c73afb262bb6b048232396ddbdbeaf1b283f1aeb7b92be1e645decfa3a277d1bd1b66c90189b4e583c8b914ca85c433d1a9b099346a307789a43ba6328ec422acb85adc7c7c98f1887841d3932f90820250c0ec956893f8aaa11d681b747423f973874eedd5426a188c17b1b9502df12f97a131a83898ffd67c52321e495c89551bea68aec1dac93689ae17e2b11d8c2d80d9ec5006149e2bbc7287acee0c92844175c9485c2e3c113e77507bc357984a31588314c929f87070f296cde15780d950f8a469f7e20a40b63371c6f5edd667f0eeae0d64e6a1d73f53af53b8c6eee21e11f33198c8eaaf278e6936c3db34b84dbce9e350d993ad1b98e2ca34adbf5c9296e0903745695bb83f2dc9e5758d0a750811546a840d5314d22a79cc5abdac9644c941da7e532a8914d02577ef5653297173710a175ab0d5590df317346fb7c730291c002e0801d42c3319633542b79744820c037e4c1fafb8b35152530f0ede64fed828ea2655c44f4f98ae3804608ea10ebe1874e1e19109e8bbb6bb74bd1a55af763219cef83c52646eb8475d9edb2385dd5e66b42d95270f19bee6c80c5602a8355e0ce585d387fe0732e303ff1b954c773e1f57ae76aeab41764762c0d63b27b3e663a18b4b4ccd97ac7ad88888233fe20704c7e27aa6fa8153607a78672882dc7ea9cb879465354309148b899dd50e2ecb12df65ff29201aa25f95753d47ebee907e9bff36b19a30e3caa2e05bb3aff8d839107b4ff183e8409ac1fd5af51a2ce4b73be838ba1dd2f785ad122b0ab3c39dc418f7ea6fc3fe2bfd31d92a855a672fe537b1f83b5bd9569daef658bf9445335cb86338adabcacc7bf030cd1b96264efae61dfc452cdbfe40c5e48256f16e6cd90bcbcd73b2dce389b5c364688f63e423c330625b843e5ea9605d3c7598740ef14ff88e770d5bd689119e74b3118297a19e13ee32fe447db7f770ba628a4850b8b1d0fc369ed5df36dcf6b7f84186e65182a57edbd658c131a0599385e031c2db43a5bf14f60c769519ceb73e610a826c1e01c4eff740d14b5214d402af78c89c422f4c6c0ec5c87e969352766853b098dc400c7c1ff47b2e9fb6ba8c1c176001ac3c6618d4d5fda7da312a66ab3275d9330107675a0c94c1a7bd29621bfcb8cef47c6f3e65d4e2c9b3cc1dd61788f810884d2a49f88705e90232e23ec723f08f12df540076a605644c4d0f199c32e35c7d34a14ceac6370a7a89538baae77ec67db7bdafb5ad31fcd1154731b54d54f91268b6481a7acf5fb18d643f07fc8685857eda44ba7f09ea42e1d9aa1891caf06ee272e8221ad515b70de7a8a2165349aa00e6c04d23c337e11f8ff29eba17a51ea6c7065c1ec4ac32a0349f89bf9ce3af9c513d9fed8c4b1a28eeceb3bea1ee314bda5f5f7a19de8ba4b97d9150e2db6780bc9fc50d942b1b80c285c218637141a2a78fa71127ade3efe0ed036b4a4739cef01504cea52ac0a7e3fe7a8f594aa7d74576fcad34c0110d4281ceb65fcb6b41ed26b13244af123183f13f390ba4899f811cf7c47ae87bc604f26e4cc4012ab327c7e52a170acbb023626f5de21bf1c2edd251784cde18b71af9b6ecd8a28ca061f3ebff6685c8530a9c9021756b203f5015fc70daac434e0062377aedd45bfa6291d1ad49b2105d7117be78b703418f396a6f8cec60ba6263130b6ee8bb256aa736e7a0adabb12c52c9497d864eaf26eb7ac24d95def39db1a9268a95053e7342324c800e103487654d4d3a7b2090eea7d3b8cb87543ec0430b753c60d5df9b559820ffc54faba7070d5190298454e309ed7167065b8458b48be05fda3dc023dcececd4adf509370587d50d1786aa6e4551fddd325561ddaca809613f5d5c30ef621a9b5ff4534d4ec6534358d484fdd1029c86d310c9b156b8b2a1ad173dde2aeec88a08e331f52eebdbffc53cfeb787da3def84f545c895b32d6a46891cf58ee388f10ce8775c2d3d84dee590a3ec68b6ca272f6eef3c72082977b2860e67ed8f570be5af2950464b70cedd25b84c68b089f3414c72993b4fcd4dee16479cd7609b7076d3d139e9277bc9497d2cb831a34e760e62d38897f8497167e3a7784a24de05b0cb650186b1515a758f2f26ef480df185912698159a59c4ccfa8d61e732b42fdeaa84e212c8ecc3ba83570224e857c60289caa60c5e42749306e1170de46de8c569dccfae8b70eb373344e05c4c1562a5033925ab243a8d0bacfc7034bcce86ce825ab9dfd212edc829dbbcafbeb0f0773a93057adfddfebd48a99c417b4cd573daf5eb06fd1bad63f26bec0c38f68f3ec4db1b6c396bfdbaa7113b19d9b4c7b7fa6d4ef89bd3957398f045836c7791a468a0e6ad648eaf54e5911723f711ddd660aae1be39e5611adbfa423cba77d2c11950f7f906b7159f50e3b37fb7f6e3035293ba998da76ad47618f24bb5cc8dff784c82356f65d3a9ccead9e7f6d5a44230cfa09e5617d373377f1e7f7ded5b19360a487c4b229ab8032b38f7adf6fa9a60db526bf0c574e5ac9fb8d0686f7907e6aee20577b90359a360db5e2b60409b472e11fbb0e992615c72d2d5680ead6cfd751bd7533cc06f3621d82300dc5b07d06f188807838b68297b64bb360b73b7c7d4165c59b566b3f0d595b398a546bba658363cfa15ef97948119f49bf461f1d1e1c200facde8d530f2c4a552362001ad31514765570cde445c5066aba3002a95eacc0b81fd5939141776d8d7821475f9bb11de55183b8c55bba9f227ca5ab1a28ee2a3b30f4bb9bc350a7212d82016c112c7a96fe497a08af297752a8ed220e5658b0f3bf23817d1518713fa42a1614c919cf8694488c5a9f85ae0e7b89c501c16039c3d1172e006f4a43c29146ed5ddebaeacb586ad089dc3622f1bde7d03c975cc32126da82bf994cd7589546609031d759a1fb68ba88572e1bcf77fc30381ac2ff7cc29f5ac5cd29e91493f5cc93ca27dafc02eb0262aabf304c6cf6f0aac5fa77fbab0100b74b23609ecef23fce2008aa05980374375b9516984613834b23413bb7e7cf388b9d5af8e01d7dc4d58796ae347cb302539d34de64c03ffd256aadc8557ab923c54177d565f2c9c2d42522f960b73d7859bb94280e05d69473e83e420c3208938ced8090d1ae70c6cb2d7cb9fdee32b990ffa1f7bd8e7be72e90938ed1a06b68ec08d17c2e0b80a931bb3bd89c6322d49a00d6c40946317812beba9200a0ee786ecd4a677eb8cfb6262f08cc1011dc15313c65353669d8d3d6224ef0c34bc117979b2dfa219216bbf645cf83833ea102c387dfdabaf14ed10ed9b7d561e2169ada9ab70d64a6ede676c5712fd3c2b034067226b8c0a1f6153ed808e0908c454963ebc2e5d469212d3bb68946af06fa57ffe327add998ea8a1bdc4afe79f3ca444aebb331aed82dab446070bfec756f520ff72f52ebcdd178740db934c14913c4e4da9f2ffd2ae51231ea27a02f01e1ce3eca92dcd0bfda36162241a4b6faa94a381556f5a6b5a76e2308edcb31a3ae3dab8da9407f3ad90e524ebf99e51342caa40f17097030932957c4ab85cd257883e9f18f202b1533fa5bf13b56ccc304656d784c4bfe97f1072781a1cf805de76e04f512758be82b602594619c5bd2030d2ee0de54b22241f1bd61391ace08febc0ee7f30020d10762d4976d4dc19ce750b9172dfc62de177df91d203c4c3e72e5eedd2ca9f3cb61bce1a505b31019a4ef6875e3bec5f3f607fba9cb889bfc1fc6e9c818ca28cefc001526f9539a54864c842589ac59683bed1fac59f6954d3ac88917eda767f1c8ebeb75a9977a47fc9e06860ce5f2c7ce8e3bbe6d2b2c3f4e1c62ac85821d58c988bb99f61d2866f5fedfa657d46462030d2de95c714ad050cb5f857d6756d6315a093f2cebd249a980d3e8464dfb9748de9af24d5f711fe1940dd4878790e16ffcc30aa4910f18ad530c1df754e46c49297d9aabcae6553e522b8a7839c95ee798cea6fa5e2931f9a527bc4fa68596dc4e8224074aa211b56bb05a63376d6840cb6a1aa9144635c8ed309c61a94cdb1a33c55bb51c671c5122413cd05054a2cb06739ce030c981c99bd69019975c97b8db3e614c4106d7b4ad7cd53cd2d9fa258b4757da7db2452ff8993ad764c98b2660b3e38327e7323c9fe9a926062c16b4726b62d399aac74329a0cae3389df313a7984c1476dcb609df178bc321599824f36acf95f626ecf8f6e3aac9d43e5b3d9fa1b59ad9176f5b560f04a2451644829f7e826d6158b176a51af170119b2e42748476a68419957fbee54145045fd9dea9815f7188f1eaf4d1e075a0b44b4f1afc8f492613524bfc7e24ddd4e58fa0b65c7fc363353c43ec776c3024e803df8b050780793efdbdc599907ca6a3838e7ecd66b51c9a661e69407ba955e599ef6b349d19708c757e7745f08622867711af4e9e1be12164763514cefe8219adf4d1cda06e75c97ff427c667f2b475b523c16b2fe22fef112c68f904798f98d4c8572a1c3c457252d5b73b5b97d86c01039adc80720b1861f989d3d5f52229bf3e6ba626bd5d983a5efb212fa835a1d4dbfb7d8a194e5546a476d6e219a568374c1a7f3099f659de7e322740fb9450844a5cce00d61a50d20d3327a01faaba4e09dd0560e0a5925621f39b2db7828ed87ae1a18f8d2b867b388f91f90b008e1a633d8ee448e98478793135c30fd15549f84707d1569d2c59f986d383a2c6900e6ad654b711179106e4469ebe08341af10fe416b4f19c404888b9f42fc53ef38b9c579c2b71ad79375173435d6e94c458f7df85a3cf8bd32cb60ca1c8df7f63d55bcfc265138f7b0b728f3ad5315b97512cff6a52d0ff7b2da1eb508f72595cae78c3e992cb507746762e65a049465c9cf399c16553985b764d547699c586b5be78b18bde0366e2c971a95d1225cf22eacc4437d3e0601ebfd6f205dea3ba272f3db3628ae221e25689ff063a05ac44b289d07b496a6389b4332daf15c6ee95089625522298ec0a3dbc5692bfbb4b4dc068058598f3ca60d2a3a2a1d812222c9cda5ec9f9cd76f958a6c936fe13464d5899aa38c3ab5c7454788d9a26d44c2ad4039d19b6d5c59d75d060f5b9319263f4b7cae373ac47a5a11a6db9f3fa50f5a0e28d5800f9db001438ef796db5dbdbe01fc261fcb940a31d04d9da96108148ebd2210017c4566017018a0be42f3a218a1ca04722b79e2a03ea5c998f66340f5ad42606a30204c944d7f45043160cdb42d80462df038da0a212eca1c3884cdc697d6e3e40c329c8b95f9c604a754dcc2826b89d3e959fa79410131d6a206592b3d0cd1f35940772aad6249c20f1192d458a6b0fe0b3cc410f20defb22bc277906cb6bc76841cf8861f713c3ad1381103966b056b96fd341b77464ef81ac7ccb357c305e0568d6c7da1d0989240b29d929656b2e799d31e3c252dbeedc1835f12ea835d1a3282e38a1f16124b8bd57e0f4b2ecbd1ff0a4078adcb86d1ec67bbbfab008a4445bbe5e509a2df1bf3f3f4ab893fa310938f6a9679a414ff254cc5563379475bca71afdae6daa5730cfefa4fe4a9e7e2dbd22a4ed3b0050fc37638bcb5f206700b8969c84d1735edb1a1bd68aefb1f03afa294a410a74d00c6aec39ffdd1ae14de012346bdac65d5b8794cd5961f4c93efb70fbeff226fec40b9dc56254c0ce663c6f2278419ee4820105d8806f59a3d7fb79d8fffba4e4436e546ff66c1df8fbcfae268b77e86524b240dcc091fdd8a1716d7f7ed61257ef236c9ad77cdbbcf39b718168c06b372a56e1d1fdb2da809bfd069e9d95908cab9460bd65a04eec42fb373d256b272de29102e3ebe6b83e083af3afd9fb1fc690a67ff46bb7518c65c17d5ed5ca2217c4fbef7f56d9a6df5a234ed443ab170ef9a7fb269eda54b35134b8686596f7e2e7995f6c7338e4936f49b6fe3f0bcf43f37a564e9cebbbf04a92bf7a7d89e9e1d38e6e8fe6cd523a7996f19ef4640d8c1fc402d018ad7bb7071682b7f792b5f9be6a8f6e282267c0a1ab53a670d2d81071abe698e0d7a797a4708d25e3dd9b4a8438931731bd237b2f00790bd7f1c9cd675636179229484fd3bbae4940c8229b643bf048eadd2b9318c7edf327339cc91cb62da9db2c39374ed271ce11c8e01844bd27dab4ae6f6d994e1e569e8a6852fd21643e520e6384a1cc04ea952daf295d2325b32444fcb83947568999968e9a8b996c45766a13a1cf7d577a9626bac28589c734a7e4f741227623299c7fa90f4ad7a91bba4bbf094ddd175da147a1ec4b4b403bb0b7c03a396c4a4f74310ee5ee1a2cfb90de15ca00c3130e45e73a80b13cf3a33cbbf89343be4618836ba4e551d77357c6c2f9b346fbad9eab8af587fe1c2569040628d39be709ab318437e1daf28c8396805043f44b2598a7ca0ccff62f311a135deb8d4922883e40a4e1b3ea590f73fdb71ad7993e63388ed22e1e6f3db0e1e58727020ddd3799b157cbc6ada123522ec9504e6e310cc713f3bae7517e5ae7297d6b0c7e841d9ce16881bf3581f56d7ea5cc0feca9df28b1a9c6ef799fdcf47c7cc956e20af900bb1e0ff93d3f481184b79ce7ea42741c90e422a6274cea726376cc2ef034c0a89872779afb5b3e442b6d0baa8eb93a2258d0ce4c0c1cb53930017f3c9941f374dbe2f2c574403afd87fc53a737c31b67e211df5ab1bc9751a09ba81233ff8c31fc02a3049c0459f7dc0bce0e4ddb33ad1eb6df02a83035387288aa91dc5bb690b94ba69d4e7de7cea91721fc5587a9370686c9a98e4d8e1edb908a95d9cd04a6a82376fd97b3549600331f25a3db50271f037f1e7123dc358ccbe3d609d74d1a484d34fd5eb5c70cfb2153803cf03c5feeaa8a9cfbf0fa2afb14fe98a2982b3f80afbf3ef0e42c5b638b480c6143d7632b47f14a368fccc0e531dc0e81ab7eb1adf26621771fb3e52339ae1a8dd4c9b56b3923e33128419960aa957d6f845d6a7b9316ffa622626f1ac7c0e90257de37f821188eda25275233f688860cb30655aebfbdb9b47a797e06f14731461aa3a170be412de87d0b698cb7dc30a538728544d535d3b445b998e27ccd20b083387c8441f20280b6777a53c5df4fcb","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
