<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fc47d133219154c03073388d28ad176541930f2499dcad7620048eb06d4408b3fb2a7913434b7e7ab5c068b734d88a3f709c54b767dce23129f3c24d928cb09998213277f5b771b55b75addeaad9ea45aaace95ca11a132ab9025f0a698c7f1d9002b3b34d73cc8967065cf45e5b93ce8eff0e0d02422a598a3b188c42a2da476248b065080365a8e290d8e6f5745f1ebe7230dab7bcc5933e48bf576f1d93c6657d689a88dc23db7a4fc1d2d27dd8a5646d0ffbed06c2cc994f3bcc87d64ecb50067309c5a4d91aa799e5660819195a8c65bbef798c6e26df4c97dc44ad3920f7d6d2feb66f6e3ca29c2b135875dca32e4a3fe31970265460b638291a7ae1d9d3a6632ce596aabbee96575297f294ac4a31f16b5e426e165b68681272b91160f156c144188cf50accad34dfcb0b541fecb1e9c73dc0e0511908a9bab7bc6ce8d82c8801fd27a6466e91baf84fbcc3b0638d367c770cf744c971d36b444545002f677374e95380ee9670adc37ff3f13b827b431fb4095b047e03a3a700ffc15f6e70c8bdc6588223a594d402337de584aa81408da7fe2f98f8e2d671e73b40d6d5eeb390dcb9dcbb2e5fe563ec681fd47980eaa975011a6bdd2620f76785b5e8bb3a2079e00bef7f5db1b33bd31cd4b20c3bd66175649b82254672185b126c57cab103a739a358cd510eb875d51940e7d92f351e1e9acf62fa7ebf8da18e9d61501e98d89a928abfc852d15aeea8c722ac14c7cb0c3401a31d57b8aec7dca2040aefe64354f003cfa65342d732eb5d198c2653725a51d98f3d8c37ff54efe871b15dde4b6df90793a8f5610e3f991f1957088747207f17e8c9fe867a644dbd57fa1483d6fa20b257493eca7c4557d9e5dc1a0ff9cbaa5dcf5ce73e4448afb40a316cf84bdff056829e29b7616623cf339cc995147870ac7166d4a34ba1d78f339e464e9b87ed05ac3a90a567e6da3ac586514b4427d57bdc265151d21a17a250a44b36f438c0d8bf276fb6f990adf3f4c4a2369fbd78145c75fe76005efd59753d0fc127b8bab7fb1dea6345e76638d4a0f22e86f7c42a9dbc74e46dc3b09508660af4f8f633ba2e69aedc07aeda46d2b41b3b32c577999caca3670efc76f7ebfa78d5903d9db8c7e640ae23984bdadfe14d8f31e4ed690bed043ec6f2d4b5b157f23e617858873978390b6144299cb954296b008c61a91935281051c6a2a15ceb63fd13c2b3ba2741ad279a15b2bcbe8f07888fb353096e8ede1746bb397f1417af1d9f979457b93e336cb0586404dec9dbcd6ebaddd200d71b4054fd405794631407d5d242ada1850704c60839471fb0ea0198ee22278f62dbd76240b7e6a7217010437b39cd3986d7e00fa5c3135285e19123f8200cc1f6382d291626f487ef57714de2649e85ca71627f11e74e0d52691fafa2df86cc126bf02480bb2824f63f559cdc17da781f58d692540cecc2427dc1bbf7ff71f7a1cce3376cc40e1245a580a689bb6bfff0760026ba4d66264ec20e23543d0b7c0b16830eb1a94607354def804ffdc0c2981af6bb0f83afeb676a76465654f26e4ad01baf66ccb58642150f36ed4519a45d6789bad41e926a50cda96e62e97ceace6eea47a1782c11873a760a0eae5ae8cec9c394051f4703c3ab8e1f0298db8b5b27fa2f76856c378de63c323fad5cb935456e8e08c76f56995e9bd5f0245f2de548bcb4e65bdfa60db73c50079d884244f4895f86dbf7a281635729296aba2ed5c0b2f93c6273dccbb08144f2bfe0d94273a293b39da0e67c8ce4b3644240023087859036ceafd9dd5d1195ea029531cd2c32ab965526b8a753d1f949d7aeab31ca8132bae623ec78d0802b44dffbfb0c910fbba807cadc9b3b7aaf841f592cdbabf3d844fd823a63ce940207e75b4be06b6396625f4ddc034073f2940e47b46053af1b01e1b0aa01cc7e073f6400a1df56cc2623997b8e093295594d6fd5bf8d3585b17cb7ce19c6da65d875b68fedfb1e740b9de955169b8b52dc6fb65158085a2b06d8877cb331a33e3318a84ed5c8e1a3d652b0bd467dcd93e1aeffc0b4e6171a94fa8921927d1822fbe15f2f05acac51c04362529c02ea5a3066173fd1c26766d3d314e4bbf0a45228c52c896f787fd876152b55f3005923eae1fe13f5f09958e21391a8a3b05e84659beabbe60d97ae71eecabb85a3b2612de560022f359d3decca2b826267c27646d01f7b0d62b9320ef2595364ed53a4c8e522979b59d8c5c67784ffab0c4f14c703701320ffd5a42296d91814f16f82ae8894da52a83445fc495f54745cb1b3fb4f0fa503db70b635b4d1fc66f06c4ac412cbaab0c6dcb76d38e898e2aa5f00ca34aacd390e134efd68e1a0f2076791d2afe12517b68020cc522c07e9642703a4f1f945397e45b6e1daaa4452356facdbc6ee63eda624ad2d38b883985fda2c628733bc5e8b05d69fb39b9e1cbb22f46068092f7ae67762c59742e6cbf5b5900b7d8dee36136c42b0ea1ae2cd3488bd81d31faac64994e6e65b66261150a84c4f98abd3b868d6132193f123b6691c719c3b7397969f791b77655b82b0fca49c6b821bb0a5f44bcf022ef7aeb517bed5224bf69b39cd5be37b9797bcadebe0b59383447b144871fefc28fc36894d930101c44d91191d8985f083376099a486834ef10190ae6291e905425a8a30aa39012a1c9ebb17529c9c1b4a7c56017442d9c246b62a0dae23b07b6f429f84578cdeb2879fa55b148e34298facdc2e55c9167cabd05d1ed28e933b03e719376811805ad1274b84b56659bbd7aef64b25a8d369d21f7cd9a99852a8770561c0bc5dc85b6dde5847709b980edfe8df331cb5a6dc22f758514ab9110a55ac703d7451651e5e84812b6e93147421252efcd170783ce25456f41da4fe4b9c931b8344ab11017142d61138a339180888001aebdf11300353b9a58e71c729619cf74923bd880cdfeaaf75f104ae4ca213bf9779ee2bcb84259de3ddc748f7f9303e8911f09e4db33c7600849ece06c731777082fc4de02d2b1f2b6a5154965bfd8f85579c808e7cbf5aa65b2e925dcd1cb3bb2277e57e04f8f350826c3e8df227c7c4fb43dad0bf16f861729e8bb8594b49bd60e0ed8e2abce2c63e31dc0cd068eb4e15e517d6cdffc93d8759274b0ffa754b68cfb77f3c32d0690e8e8bf796b10ddf0a5447f3c20df2d56aff5c3e69fb1c839d7abf4b685b164aa46556ace9e6a04fb77b034aebd6ea710a1ab4c917f0d3371582144c2e67a3ae2428554f7ab78529416a6f39e5084c85f80c0495ee84a46d25f9dec063725ed9624216576e901eb5f8674dc3ba442671a5fde157fa4366ba5201c43c5487b2c51c5037699b42ccbfb3cc895784332484991619a4d89c8f475161dedfdf2cc665a50b1c7feec91904ee41952697d67f1e097d98527bf307b45d3c1bc4b4db41603113a7d8464f5717ed2832bf78bb7a3219d092390683fd4b457a210eb76f315ae374973c8f52a7544fe41f64ade68925cf4365e7c486a7bd290dcaa9e54dd1b2ce71910d07d2b397a3acd2f83bd5c9fb8eb96a3c4dd81a48870bcaeb81280924239373ac20db2e7274ef1ea0ddc590a02b4036fed946f166439c3efd5ba828bd327a6361dd6ffa8dabd0c11ac97e9d7582052794803b66f6becce2a1de4547a8e484908ff8fba41eef3172d8539a77d551e70360f462dd52f86148d5a10c212ab1df30be87f117f94cb5aa9df5233e2aa5fb4af0718b8a475aef9222eee1b11ef6868c5c8f5cc19522fbb7607917819633b4f460da4305ac334507eaac744688b5c6557ca0270ab3bb8b26954d424b2fc0ad9abc7b2fe06d4f7680f50bb086068ef2af7edc79e4404e7fafb4445ab6450915f86cdf3f1519b33597d319f426ae1c4f52c2208a804f5e0cd8afa14a425e3fe3257f9a1aab35875af564472dd5961c5e56eb313796769fdd5f97b0bb72f191ce977ce27d92e33a5276162e56d905a87a2232502f3cd60ceb9e65fb41c00c65fd425b228afd21903c6bdefb93a3ce8a84c78f1b3cafb10c4e4ef3ae4f3d20310d781915b46b079c0bb0b5b3d3e9e2fb9db53fd7592391bc2647a4cef6691a2b65ec339387d3610b4a7c19842d960eebdc4b13ea31ca8266f8c4e2a10992927839020e01bb66619254674adcfc3bc2fa78e38d975b4bd25484efa3754ad54e566a177731b34a059d2ec333359140291f76230a269fe7e63a6bdc71068f732494b9192bc052cd6f7c9b3bc0cbc6e8b029c9481f65da6a5a55f96e93f734f7160d046c7a4574a86d6ead76dee3a6a70a60908cddda26429bd0de9f7b6388958d8169c6b82f9d59e017b6aa51932c03dc66add2089c2ff3c59fa37bf79b16553baf477b475ad90ddd5b855e6666a74261bef40d649462fc6a7e4a5957fb7991123d1217b1b53ffe77ef18f4fca46e48ecfaa025089697de20f2437df1b7db7ef5522d6b1eabd22df52423994834d7cd877ef26d4669e4efe01ecf016389bbbb1bbcebb2acfe54fdae6a3855a91b281d490f95c7cdf9556db57d8b69e3ec4020cea6b1fb9fb4c7e8e33c3e2f6172a1b3421f258bf74c9aebd952c9cd664e3011c917806ad3322161032123586efeabdf88cd2de8069367aa902cfe82b40d61649827840570d66ce4b23629ac473055234e11acebf0dc63d69043f34d7430d3bcb0c03cd8a130e9efbc31ac824edc5a8c727ac0d60d656c10cc7a416a4a62e72ed7b1a5843d099790ec799ffd11b472b05a1dea72c259a4823b46bd9331e498365f5ab8e06b2fb45d5a7bf22e23ccb58b8086aa24ae6af2a18213a1d4b2793234fb45c7f92c9e93c684585fb5ff3aa4109fc35818454b66afce8acb667b1a4a51f89dd27b93a1085a7fc705a835547dfd17198adf31966eb55ee1a06880f05fd9c44498daca29f8d9248826090b26dfbbfcae02373bf63d772e16de01f6847499696be03b6a64df4f8f8b8ad30c2551c9981884b3a178c3e97d1442d098699d3c76d8b9bd927ca828f89164a36def15eec1b28714679a102150157dc841fcdd76d6e2953549273720d689cd11f86efd5438e15f7033af156de04c823dbe2e303b5adfcfae74c8aa9fca0bf526d32ffa7d363286e74d53386d184c9a1a8634681ffd8b4e065d517a0e9098242fd20b008065b96ca54eff34dd277c5d839ed0b15abc4b3510529334975346f47c374f9fff16a3e4d2f5c680490b107049797836620e6d832bd86d233c92156e59814df33d625fe380a2aacada332f07c483428dc6ef93890cae507a4714f9fb39e36f1378cdab0ac2e0d587df8a8a5997cdd285ac15ebf791d61f997ff6f84e3ea191a53bd79c9646cc74eedf37ba7875cb8b8a255382ad5597387ee6e9c1f8ccd9c7da3b5795411cd51808f52e7de43719284bdc511eef4bc750ba61f6479a21b6c9f98e54287d9ca910d06e8bbf9a1c545a45a03fc5c8beb205bfca9e2a127c1308e98137eb8b247c45f2a71676c4f4a63291841e32bad7f7effff588801873e58c1e989e096d07750660aad74afc4272bbd330c5b6ed0990b299a44456ce5adba40f259fdb9d5c45de8743c987a283c8a446ee6a738dd538306a11d4deee5c6316e7de14e7917accd93c566aaf109af3802592481f1c5acd1b468f5b88af50f6dadfecbdd9e05855a4da94bd751a46b378d9ce7afe2aa5f7cf6c2409f9f6bfcf53841ea91fdfaa2f25c0213d510955221584f0a2eb524ce37d0c2af274299a166a5f276f76a99670f95def7a91343bc3c2290fdb6faae0e9269c317410b57c574d823f03582e5300c1a7bcc983035ada81f84534234a8530f9444f5d53d433d69ee712cc3030880518f7f1f71b6599ae325713b4e446600de7e150a703cce779defcc870681e6bd3ff4028972a10f49f11b0677d8dc0e1f0aa7bab3166d976783a15b73f28c457e2da9e15948f1c90dedbb3946c985bf70fd94d7d9c3ee726cc41b811460c26cc6dfbd01cf3f6729f4735cfaf581cf664bfcf97fb110f7f39ff1f82404961ac89e2b2181ffec1a27252a2e854dcc12a7ad852cc9f7d16eabc5001d094313f18f99988b65c1d253a1fc04675f3d9225526abebdad34a8539f71782520900d7e208dfc08800abafa39d44edbd091d4518fb7619379ac019e99fe047a701d70f2a6babd9af1f503fa8bdd91672829daf140f555762eac4d7a439e4e748fc1fd53d70ef84bb986f543ebedc9b9ac1cf8b6af485126a7d70df26e1c0e2910c19a3f6f0251b487ad548e57be681a5099ebcdce41080ad5e99d777fdc36c4555da305e1b1d73fa78ef4ef1b5f74fe134fe91effa3c3761a1012a01ba09596fff6854fc68261990f9f5b12485298e85d9ad131e7c535d165a775ffa4214f80f16f605b01f71e704bd1c80857aea97e3c536c88bc815a4434a0fa01c1358f9b1f6397d3e27963ade5a5ed42d23a28c12e5edbbd005ecccff57308ab048380af103f5829218d1aa08d11d6878c0c6198da51a986e60e665d66e23b0f20214db4789d84d6fee0afa1eb4d20c36692c3b8a88fc08a3faa477b109d40942c2b575b5d313cd277afbbab2ee01cc5f9bbb3d076d7d223624c2c6a9bf5f8301c0447290f2ef92245491c866a65b5feaade77b0b6ec124d485d86adabcbb6abc8517ff24dbd71de0bdc6338f98a3e8913e3e6cb170d56e1a2a963297a0280222d3fa68fe5936acfa122d57d800f186655d0ae8d5efc82379472cebe0a8a233267c97b1a236ac9bcfb6c5ab80600302a804fb44f04d8c5c02348971da4289fa4369db945c56921ea9a292ffea0bfb97a878e456e872d749594888c6a5a9c086fa19c1421769643baef69bd7548755b3c612255c21c49eca19722a46b71ab6e8ed7bc83106c6cc6683779a040a240ced7049afb1bb1543d1b929a47c3617d80cac5a0f5c72c2d22031ee60531f8cc05bf51c625e599cb42599576979161bb062a437907a77c8be849cdea50afba4bff7103b810f4563a881d042ed679affb78cbcdbd84818782a7eec7e723690fb2e67f3007a0473886c565e7b2174bac6e23d88ab997385defd79c19f04429a6d098a53b36ea28c7dd41b63a0ca716fec63cac25bafe3aec1b042bf6c90becd0226275f86a96770a624d9b4b3a90b287b17d6d5fdfe126dd3ac76bf6309b3a999a64dedb8e89d5ab29ceef1e3173034534275a6b5766ba8ebdff154fb9dcb80bf172207b0c0e25e2be08ac7e27846df95eb715f3ea5255cf2817bfc6e0695783f12deab0ee540a361410f59525f7f79853a5f1d1298ed171abc29755f51b6f62ba9472d5d94c35671fbb92be68b4b88c860bf306b7376a4f1518e45257240b976671fc2eb91101ffaaa48e5aa10f056b16ded2bc5963221b1826b53b2e9eeaf77422afbd9701c9bb04f3a3893a996cf4df4bee98e08099edd3f9f57868f33421969135a746864440a4ad33e08532bd9be4f7758aae09f9fb436df4765f5d86002d4c4426a1aa189eb1bb683d2d719415d970172e5b6308ae8049d21ddef570d53e9c3f3a43cdf0fba1079c42a4cdf9520c20c5058fd182dd469639a3bc9e06b34d4b4ec901f00544763d8f76c9a940c3e57ccf51f3cd9764c0ce2fcda75a5fc12bedfecad5aa649473e9ed8ea6467824c4f848d9fee63cd8f57c96a137b790804be8af4e211b503a63b84d0030f5119fe339faa00bdbb6ec6ffdf052353c7f6878f01dcb91fa894a76f7b3a7f0d020d38537e9fa3bf812fbd632d969770ce9e68ffdb6572952aa66b9c6e12bafbf6001579b90fdf6c091c22fc9a8d51af4ee6e507cf4684045010bc2204d88ade83fc0e133ed8514f2f59f304dd85f1d500972e843d543d5ca67bbed32f1f1f3e237a13dd7d2104394f1e7f534114ea3cb8dd8c1d9c039a493cca4b72f49836ca3bead8e42f6411d7b5121e78af83dffda1432e419c65933930e00e66829f6105f12edfc46a18fc83490fec8a38f565ee57e7b19aa654f022ab5c0d87e003dfc91f9d5c281c06739c827f83298aabde7533c214bca591a25e2327e52889d59eb3f4ebf2795a5e4ab4ab45bf8bc814afbf36ce5a4acd799210aebbd439261be6183122255d37bc2906f43047761da92238e973e4e5bcf88f96e7a5e646bc1c4fdf530d22bea9caef89526dd1fa3ead7ed7d6513d2945ffe99e9a2e456cce6258b7712de326b92c1240711c9cfce9da43c949684589f128bfe50d19899ee68a45d8fbf3d30c9a58f464e66536a60c48afa2cbc3707c99bd815e2eb4e40820ca9af473917d5e047be272d7ec705a6edc085d9500f6c541c0a4cb41a58bbfe9bd10184f368e86db7c5138742fc24acf4958f8d03a0c259f8c36419f0fb0d00d11873549d12f4d6383a65df31cc524680bfedb9f8361efe7436753f07069ace2759f7d4a4180d8531d5b6de8b637d929f5eb2e6b0018a782b9f0645d334d0e3acacec20e47b6c3adcb92c1be56102a19f6bb6d691888ca3c9e1d634ca6e807a2498a55f6ec070179a39d9a0ccc8069d8d97f1f90ca06b38e2c6621cf96930674bbd0c188c9629a6691fdbcafc68cce5d7140fe3343013a34f8ed14a15a20b982a043612978ad0972ed62346c255ac9e1d3642f218e457932a4fb2c3d2100fada1b35866b6ce4bc278e35a160a5775b72b13a0ca639c9a738bbfb15f77b997c551acdf826398755c8d4bfae7d59b94879df90cd39bf84a8bc6cd97c937401fd2b44ebb17742d40017dcf0ec74dd01dcaa0a73e56c18a2e11e765db067dd6b165247cea770fa4c5e4d9e9ef21ba9d870986586b8e7b7fc3ee7fb6e9f12174009f5a689d877332cf8fc4a629f786f602890052a925da04953330ee78d61b2e674bbb0b655a093a2aeef8885be5184dbe07a3a51e9461048e1efc5a509e5d856960a7110fbc0c3d203241a6c477c2685509882523cd1c93832c537c2322e4d8961455141b2b912e6da3ddf77ba66fdd1e95ccd52f2819529d55c00f9162921749271824e889e448824a94f80223e04ca047ee5541ab4335b486ffeac5f23c565a9f602ec51c647555efac5e44e6983b724e60f344b57cf84770bec210b3138d4a5703142426f6e41ab287d9ff2b12e04ae5e0d08e7353558e18f27481deeb3c7a2197c1129d67f2f3a76366bee8e8858e4e0cd8813b61479bd631f32ba52f57f92d4a9d601102df4880d530b3c0db2159ba2e134dfeda76b22a6b5bac59fa202db586e666682bc857d09ca6683241b50d8e4a6d57d570531e9520fe70005a5ce08fa1cf335a13f50bff31d402038f9e0ce9b6152a93d9dced623196397e28f08d4a708d2b18e13fc000a0c63699785a34dd60ff1a64e37c3f45711296b8328c11965d8403ec82d337ba85af101ff00d7ddcc6dbcce7f7f2c9326c7200e124f43f08b74fca933e959d8451c82feb3a869e2f7d7c444b1f791218cc8b9ae72db4c8de1ffbd1dc3b0893bd5aeb8a0abee4960892d0710d11e8a83d2f38640b5e1d75df09f38e5d52d259645f479c6786b0d9461ca9b8adad89b48553ba48d6dbf7da4ae4535fd2e70fad7233e10347399b0086d5ffbc0834e753ba97724ce4e67f3e333358344f2b5114097afa3ee400782a82a7ecac00d9c007c0a379aa5de9b27250fd0d457fcd630b47792550f1246704eab56d6106a5349252aabe057d3c1fe1771886334ed9a34cc41ec3cb0da8a9ccc3a02d3f96baf86b86d3c12d5bc2177fd56656c7a0d0abcec60c13fdb2173b181368726356d9f622d3de00e999fa7f7992b37854e17b849f52d2da32d92cdd79557958b887d0439af2eba8fdfc8124f7399d4149f877f54dca6057d42f5bec43322bb291f91858475dd4473d846183593d45a062b967fb60bfea9d8d7cee168ca70f0190396612412e5f369b86b5516ed7445c119b470bcf38932a483c36ffd3f3a99eb0599ff01d3eed803a091d1d9d7764f75ed3c58997ee2e960082963e8f036f31e6606f88fa322531d3e35bc3b30926db12a265905b984837f0e03d45e9292f74a2adfeb5e4caebf05c234f8b17ce17f0084958e02dd425189280191feb10b009f77f626de7f56382439d84b5128c508f6c3c5f37d47d40e34ddd9f0acb374adab993057821a91cd1d632be06356b1d46063be3d3c47e0618669d0e3cb09fe3ec03b724c3c457f2af010aa117646ae426ac6d34fdc974aa9a953cd12864edd3deeba1d3eab456599a4ba7af71dbc5177c28cbb32de48502f4995311d731b3c5f58014498048414d5922ff98142f4716e1c728150af934a6610b20683ce18808e42299ca3de65a6849ad6e9f8dec0e99efaaeed7568a6d566e32f5bd0f0e92bc95b7bababff08f1b50fdc1ef36cab120ff56bf55ec27208c47d02fc40b53aafc659c268387f770c500209232186b594eeb220e7c845f3ecc81a9e365c70473fa3c104b02b93117a8303f68d3196a0ee4ddacb495b934529d410bf119cdc2f9b75120dadfb0d1e85195adcf0aa97cca263b3fd63cf8429310d02ecc61cd7b8cf16789b80a74794b6de4f8e04d5ceeffd40b467aeadf1ab5ff490c7f9a30b6fb2a4af55206ec5ded7c6910e4679e0186ba86587082c653e777cb166d3ef9d812d720cc5ffdacbc597977709e0f09c283f1ad61cbb30f73a9cae9761af28c2ddb4c73f03eac195f5b1188fa7b2ece3990d2f89953b0cd19423fb342985cf708c42c8d6389cb97cdc042ee587e625e08b382e9288aecfc769c4248480ddc2e2b8048a06e89cf64a10b1f26c9fadfad1f2bba8c7db1ba57325f8f59eecba078225e0d784d281023a9717da98020e2a96f4df70a53217640fcda4ae4fbb980d14fbd53e0ea9b097af48bf49e413650e39d8d9af92e62d797b8d5bd3ab5c7e65bb211c3f2d79db4e76d6571ddc8f964e357a51b2dc472d693a86606d7f91e35d28c610dc609029001ad0de32ca2c1568aea2720c80395ab4e0ea8758dceed3fe5830c25cf757bbb9d5c10a33339353d2a611a937052d3280724de6c0d263fb24bac23447411c96ad7fdf446bd2c3cfd857ae0a8ef51f0d83e2baaf4e98166c49c7e6a1399e9866af6f5dab37860edc8c5f068c8b728cf2b81369241140a1213740ff7e3191b50032e6a457fcb8ced8edd93100f64c6bf32d22cfca9cfb70e4417b08ed7c6ee434f98dbb65a090474049793a6dec895683cba02d5a912c14d7dc7296bc48563a3edab9c4232c3ff04a4a266a4dd69c570d89b1604222d4452aae84ad6f271f7274c53be20eeb8540dd5fd3690dc75ab633b16ebfad32557a8dbc1671625d83279f7ae155edbdc929cb48eb0afdae779ebb4831d8d0f5ec795d8b3fda3e08e1f7d3234411a95b69d4d1b6b6367d4d72faadd4b58cb9b479080af851ac8b12bcb0e0698ad8a2d789fa3eff28ba89d430f6abfdd4b1a6e0ba918d1b60b96c03befc5066c692e3f075a66148cb2b3beb71a4c462da00a34a1e080743921d4aedd1d1bcbd601d45c22717dc242949020b1ee9631c4acd48f837f27182149ab3b501a6123632a813c3ebdc38a6807d8d9a1979af63d96ba912ec340cf3d49961653c1d29f8b10a985ae7989f47a9aef6b20ac79195d389f82857b7f43a09ac376e69723ccd3f76440330fa7aa0859063af28726a894fd05d021f9a184954c12278b218bb7472a6bd9e8a2ac15b9c489fb8640c7407a115f6a050281f68a83546588a7714270cbd600b1686d833d8e1d582ddc0c0bf6e4e50a80cfdd0527f1a6b8f638c80013fc3f9874fe122c99dd3524a8e9490a9af595e1ded128cf6f5a95e8d630a4ab74c258c348f234f6ad042986ac0de95d681c175db9385fde7ec82777b886c962dbf0dc8c0301398028f9ba974b745b690a5b1d6d620606a129c94009730a11dcecaa1da8e3af3793bf7ff6d5fa201ceef9e1f989415f6229d271625d5a28f980534ddf1b61ffa7fb6b67b443190c01c01b950f769aea9d982ca2d794332f9c3185397eef99b94e84a30549b1a80df53e2513be1dfed735c144bbf27c4f8e040f73e8315509b6b271a0c8749d48b4ac6f6e702f932438b9b8217a401aeb8240dbdaaa8ce7bab173a3cfe909edc3da0e342310fffe597576ad2ef0ac046326d546a2415c6122af327788b7455f9fc80802c89104dbc4a4b7d8197492ce50fd0a99f70963781071c32ebf9b8a23a56c2f8afde0776fc0a53756cf70f933484acb9efe0794cbc63f2dabe3f5064ff55c22249707ea3146d4a5a6de632c897385c0f041fa966b1dc261dc78e145a4efc07a6c8c49f3b71185fce85e9659c77de606c5fa0cd6375d1dc707f99e651f19ac23c9927e1b8ef92a1c540f1982aec4509d15693bc0f01b28f1d23294b7a82b72fa360b121f507f43cccb55e35cb79ed47caa0862660922fafdc0f81385d48d87917454d5cc5feb06ab7adf747dc178cb8f90907d1678f661e63e2fc6b3f595274671e71d9138e6a0384e80f73a30a080804ad4346ff995c378eabd8e954328a7cb05532e54b58f79666a8b9b2a12e20def1f94c689025f72fc0c7711bc9f5e9996ea3d1bc3ce6eb3983b89634e8cfbe64025e83ad577869558b99f123401a4cdf9cf463daab4bd022ecb908f0f9457f3833a5decab66645a5f4e4986fbeb4f3088170cc9e39581626ba91a9de337d4d25222960c7f274758e5f2e42faf4068c15eda6b44a1ca729ef794463d9b77b77148807ac4f730d7591aa33bd78f171ff2c637a8742ae1b509216146318362a96fd7f452b7e3e57567d9b90eb765b0cc0b9a36895e8dcb8c3c0e5fd12ac39635ffc58401e496ec2472db60c46c584f89cea3fcfa533daec709b2bd0c08d68417758cd3526bdef636bd45703ff6d1fa67d9318befbde19ea55988fd2871523d13674984fc2301d4b3d3e034cfe738809713fc8c2b1810ab0ed836e3e0faaa07163496ff1f2903cf14d65dfa5964bd5d0b60f4d0bdc6dc1562b28a6481c6d8f655d1256fdbdaa","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
