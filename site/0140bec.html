<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d8e16c2de38b9fd90cccfc1a03c697bd0149027bdcc339c41a9d81af8d491e2cae714e97d84b803e94523a38076e20ce916c0f86cf94c25e11c26067b413eafd9349e189433f20e60265d574dc346a9376a39095b01c26605265a9376d41bb7ff6a751e9db98bf360b8c8c36650e8918ebe1f2e13830811530a5f8c0dc38c53880d72abfbbe3fce416d02a9804a8d96577f0d237a2fb4407c678535a6cf1870355445ec3d5355226bb419ea77fe90b93abd5ad1a72a95385d58dab762ddc35f159c2e98d71266c800460c9ecbe220bdba4f983020c525c417179d6c919b856177923fa6bee81b54ff84e000f1f80d77da71b906f74ca7526f0dcf93e174a359511246313b91383a6ebedeb916d70ae699f642287a6eab1f7b51c26416f679f5d8125ec6b9690b1733b75e516489259069d452fd0d629673ef14255c311c91467339b902681733df5f565d14c3fdcd705c877b634d0e26c0bae44a039c82a80dd348df3f5ff4decec1f064b413900a57ffee8864bb491b4fba27ea312aa3186a4c6082ce8948f0f5c8b2ac8612f553250955b068522bbeca1c8e41171aa0f031a6cc14aecb21cc5dc6feddb2ffc55aad429c92755f88c0923f78f3ed516fc33edec1a494bc4d76a50ac84f00f42135b70b3d758dd79ad8f0ee6f4702f8c13f6d9986ce729ebf6f0da2d3711afb06f6afa9836017a1a03037a66f06da160fe70ed276c413bacd2fb2f75429cdfd1b68edf99c24184595c2852ea689935edb4994b3cf1013607fb20fb2aa700f6e60da631bb993e6257a92704e39c1f9ce251e195b6e893e88ab350b4d34eac98faeac22888059bfd486cf6146d2938e3fd41844c3df2e6770183631e59f15746e3c5fb7943b91ee24b5247d18b853354e75eee5b62b3e6a16d79a4d327087de715e3bfff309e52e8e99f21167692d2a9969dd7e0a842a0769a18899e0ed81ff296edf953095b1b22cc09e737e8daa77a2dadc81edf9907d2efca09a6bcb3fe0aee2cb8ff45411a285502177478fff04cd3f605d5e8f032332894d19bb8eff69e6d7eae9f67ea9f0a9f775871edb30d422a8c7bbe6e10064ad733c5367b921d1082d919c0a2dbba299ec0a89932be896c8f48eef012f6127e6cef7bb0a129a40aaf24d3869cb17e28554f2c6f669f838b5f457ca5ad388b9bbd129a8f0a95f1919ead4c18391efa007d685b2565e706214e0998bc1777c074c89932536964ea7dae4d1d1eb193fb44187f3c2d6738ca48c852459461a632effcaa04fcb75281921b54952633520a02c9d392d49d68b795ff575bcf31efa6896ef2c9e16e783124cb46eafad4928236f1f6a61f6f8423a1e17af8ffef8e4ba4f638b7ddd635d8d36b2505f150470d2c6a796a60c6d7e3ad5537bc05600d4861285ba5ef4f9aceb24ed24ef5934243f012642a1d9d380ef822ed181945be24d0337d8aaa1720395d29a0af929271167fb9e7e63b68f20fc3fb423515a2ee23977db44d4071207d73260188cbea440b8bf8cfa515b2f4e5c6254a8ed46ef50633c1577ee786f8a709e6215b439b55452a10ccde3326611e2d0bfb17eb26ae9cdba70bee6ca94c71e93ec1ee3f81cf4a218519771ea8ab94e4b188aead6684d6b8870d635406c5b23798a74398d8f3c7bbd74c2998abb63c67eec8b5aabf016fdda4cb705ce79b94d5494604b7a03221e6dc782557c4538c152b9a5bd8d367e113bda90472c5ac13a82d070a7c96bc4f3dccc97cb5c547f3c7cabf247cbe353e6f34bf0de9d67bf8810ba3d1d5f9700b88feffd9db4a574d0ed8e7eb1cd44592007cbf96ee4d0198dd08debccc57a6939c0cdd7c5d0024fbae13bcefc00b46bb003206af6e899221c9effd7c565937e46bbb968d7b2a02eeafc359e9143e9ecf027fb5ea20ba63ad1680ac43678da01478739778521d8703e632814ee2f46292807a94c97488ac7f85e49a04235bb439884717ab7b7e49bc6de61980d6021c4313085541968083bbe217fc0d178f093081247427edffce937921afc46f9bdbd357e8f86d3a2d5b638a7571fb5c91470965ffc30dcb5d7339ae82663d344092f5835feb296c9c9f8979ff5ec160f78917380d5a97b25a15dc67c4f5cae7c62a28fa65cb249433cec919cf39c78c2c77c3583f3953bedd86b3f1e4e51663e7bca693118d751fe364b9b2a1127fb9e8e6764bd6aad3975da7580af59b0e44ddf47aa20f59ae0dbacce958b2b9b1cd6c33797f7684facad5c772cf973d6e29235517504ed9ede11fb8949bd85b535b31c024dd8856534ff2fd7282331a9ea81ed69f4446fbc3e9c62dcd6c8182a0c3eb411c8f7987d9acb08cd58af6238e88eb90ec5c1c284ca5bf20fd57039b74b3360dd81aeed3f85f80eb18193c6de764e4cc8cecbcd49bd4f91670ad86cc5fc28a2b812e16c4f49bce4b3ec92bdc1d4683733757ec6d84a3f846083402317bbec65d28ad3664c2f3d7dd7cbcea41b7518eaf6375d14eda81c80e5b4212f11b3e6df805e7f158819e5654243d45379b74630df8fbe1e234140295a89e0b3ec213d6ad539ff456b323c578abae9181e1b2df8aedfc5162408c3ea63bd52c2af251c3bf6611366fc9a799e4758ebcc5e5c3ba2826fc7fb2611b4c64f6fdd645cbcdc4d92dd31a00d5bbc2307000a13d8cacf79109ec907f35d952beb9e158e019c9912a48446e4f62b0918e9631fd827559de84bea9679b6ee0f0f772b3aa4d4ca6576c2b84febfc56fefb4a4b0cfd4786856f15aef841a47e6d85546d025a41f67fe9f7a28abb36d9cb07fbb4b488c6b510761022335a5c8e597d4727a7ce3ab56756cba38ff527e25adc4d907a84da222d4b81fa4b34c7308169a355f5aa1014a8e3fab79982f501b4cc4e53a59aedacea6dff8a500a83fc6bc0efc72f239ea2e8ea47aec68b57db2c4a019f9118a77acfdfa2ac4227f26bf7d75c2d78f100e79952fdad5afea613ab5144915d99586b496146ebb83826ee9ff0c30e4cbe957cdc6bfe1680b60ebea6c769f5d8344e7146a08fc31ef9b5fe4c3d8548befbbfe9158e8c6d166553bae56bd9c137ef58d07c85d46bf512f1bdcc9ad46326e77627e68956ba7fddb847b9d83d045d7424f7c1fa65eb1cebf5de2b588a7200450f3a8820db1569199510f01ffefc04f7e74270ebd35c1832cf7bd782866b94f984378f1905a8d7756e16511642850833f250ddb242d220281dadd0e48672d1538115f9f5bffd35da8d802bb794934f4800d4905e391127d9afdb779378deda8c075331d95f8c91fd4457b26522047847c770bdc6ec3e249044de44fea5473cf6eccf0bb6ef3c23b81f61087650a4064e784441f20eab3c701239c9c0f9180965cb69c7d5f5a7361891af7d056c3e82f6e3c5f80b6e68b4f309d1ba5294dba81b67c11df128e2a36227994d089b06ed3f6d20edb6cdd8008f2dab79cf77bc426033539c87d6ea06db3e8f27ca4b95ff01eb3c4a5efb402600bcd60593c6f5d235af81ee2357b1a08baa7daec407fc16ad6eb52c4bff5fadc912ac72b4b1a853a476640c1b0274b29706fb59b6b512d116364832e1d607ce96d39c2722422b5e28f91574b5ba6a2c3ec1b08376e96eefef212dc7bd93b3fee340137767db0877fccdbe5c5b1060f60ff37ccff06549182782113dd946520a769298a57972d6aca08fbe7db3fa60bcce4c8a430e3030758de4b2eef56dfef81f27c376bd47cc545c10650e8c03ca22e9a66d9f494e5943711db347fcd0ca062c672a2748e495f76cf31a14bd6980e21782636ef3957b3efbac1cd54b9b5cabd0c90e27d13a18ada013b3a868f55a0915f40694ee16e9494726713c7cd84ed58a4ea9ef42811d5121118abb64c630f1160a847d25ebe4985af8d3c49cadfce89f39309aaa1fc68a9fbaf93af645b74005ed6effa66f9d231cb389041d4b9f3cc532daeccd9faa917f1b9bdac1ba9196fe58256d9fe5cef7bc683bf043d6e14c36778d153576a126e53f37edee6d19766179235d03860173157ebb7b1b1ab77d3e09e024fb1e784669ec2a27745dae92c3c35ebdf12e7df878cbf6c743de4216d1a9108451d8cae82757ca67cc4f4481a5096819a78c32f3fbbeb589c5ae9835ec8f05c31d39b8f8d4096ca2512416442b541ae2d1ea7ab44e1ce8b0ccbcf1ac460e0a88b3150299ffb8d6bdf4a55875431b7206093a06ecec3e22cc1932cd3b70def8ca191d404f6cad48fafd77ba031c9359f325a8846444fe5156cc240f95dc794d9973b29827bb12cef1af39e2b2022ed961c6d98e187070928c842a6882b8f133a4dfeea46cc054a37e657908ed4e244dad4304fcf496f277aa5b1c09443b738a9c48004a10b52de1c79811fa30dbda99a4739347075b97b5408b54e08d43de1861af35e4c6144e0f25b30f9b8c50cfd1cbd6f4e975f2fc36288f3a8592ade9839a70efa1607815a80d4fc0a3cbb5cc9cf51a3be359281122f59601bbb93e5a419db241f8ae64861d22e5168d5b479c8207488255ecc4b207dd63ebaf18aafa56ada6d124dd504f613c04f6b8d830f04785346d0bf1339c0f45c95af57a9026e5866a95c41f79afd02442ad577e5730fc4c99d42deca6b4c9e97b2f7937534fa2a5df15d596d2a8362bfc781e84f8419bce7c91f7fff48203577df5c9e16d49a1453becf422b500390e393930a607a46c084149b33f609feefece4bca378fb963b7fa43d2bee4407733820e4360dd26a7c125c15c17b4b2713ae48177c27aed345e4083e3454c6fb96d1a6fca0c12fa88ea5e2b38e50ffd9ae5bd4fae6efe998f8c882e200accd4108fd867c48d89a1569554439c4bba82c802ceeb1497e99b2014f08216d055a96aa110bb6a6780aa7f3cff97f3d5a80c58afb7e3e1e0ce53a6d33d9be22373f8d2061bd7f8140cf94fa220b4f029d11552b3da72ba801da8d9b1c55794f4deecfaf47dfce6630fec8d089002c518c1318013b0795c7b8a2ec18a24c273b83ebaef4d6db0104b66d2c7c86f2e09bca9dca20521de58c73a16d268b18af216ddf03915b72fa6e798718766ee734c09b6bd51b6b6672786939b62426fc8e748413e9716070502e9f7ad6954fe991118229947e1cb24e6e788e1e0edb276cc2f6e0790372279488d132f01db5d9c4d9c798494a749e43bd05d19b0fe9d17adb49a692540cd82556dcca5e92e0539619270492b038ccae5f923e5e9cbe32843f54f599d6da8e5b74a56563d6d94b09aad42993838880696522717ec75a7a3f0eea42552a9088ab582530ea1e6e7ceaba365a07d2c9da56380b8a0b65c2a3514edaac6f9b7778f627e436217aca032f1cf6552b00702c0d7cd7f3655d49c9f0e402835b54a53bdadfed20810efdae63e0a3656effd8711bde3af9a9fad05cd398476aa943fdba57521ed8a60cdb655ea023249008b1f6663497a73e8045c8d974f19acfbdf0addae3d847405e2107bd7a1d181f08b5cb4e0ac8351a1de7ce3b87a14c7d36a5d68c70dd3d4e75d2a937ea9f8d0a4effcbc37295d9bd6075f4cf25d7965fd8abf18d6dafeddf316603f9d3415ee152040e155df21b6794a6a6d3afcb2766c6cc95c39c2b5f7dc68955acdc3d7bedde8fb2ed1b87ed30b486e58d9b5a329cc68269913dcbb0f8d995f52b9577b8a67436287b2a0851cafe98ba2adbb6d90e2b4106a686b0e3d7594c92a5aed5d09a7209bee2e10c71a20e25369d2e6b279a4cf18cbc5fda1d559ce39f6a71989c110e95fe8dcc88fcc5120af4af797e0c14b192422e5fdcb3c2e92eb5a0954ae9c8c088564321fa312dcce32043e19b1764158f2f29aad3cc99e7e39bcd9cfe4f242223da950a823437b152d212a9fbf9c1c66ef0698b7ae76cf9e8088e9e998b8d53830b6723370acbbd62cb024a28fa4823855296644b03780fdbadc7a0f31b15ee40cabf60e3191fcc2df64dbf1a5f8322a6a9bf1aedd5c9f75378c3b664c14557ce7a60411b321e5a07994351f98fc7d150787c17d3d45c794d6eb49d76df0aec5bcbb9e135037e3b568f976d1edaf9fef3c1b963bb8d9196fc1028a860eb8f2e5e7e4764b716b66204a69a78619e5098a0f523e2bb2ad37b5ccee84dd0283f585bf40f835c6f4aaaee6980d71eb6d522c0215ab062ed2420b6d2096a3a4598e6a0d4e57d653d8538f8d7965a3ca8d4f1b5848eb3dc79c37eafcabe61e5070a24aff016fce35bfadf4d511388aaba335692ee0f706abde2c20a716613f6d6ba7e382ce71da26e26ec9063662e4a2705fde90f4d478fb737ff7055e47c64772c8d2bb74620d8ab0c9c008e902c65126cf1d2dc1747c81fd2b6f4a4944bce9146f6309176edb6e11dffec5e471dd57d25340248ef87101b45383aacbe774d64487a2052730ec628a0919d935c7d6de8adbbfa62a4813e608bd0c1d2e7215dffbaacf7bb223d122983dbcf5af45136df8120204e5f20b1e4d1a9aa9a85621f2c02a6bed45b8ba6761b4bf700cc14a2c58f067f1a692d5dbe302443a3a25de32ece25e232b99a081218f468520f6511c92fbceae1bf336664a1543df2403958692f04343006521367e408f36e85c1848f069b849fc5d945efac70e8bdef3c8a88044a6a20eb3c59c1bd61e996549f632ca437a46f36c55220d3ef8686ba6f246d2cfbf6b4373d14b6b5ffda46b5958e6c26ff3d6d225f9a8a0accb4c1595560fe3b9fa50c5490da5e0a29577b123e6210f75990bb2c764fbdc6981f6ce4169b08fcd1792988ded79ef2e9e284676a736a2db02cd6339c8273de415bfed40ea339f61907b866a819408abae3b8600781dff3367c60e85b44dd0dfcc2bd9882c3339c2738c57cb286aef5be3a57540c24ce9fbc9b8a35e7fd5b011346414604a58a42de1c7fa419a3a11c02c8e876e08b93b978041454d3554dd8872debacce56e05b3d20bafac5664d64fd3af633ff49b98452def09bfcc2ce11a414756446339f94eb1a2dfdbec6a6bbec54123accc9e4c2d9bbfeb3d1090659b5f70338f3fcae347fb276dd498fe444841ef02715fe3488f0fa6c7c0a56a5df8c8a586e0987fbc0b964053b3f0b4b7e83e99da2d9fb8052b46aad7ab5b32ad8072cb346b08527e158b1d18f61383363884d496d05735ddf3f6b254e15b400ef14d018765f0ae4d302b522989c8f9c27a4a5b9e05f5791f418de7b2115b2eb9878433032c721a9568a2061bc221c4cb2a84680cfbc7251010bb20ab0bc93f12a071be00b4bd38ca24fe0653afc14e70729a0807d60e49f0274338547082b2f724eb45b1bb2a9c09666ee6971584d941e2026b845e7f7289e478662125b7498be52074da36a8c21cae976efb2d98bf7183ba1118a7c6f79ae989d56ca647989af2f855557a1db8429360ac4d8b2fbec01568cf2f0fe0c61e770ffee22ecca0368dc0fe09e52ce44b567e2e9cc2b09c185a36086c7e3070299f065d4507299b49f818ab9ca88c43c40fff83970f8d022a03793da779cb0abd6d7ceaad658ccd4425a505cdf884bf3b29744550badcec861ea248a4780d66b5d6281815b093e250404421b78c689bf8d070472cb929b8471abef164cadaaa66f471402db96574a7d84b9315e3f8c343c069c2d4f33dbed37f747aa237bc28393eeadbd3952eb6604aceca8ae2bb9a9de271acccdded2fcade39b1e773ceb215a68efb60ffdbfff189f662499ac10d066ce07074273391823bca6823b1255b2faba091a36d2be519a3f9667fc4fabcc95159bdff74db03c52207becd54c869ff9c5ecb059392146579a8028ee12c33e3faedcf3fbf8aad4e0f898eb212a9404a50d8cf7aeae183ba83e263dc438fab06ca77f645bedfe40594d5bd466c108a63ff8cb1944e5ff614b3418bc0beff2a41caf4442cce0e134cac2760af0594d1c6eb522b6c4bb190fe4acd95c06c11451e425578cfecf015d13e42cca6113189415fe63df8b22cbd5b315f81244a49cf1dc1d948952227a088618bdfbf761eb2ea3f3ca5dee3f6b43fe68d74c8b69ca0d3cc5a73ca9632ea2e719675edb7bdee335dfc8a3e42d91769c542831397ddced33685109ceced0dbbbf063fe90bf9ea834a0397c054687d63837daa17107ccf0c516da5e1b145a471adf0007f930f5d86f9593c5d46791fa84a531b411bc85deaf923d85d3a220d9c8a2bb7cb8fea1c4648d7d4bbc9de87e4b77ea74846591450f92f7a35e626a5b525e29d4e259b83cb142f7fca8727e3e5f569140f786a3aaa230e31ae7492f1b856ff75edec7fa6aaea001ff91f5a7ad904c0084911845beeda5b2b641fe22495d0705353d5326d51863f4ee602d0fb3bcb704b8b7a77293f72917ac0f5f136d42f48ed8adb3c18b61ad6bb30bf8e1977897531674e5bf916e8b9448d1a40861934f4749d01deeb9735eab9f89e440c6a69645913258938d2a5d727f8cd486c6c9ec04ed43b6ff684486d26d4b56c3614aec1874e0d7dc0df3ab81745307e7368050e7d91d9bbb796f5d480d4127fa023a041bf125406b5b36bec6267c743a5c8fcb80537381dfb8c4328f21e99daa9c0c1153093996f5520c7d3f07a4b03f4dae1bf374777278b65463868baece2c03dd0bb087bbe567ac738e916970897ac05d71578a42d6167a5bb7c0252bfe88d95c331dce78323e4ef95fa19300904de9728bc9c340ce29ad370d5a1333f88ce13bd735266e999fe1c59dce2a47487f423f8ac440c9900016df7b8c41e452f42de48d915099741bd895d9e5390245868d9a908544f1c9e030dd32f58342dda8b0534d22385772ccccb9a3d1b99c62bcc1e3c54041a6e23cbdb667c0358626a2682481869c62b2ef8cce776b9ee9544633ef86dbd84b2a03ecbc11159b69e953ea5d89b788b9daff013354074e10821daf6c2e536ffb540cc1c28277b1e9c488e5aa19ba1a78e3de81ea3947893d2e3b5e64b84794f08af0dc293047e9883551bbe9b3828d4d3bb53c610b58fe4cd88f139a3d616e8ef8d589b601a41139fff55c6a9d42e7ada02fd03212ac17fb2bd85559ab09bb2ad489e3ff171bf15c317005250fc584f9039fab1db2f3d2cb0a70d14368545bf920edaf02deb261974779a69d3e2431f829073c63775f2cf81fd72356f93f857bd63197c1b117277017db11aa25a56219f8590338fb918a6869ae394597d79b4109e9a93395dfb95d6a3a47a0ba8c68f10d0fda9f3787a7489857e3a053d23e1f47c6502d60c5cc3245ca70ff1917f987a2b9195fe446f94fd720be46fec6cf8aa23b402ff9182961a746a293d25611cfdd249d385374e03e1f526b74b86d44ef7cbfb88e3b2a04a36b29228ad79581e33f05d9851539bd2cda158c0321ed7ae09766a7103dd5d96d1acad59a102e181bdb9c39f7f7f0424f8111c6e7c70d72e8a4258354b738072f7d249584298cabbb95a40a6054a1139281fa1c4e1e9362bd1c95b93629470ee97d72de7780c9b249c3a432dabc3f4c29fafb3bfb7fc3bafd494ef564a890f50a0835519b51515b0887a74823a32b19c48eeae53b9d344407259f2c4210fe523dbb39ed228676db411a1ab92518a0d01eabcd6a1054132aa388e7edb24bd96c6828801dfe27e306f3a285971c5e354ae46c8b0caab802e2cf9b21c0db6f988211e95f3a16f9df0064ee015cfc1b85858173048a0f713c3a6afea03d4bcd42c9bed54e259fed467453ae700ab3c8d4142f2d0a0d05b9643f54b5b011fb8bf39525365865fb4058022dcf2b259eb8065750bc5c5e611a53280fa41d2123a25566e06e74e62b1ddafc31af103baeb479c7b73619caead502888efc6edeecdaf12fc5513caa7b9040ec3252ff64a83ea34e5e2d96bebb6f6a8cf4b185375fb30092ddaa42fa5b1150355e7cec3751b88116bf44166f6bf34235607886d2ff02a950265116d523228b1a738f05482f60ecdbe97bb70dd60587d28a4334a1a0e164ccbb8b8fc90a9297d3b674b3dafd862db679dd2455125689dacd87ca9969368bfb4aff636ecb2496d7f50c5ccab6f0903e399d76d3be146a52cf9a97b3f5ac503f23e79d0327cc1a6a0c6ce460c49841fc0f4f2f37258679f72dd5e3fb87eb42ab02809e15e39f2e002a5bc106f50aa2205c7443ab3f9c6c3ceb8970775e52403a540d233a57b447a25ae48db7e72c497f703ee0cc4438b18a1f9891325fb21bf816537fd6b22ab0ba90c6fda37114270329c1f39cba69a30a62676978d75f4bc8ed7bb3155522d01fb627b92e579ead138072ea98f1534fdcf257fb323b3b7f68b07f9307324d52a8b70226d818088cd29e06205180648d5a928abbb208bf3c096876a173c03e35d07e13ea2646e496bd62af2b2342720dfb9ef243199dad2a3abe151698d0b39eea910d613df4a4cf87bf5f2660856dabeadf0da2dabab77d18de6e697305ca179569c0bfb37c65f86dd3a41858387c0681f641a8467c7413e1e3af86769d5aef7e789fa4c8b1b17cd6d4e5a12d229154135f590a0f03fb10f69e43766ce7ebd8180f0dae9f02742db0c8925df956027803b3b06d9d0fd5746a1f231f08a75bc36815ec2e3d0e5ba01467d1f9095ec155c590ae5a3900c1f1af398040902217d9205d23aa88f4c241aaf7930d4a5b695daa82aaaed719267dac32b0a0861518cf7aa757209f69a463e9cd7124ef6a6198017db98bc66b7087da7540f2bd4fffe2ec915fbbe8e5d1ff4d67d965abd2e7d7e4f244e193788dbea6c774baba81ee813d8216bf022ce08b90e61f2525dd69b6d9d85864f98763b0a37f5d3c0d1dda4e79ec634ef67cd96e4be2bca2b7f2edc3286f71e22a9a1fa57c9c26da18bc140d98e1a40a41282a6ff998e27845c2ed7317ec625f016397695dfc779e40cb87e0adf821fae77e35d605fa0569da92293747bedefda8df47bff67e39e4501a95a8646aca203e31b45cb7e2e1e870a647ab753ac8c39764e90d5dcac96a177b898453315ce686d68f2e7096da30290466f0228af4c75e2577dd2a3910d2dabde591c353aa8c4217aa555533d06f0eebe212318b779cc8207344d3754be2e012050eb85a501b089a5d2a11c6ce312a4529b2f3c32ccdb7f624f69d81ecc1bb6d24d89cae8e77f2d448127792e9ce42a16fedcec87fbd6fe8f28e6a0a78829ade4fbdfa83e189e76ab9b0003acf2a788df71adf95421053cb34aee7ea9b6d99846d1196f5aa8dad13803dd8b51d871898ee7db1535bdb8d4b5580cc510fd0122e79472df5d42795d936ef40442761215349e17d7592deb126ec0d0cf870b5ac9e4c7de9382138b9ed6e8cfa140f9403d5789f5c6f46370d91d1f30eb546d1b6ee93928cc032da11cf2bc4d08091d6cc47eceb3ab20d415dde017aedb05925144142f3f1a47a6e28c024b31ee4cba87aa50b8d21e795106bf4c2541ec1eb3e890d777ab6cdf40730ad703c34b5de5a125ced72b4920b56187d0cfb9a23cf05f44d97e15abf3d54e5d4af6ecb5d535250be2afea4ed59d76bf00f3e1678c6076522a47229b7d80cf7825bbe5fa5eee5a73a4c9df5b600d19fa1fdad0faf9934ab4b8de50d3d3220618f610baedfb5a2d83c9bfde1a858d5e469ebcc7d3bf380bfbec83df38d0b3091a9333585adb64b1847080f8ab69e88b3c21893e897d861756f27c6ccdde23351c263f112e2c2d7c3620b5c7ab6b7c8aba9d6dae7d7aed5217d8ff8749ddfb1a8c6009b36c1542402677f7f1cfcca2dfb4d0f2ae23a372a6a7eb32beafb7bb88e8d370ab470a9abffabe26946ec13021b1f2d3e95e559ba37067bde27b5506060ef68db976d3293edd2479edb7e9822057e352e8666af288ec26b2f4274c9fef804c0aa4f3844f276c2c50c8e6026649fab24a773c28abf628911c3df3c94480f88cf178b514534fe9bd67929239378e2913466fef780ab21381cea5a8c34d5fbfa74af72776a879b218ee8275fb3c74fc4c3ec097373354040601d18a99a539ff0918f2f18e955f31c5309ebdac8374a4bd2fb3a3c68d1ac4251b5f576783ecef3976066880ceb67f59e69bf9603cdd50a4f4737a4b0b976c1320fed794a5c2c2efd925f6ee7c79da0292d0879ba0a5277240fc317f8628671fddba5c17f9f9fa21bb6a90d0e48428ef222a662861e034d83776bb93b22a7fcafa24773e8821ca4fd9d48099abc81f4c3429af55d74b6aa1d0eea13d8486976213e876e26d09027822853932029f3e59085780d602d70b2127c298031384b2ecc3d0e9c1d0bfab94a2c57d49c51297399bc25c388e25df9c9aa94ee2dc4c49e30667a2bc726c5cc64d3a9c9372ffc338c77261dc9b30e99625fdfcee5cca247c484b3f67a2c6d7d8d84ebdde766b7e8fcf65e6035c725babb8a6a3179542c58fcb63cd901a17296ce53818f2abed0a8288fac49923765e1dd926cd62a06137ec576dc3ef14db4775df96ae7d7ac21128e290151a3495a4d334b2738598d029fba8385595746e55b0965f3143290760e7d77cb2ddac7d29662293164c4f034cf6a54ef50e8fb1b40e72aa626496ec05f112de743e0e9468d27b1dc169c9c0dc503c06fe819ed0d3ebfb0918912f03caff551de1770ce8cdd5ad74fa718b8f4cb984a3aaca40f228a159e653d45c818897382d2afa997a8f126674615ad6c4eba33128799bd62f54ad8d2079cbe493fac171f4da27493718e62d061c2aad326e9d9a34b5f8dd754d20449de3a527cf64bfd9abb2150aae5d837a968d9a7bd78552ada43cd6d2230182a773e4ef74a2d68ec3995f55e305453fef41ec54fb01bdd4d401f58d082667f6f97a4768e8f61869e70a69576550088af2682fb9d6632766da0b1b8934aa60df6d9f0a2093b2aa7b4724d9fd602fc6336e0df491a98c13441ba70363b4c3e3287c9dd8ed8b6a19a8b142cd9b8a1eee7d8f6b34d8683e2944e2498f540e46ccb20956ef827188ef9b472de8537ca930e52da80021025b7e1ee8e9c26b6cf1033b96deb06a4702c0e005bd8cb8e355cce30","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
