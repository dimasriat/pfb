<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"32c16f4a3ee30df2c84ef1191c74aecb78f669fce5a220d168d337a5924561239a80767f2e1952cbcd3f8636e70a2282ebc3329fb5a73feb8b00616711368dda389498bd63502112b891b349104499c052dcbeff7e6d168226a700d493835f173dc6352f61bf5177cff14232f1b8196fe58995d859508aa029273f0499212c8b8818f18ac3ea22a23d10224ab1c13d0f4b9da51338c1a413411e2ddba817238232b27dde73b21b72ffa4e4343430d2d402b7bdf93c65601162a683ea253ff57e4d5f27433a12f6a055993881369669d80b93364541d326b4ee44bbec1c8a510cccf9a7a4a4c0974f84ebefc58d4587446d0ed4a9f112cb9c4015064d066fd75fc5944d34f3e7bb337410f4b15ae97703b9bda2dce4bdbe628c39be74f5a86d05ba86540ae3d3333bdcea9ca3f186cc133dd888c4ad878c9786cb9cbb706b97c306d80284df4863e2ef61dd52eccf2613216997abd53ae471bbe9dcc4c351b88aae5ec45c593e6447072df7668469a59af5e71ef4445e2859b85766b95fe18974bef3cb0d5abfa7db03b717551fb4fa94ce41fdcc094c114217a00ec4027830233b5bb79d3774c719bec6e6dbb088060c84cd5d4817fa5427eb633a4f7fa065d836c551d47cb780d75af25dea22ac09f24c929eb1bdaa7d0ad0bda5bd8a6149b5d2b86efa7894f81b1e1cda0c69aef679d97b50c6621ef7f42cdac593e32b42e0598182d7f56a6015c2e3a1919cf638cdfbfa9aeb134595b105e36c45b478297a07d9a372b883520d28d6d66966a9c4bd61b8ba32cd43c1dbce45583500d538553424e46781fbd0134cbc565d44b51244fdb4b90ed5c97b33ac4cbabc2d0a18dab8a64ebdc10d94546b668d21e666648f1f3e87faaab7c55bd7f0569b75b104ea7bcaa581915f77ef0c68c46490c08b6cb23f60eee5078e4efc516d32c62f361fa424d5ffc7f5891223b32639f0cb3ebe4b40cc338220e3101591d1fb4a0916625121aa8a671c1b54215b5d2ee5d3bba21d3f26f9e6f7b7e3d06dff7e82f044613c60887b08ec22470ca2ee1aaf32b1f8f1ee8dd5e50430b7324d5ad61b244fbe7c2cb2014f3f80d29e9faa5056cd9c4303ad12d94183871f65c3477e7cb2f4e5c6312d1247d152a4fe504f6defa8ff580cf6ccda12b4a9beee758b7ec2b8ae3b73e5c12fc165451eb85b5d7a73c1508004bc105f6d5e9f2cf5f282a8155c52f4fddc4e53ceb39c95ea087003de3e9cd490ea96dc36ebf011595f140c4ffe6062f3c1ccfde1de7101ddddea4a790cfbe19f0ec8893d069b94d59d8691de09a5d75e834dfb72341e8e94bf88b17c3ddc9a09cf028f465fdd6753a255a6bdedbe2d94582005c1ffaadf6a78b0342aa6f3e0f01defff8772c67e02c7d828df29a3f247b0a5cadada1c34238ca96c9e2201203aa22935dc24c722f2e2e17af4d87624ce3ac9cdcaf8e727adb8904cd716fba1635a5d04c3b6d67dd345e0ab9111a9a7e14f8019ac14d6590bb44418d5ea57e66e87a4223f5429bd0991501c7246f6c9249e661a185f7b1d7d27855144fce7bdf56937e6aa704ac2378c4affa7a13275faf5aee1bf9ee89ebe73cc73d717ff6eeedb789814d9b7b10e8ab2b3d196111e340bccace3e8a54a1b7805dff8b9edea1d2e19d3434635c56bad7675d59307ac0b8ac1ad2c37c8c472a9c64ec38e6c03184b8fe81d7355d09e738e38342d2f2f243a9dbef9c7e2c350648eb4e58aa8c0b35344b2738f79dd579f60a38f7d49a537e21e95f8e21fc859a037f19036f628753026129b5573690ac7f4a8bf540fd681a4edc5f4c9e1ace8e083f5158852ca06d33cec03b13801078144bbc4aee9dd48279ef28979852d2cf41c9be99fb97a9e0e0e20e07a6365dc6123fa4a0a849afb2cf577403d328aa6eef29d5e230bafc289c06c378d963e105c994e80e0f7701cc1476456b615b749cb2298ca737110340d0d3f7c32341d2aae57287100a25e92ec3e5cd2c25dd9ba0fd23a94ea5ef2f6187dba89c2e216f9b04cb0c00f44d7401997068fca1174624417428623a412556350df7349f08b8b8f1a14f09c562ab21a732ac5fd2559588718b1b747c90e2ea05ee69a661ab12f155608f01df9bef65de49cc84c74ba7d0562abf78297638678bf05e7ec2c6833f35038cc623b481b42fc592d7b9fd456b333b19a598dfa85e3bb3c287b18e46d169e65d249b51cc43f351291476498c6177382ee5a4a9b0858874a0e791e2aa633a38a51d517cc2349c930ddb45ee4fee444047af38663755da3d84d9b17f45ec9189b10dc40e6d210ba457f4493811708b879964696217520f8dc0687404960e0044acfe192d4ed75001401b03c0818720691d1a2e1e32372f585df3827017ae429cddc310d39ff101950d9b78995a6e34544661dbf2c4d6f12c4a882fd32622b81466d609b0c8b4f6f3d42c60e1aaa40a1795a96665001bfe7e0bb9e928f28688e7f728893e6033145705c07ac02643d083eab4bb1db23e3623ee0b18fcba70f25180daed718ff631fe867123eae1943a6bac49b5d6a88d2f8d5ea425002936bf0e85dd9b3fcd87e923c599a9deb4f7b954d6fcdc915f3b70d6880b73f3ec5d1947a0fb9153b352a552c16653b4aad6b204a807ebbc34e73f90992cee174f837f7c468f148f116e7eca06200042bbed85168737e8b70df792ebc3536bdcc84bbf098487c583afdafb45e294778a7949458082655b774535f5674924b2a1fddfc281eb3611c0ae37214227c3c966902bb70e23e2399ef04e036af93a776dacdcdf612013d7f98e0e135ba6ca54f98aeb4dd8a849c0fdfa598533d576427833d96fb5fa339aecc6469cb8aa2cf0b055e9062b3cbe2662bf09b577eb2113bcd4c3e1708f37044588977c09fcb7bcf9cdc26c3e9902af5724845b8026389f4dacbee0f5bb9bc97d98efe51a16058ca17df2e7184e830f1e228f9d3eecbddc297b413be75193ded127681413f2d49f83a6e2a079aad24b66c7c7e2053dd605b1bcf604d386100281171604e7239e6bdc5d9be1d8e0ab75ff4957bc242daa5453b642a73be71cc87eb6a3fbe355eecb3dee454183aa1f7b1d5e739647fcf655af533c6b282b5ce65fe64e6e2b82307a1878db96dec809856fda9b166df7aaf9f297e2394e5dce0429eab6f99aeff50dd506a014b2023f3b1fd91756eafd3c580bc240bc1ef159b26e03e753fc18d4a28b0aef8831767fc72ff36ec3befb31e797cc55f49fea7f427b4ebe7f7f34e01d02736eca9eb9522f1f514a857b43048846a7213d4914a20a85a55b21ea277f53e165a6db0ffebc7bee2c89992c44e041b09e6fc3c91b359deb019c4a4bdfcb99c4a1bdb916c901c6ff936b4d1e897f4f2414911d8308088e2ed958db02f7ade599137611fac3b905aaaaf3a20419dfd40ce0367c43c26f544aef43f086ea1b8eaa7a6d0d4eee381f06fd8630014dbe8d8fe0012e56509ba5ced437c3d94df8fc0d16b3c68f7ee79d06f0e2102cf516418ffd36e2267ec6baffab6053da127542263c69ab0665cb9772fd84f3aec03c449d6b775d0651f10ad1d5ff0916fd11e0bb6362e83aaca5316af5159279d9544082a12a6a589255d81383a9bac9e31c4b6623acbeb0d21ddf06622e4c7b60d7761e060407c8e25cc429c4f25b0359b591cae6c7624ba6553ad1fa8ff198f6a1d11b8ca46f58b3cbae48cd9d699524d2ba4d28b40db36151add03941038bb358745be54dc9eeee829ecc204223744766faefe44187d01c5863e55842154ff1d4972613d99ebd28c9068974738588e6ec5e6ede69d0eddd96c340567f4def3d0892954fd87e2abfe5e3a51042633be8abde1752eb1359673ea9f6c70dada1cf75a10e360f9a6595f0d66a13748867e481e82dacb0cf4f896344fe601b8e2b68b2936a3aab7210a06bf29499698ac1edee239e4183260984af46fde87c980507575d1a1492836745842048ea7968a86abf3389c4e82a05461ed81675dbb1eb38606ec542e08541fd2a0634cd0bbc9db6d3608d7b5ca88549ac4b338f8e5d99e6a271f011678bef4d1dce90b78f99f7b2d979ae45132709d3ef97ad596ddef757fffd7626aeefcd745b118473be0abb4450adc65f00ab7b7a617153793a38d193dc19d472f3e73efbe4947ba1962b24df75acc36b34af6ce9a5560e480a67fa7fc7c31e7c27aea2ecf253ea05c5e8c94149a0fe098742c135905367dccd2d0aed9ba85547f3deec18a0e3f0cea63d24a7657598725672d0ebb660b595bf82417220e5a5cff903a253b1908f930ddc969eff84a969d6c17fe861016721d041f80fc84ee505ebf2bc1b6f55443c177a3217018117128f231baf7cfe12205cc72fdb800904d8bc5f9099faf6300b9f5384b80c241f762157e63f5bff44a90eb5dcdc3cdea57a2f21eb2bd2da29af569dac7b97708becdff5ad71b6ef8e3c5951b9d9bc28545b0758b58edd0ba275f87b89da0c9e844846d471c29cc5088bb807325655e2321903397c837b1240c2668d98ccdfca8907e6eec8895e22b7acee3fd67dd091649dd4cba9821a03b8ba9d34dd89e8fea0666238b5be44a034d245e1087d334fbbd363d2e43efde3a43d91eeb99b7c20b4f5e405b76dc7a4d67baac9aa7fb169a2a8e43f52afe7c8bf06e0b3200bc2552137f8ec2e5d0e45ac45d047563966cc1df5764bd74024f3412bd55b6aced477c91e7e0d972a27713c597cd7441274acca43f4bc1968973f2ab66d558aff99f3ec117b7b965a828bf0099154b482f823e8ee252338dd674a8afb72ef2ec3dcf84964beb749951f0224188ee050a447555ee31dda4fe5558755e3e29abf91d65b0db765af93c854bfc4fafcb258e0e94609d3e5518da84468908cc6c6e8e9962063f5ebe6fe7a24a30cb8b2dd4ed312e073fe4aaaf025e03ccb15402a25e7a020bbb7960e4dba1edd98a9aba29132cc77840123a04054b9b6c63cdd51bc0b36f9de1fae3147b55609c1393c00effa09e139f8b41cc59bd5d8470b182f4ed69b662374023185b399f6ff6ae671847e14e1f7eea5ad6b86fc16738a705e60fc68a92767e96ea812ff9bc429e63088380a1daba1d3b194b4f0af284daee8576d8b34071bbc62fc4221180c6c340f63f30ecc9e72ed67b1ef6eeafc1f524a1b1f3a26e05ec4b07f31f383d67107feaf7909c99ab6b084553df0f49d2adb6ea6b55ca1f66c1976ec01078fce1e3bd87e98b93982b030c7aba19648d206273683cfcdcbda049b89e6811ae0389cd65acdca005253ce48172aa238f55246f687e08bb6bcbef4bd429ff76d3b54975f79102321db19f29fb424aec7e6b22683aa92836a439d18436957e23896220f7626cad5b9810a2a521d43d5a641775aa6c1da0bb4db66f3721b7874c8de8b04193aeed3a111a787110209d3f0b0003924dc1fdc6a68e6cf8e2dc5dbeb4b63ce38c430deefd1515b77dd137d43d310484da36fdbc39705bdf041347d1824fdf50ad78d975d6837d0af2cac197a8cbf94f96ae7d1885f9b41c5f075a3fb42696f1a0fe0ac32ed768317b6f9d4cceb51331f608bc3d38e688f5d13746f9c89b9f99b88c2f08e3df9cae620a8eec3f4568d076ddbc80b5cbd0a28cb6b51d81f0436411186c3eb5c820dcaa935c284ca04c522db101c326bbcba72c060815952e8766bc21ccf0c444df2a49a49923e94b6a479f0af602cc26480bcf3240f46a05b1effbe39d892d0b6d50ffa81dc5704b10eb9838153fca50123572b8e653f209b97b4ed5dee2e94d935d3b6bcde0789c50239b79e57bed65b2175fdfda83af4014ea866b33e2830fb6ca23ed4faa9a7a7fd5839ff41cc588fcfd9332f4f279a3e0ff7fab876f8c8d44fb1f2919323d5873cdc5f537261688c1037560236366085063f7a5fae481d98f950c86bf4b7a522551a5f63bb0a00ed824a8299fc903163025880f656f804dd54c403cd2f9bf3791d9d88900eb83257c2acee4aaadaf6710f8489ac2eb0a75d62b9311ef870cb6b01d4ff4021e23e7fd4b9cbe724be04efe317b876fa72db102aceafeab32037b78cc341dea6c523568eeb0dc63e71905a7ff33fce65abeb42d0fa88b661b47fc759c4047a6a1705ca20a00decfe58e7510f1d23641eaba9667b6f6aebbaabef31a1c379a9023715209d0831dda76381ec623cfa08ae462cc317bc170e3a74ad04ed68dbfbdf838170fbd944d2ebd51fefc281df7f3a0be9dfe1a22e782efedba78a46e86ffacb697440ea14df6134851230061fda0848800a42b0d73bd98f601a1c4655f038d1b8335e02d86311bcce81e89c6cefb6ab5d769f837b360a8940ca9d3c560bffbd3cd4e260e42070ed3080906a28d1bb1153b9f39982b00a56f5a964b11fd1913d0c0c7117880c7e55026c86c28e4b94c98f2d8a759062e060ebccfc06d94fcdbba747528c5f56ddd07cf2097327740f0a85f17ef0258eff23cda1a38dd24f83d86f1840b11f977626851130b2ec5680745cb58f2a62274e93ddebb5a86b7888317797a4a2b78f6a06172edcbb40f3659ecca7063d7a57444833ee3b60003389b2245e7fe6dcca23a9d842580f39e083abf9e91712c9f1180abe31f0b7a5f9dcf7ed04754632d92b3a364155b281b91782d251227861e15f608ef0cebf11ae9a156b6eb182b746eb7a4b82e1c9fe398378320222a2462d0e69c8bb429b488034c8f8f13ce58819ba163d7e53e5b9d2b8e56ae7dd13c3ced5be7ebf02e0e799caaa5667a04f7bc0c4aac6c61096f989e51de831460703bc1fcd5c8eabf5ca5d0d0ced01549d371e75eec0fbac150b6135c2550bef1f23ee590e35b519f75ead3e28e31ad42ed833a4bfb55e99e8c56f7164784f34364b0ab4418c121f3811848be023a8d43a538533f86aa5dd72d50a8972cbbaae2313655479d6170d5197e7ebb33ef9b0b0c910d70872efa42fd7c59138668c52265d3e95d79df7934f6e3395adaffe9088d80eeeffb7000dc47584e00918c48ecf547f6391e0c060a156267abac83ae5b6cfe5b6220b3642fe5e8c1c71bf9f943fee37088d2ba9f339c39eddcd7960a661b917f7e87732398359109a9e6c69e7094f076ee83c8f2951f11c96875b708c29f3620eae9661f92391dae6cafb94be2390c431610bf2e779bc7528a775331e021e42e106fd7242688918fa68a993fc7ba3e9238c4a9237d89dfa286b9b52c290e7b40eb21e3a30a16ed2088b5de576d14559305c4b210663a346e0446ceff8fbf321588d44e562901a769c528b678749be3fc162b3e1c9341d0f228a562d47026ad6029cdc0332fb69d04bfe2be15e47545c1d733abbf42711c252d139c6672e9ae24e8ef230b03ae3e322ee574b2fe70371197e2799862b0c317e6baeb47b541c2b71f49360dc7a87660e5a1fa4ba46e52fe771560631261eed336e4ccc29e5566aad7f564ac5dc40a37dca24c645570f9001f94bd32e8ead073554111216b7c2c367cf52c6f6941dd9480055a74e52d6824a6a8b0d555a6acdbfdf8e5148f85dd058b42e404b67a93b4cfccd1a63372e89ddba2116e57a04ec1180799609efa4b18c2aa4aa3d199c296c38cff2403ac8471a1a2f09774f44922f8cfedb6bb4a24da1e25e293400977cb4bc97fc95749a89304fefaba198471560fd0dd550a14e8b893187c23e96874471dda248e8304998ec7fe960d186cf9964e62be0bf9258eeb3116e54a19ff44438265193ba926a5ce7d879b5dc6913505236a65393f38fba3ba1266eff71d1beb8253c5a3cff5bcc1f3eb0803b7f8202602f61042a449c5771a04b342f5b2aab8a27db0cef8fe19f7797464da8198a2230efe0bcbe3b4472ebb3b6ea2e7be8475290286c7bef5164c41f8f3471f4ebd28b2ffc23e4c5f969afa8c045c88352947cc93568946a69b83b0b756c6f43ddb51ae72717205f1f8508ade81678db2d75433670ef278f05f58a11707c930e08eb72f071101dcbe3de40f8a6f7f46a8fd4f77a3b85414c167af7ed28efac0373dd173cb0cf35cf5ae0fb6d862e1c3a0a8ca04a996d0ae1f84f97e25d2db863f05815ad16a2627be0ecc9095c550257dd7983f553a02625c140ef49766aedd6241a8197f220a396dc8544d3e7ebd269d56a39d4654c4bc9ff6797bd81b6d3b2de613f19941f16441711f6f6440f3e5ef5eed0b29e49efe3c2fc71ce053089a236b082431bcbab49a2f41b52054981437784df058cfdc85b44af89ee5ef4431504a4329e9c2bdb95d43afbc72219ebdf0b852379e5c0af980a101f696047ea61a08b595e52445a45243569608547c2001540d2a38c3b81efc0f53c47b83061907287ca4cd3e0cc7c30b7f9a7f9524cd1a979fcdd0c890f5ab0e8d0367df2d577796250eed474460c7287a61a86dce8555cb64b592621c02f430ca98377e2a812c0c6f2678c4ca2cdf4f92804869fc24eeff6981106e9eed98a85def0dbb4b07bd14acf18d689b65b17826eb51f21826df261221330a75ee17c158d91cb8b2df3c646d49e513704cfa8d55dc5574726295d91c26d1bb326ef65abcd08f7dd52047ed41318a779acf3217ef25d4414b7decbff9743151f982cafb4c315a230a95daa4fc5fbdccd41c318d136219c3ae8fafcb5e28cc8dd8a0f9b4bd07df301e0f7bbf0c83e07e5c538c80a0f8a2a883ac3b220ec6f0899cf4bd0cdd849518cef62772a8ed67c20ae6ce359e9337a42d4055bb1440ac8af9869da4042a77f38f58089dbc1483cea3924f4dd49c4300b0a10c1a34fd0c4298d4c7681e1a1e13fcfbcf820b17690f17480bbd96f69792f0108440f961ed4573e2430e49c8389be2c88feadf0a997ee461f2b0482382c0a9ecacf023643c6f8af90a5a09df67a768741b54dd2effe8bc1cd1f678bdcf181e126d477bbaeae75f4408ebb1dbdcf64d1a0b711a3817cfc590c33d789bdaec9d4834ba9cf6a670cf32112bf37c5d990fc0fef435df79d27d4c599d50cd97e2d27d0fde1b76ebb0f3c58ab32ccc50c94b067d870c3d41cee3f3b0e996c06342a140a89bd293f281a6688f157f9c84f517ed3778c412bf6361241329bc85183b7abd956178a9c086ce67eb64f16636a66b5bf1c59d7882160f67946f8535b8eeca16cdb9db47eee7d4df672bd94c61df88162c9d8f615ee2a4781d0232ee986dbdee4a5845586ba5501951ede421d3b6a3f676d28d15afa4f5859921d9ff33ff7b4af7e605eea77a66a924280295da4f75f2a15485af1a816c4b9ba82f066d6748d1a5459f87efedd2a926ee84628d3a574a2e6f36a39379666fc53c514e1b32f88cd8dfd64cf1618774c3e5cc9f8880776143ad30fb5c297b2eeb7e0a7ce40a6b24215fff7d60fde927a524548465e327a08fd7c0b9c757d6244a0dbd038efea69795021a70c4434d230a078a7c735a83a958abd47f1f4909f32f5105c1b9782e6e22a9d9871b8b718600596f6cda54138b014d0f9d0beba12d3f84e14bb04ca02a867f8848815e58f41a89f0f5a1b60b43433f071c4154e0e791e0d45a41519f74ac25b9c3ceb076d970953ceeeb09a8b2d2e04421e8328f68695a442787cb6206075258102a875cdd4a2e79e65a2eaa57f3270f347e1cfa67085b523912ed44d78ab4d7ab85f00fbbcc2d378e1f7eccd5f30fb4f498c575207610cf0fdc6c7f325e556d9bed59507c532149fb933f8d7f838e3911cc0baa55584d3127c6e045866f78838bcf74f073413756319fd499e750d45ee781b92abbe631eaab1088bc671e6721d07b656c1bbad7165fc0caf9127fa16f79b533e9622b70065c0a0bdcd1a496e513380267a2f19ad3b11f48f983a2443ad31c740970b0b27e4a566e495f79dcafecbca6d07c8d01c739f312ba2ddbac7cc4ed6d99b7527fd8b359e124cc8ef01563fa54ee7d761500f7c96bc4a0450669c59d8461a6541e2fb418b9db1853605e5f241a8ac28ce4cf545e9532750f43435ae01ecce3e2a75f4cb4506e218768aa8c7eef3b1b9031c120ce04c058644116ef7c45970480d43992660f7e72ca4f0fee0889234c6e86902b2a5535a83045ee127d15def34d9d86be12a55fa109a2d50ec0ba564edc2c2bc6e0f053e1efce15243d194827edc62b1cfd372f7cd88a7cad287585b009315f10351d753b5fb3819b2989b9b14ac33c577d081708c060554fe8d24d93b14b10eed6cb57420adf17afa3a643f8aaac352ee3ab09356b372781ff4d7278184d93d6c5bbea0b1e83715ac8fbeed07d7cf6e57413ebdbe069613eeab2193989c62e0d66f55b1ea839b8dfe0cdff4f39c1cbfdcb8b23eff56416acd7cec883808ac9bac357fe49efa14490af4c4095a8f1176c46fb30d4695fcb82d5c53aa28d8a46fc8fa46392e5b3789b109fdf10394a78bc41205f2e80b0a135f8a765d476837b9953df5eabd93d5c387b87c8696c4cc78ce8e12803e7950acde7806a77c2004a23c50dda3446b694830594b89f2501778d856a032d05fb2ce7227ebaa87c9d7a4a8819d2a0e850738c5fc6a7ed7c70a432d45ddb9514911dc0ea25043bd8a1d0e846e17aa8ce681fff5b024ac6338dedf70689cf2b392a8c72ea71c4a459afea07c83f33167d9479778b9b415e1d0f4a459a4b0b0b217823956079aa3a2ce690d59aebe61a423fba595c2c67c5531506d35b9ad31b2f4a5bf6098bb460ff209f13972adfde536fe9c577aaa688858713797ed8f7b40f03ba34ac9f17d8bacc579e9be4eaab52625b5986ce75f62ffc155579d236273168b02046307e51a83aef7562fd674ac4e2f55185cc2a149e0b9d262ee8623ef87431d8e4df3df46749e1ab784b031b2a31c84434e39dd6a45762b75332bae3859fa1acef0a5aae4b7390d4d4ca1b007c801b288600c0db3ad046b6e4bc02e2a9ce0c04090aa3a9fd993eb2aa083d6a13900822f05b20e86c6041810fb7d9df6c18a501565748e43f9e55ad884e12cf1479ffd000c683e370631c441e8f2679d7ecc78a24a5a2f1113eb7ae9a16668636a672368f81905df3d40c49ff680a8601d5fba08a93d1b8cd27c8b8ae7bcccfba930ee86cf811067fed9fb7deebbc078481ce84f2135901e5dfa5378631e0f0bf90b88b92c116f1a9a5d1e84d2c341cde9e668af3da04ed2a2e3d7d0bf27ce02f40b6cc23b7def361d4d59bc58a0c9e75c3795d04ade7965d06cd0db972d07e7893761e47cdf9223702c2eee805d1688afcb4bbed2c5bde73ec43ae665cb36b06528959f3a897c3e9374d7dd2db96da70e5db0b1e03100d42cca2626939b289f968ab219104f2e33f8c75e2d05327a73ce56685db354465fcc7493197faadf3c9a8ecdbbb0450a7f48251cb660c3d32f518bb22fc0a7bcd5243b67767882380a2896cbc2d057dbc22a0e67fcd6a0c2b2a20a8473638099b1b302bd60218ebb905827339fa7417de7d9792394a05956ae5e7e1ff5755b2d06c18d3b121fed2def5557271b58c2a6ab3c96d413eac18fcb02bf0e447edf00aaa97a267e365ed57345a5f7a8eb5b50abba7c505bf22f32d87c2e2682e9c12a24fe7b9cabd4b1577e015fb9e52a4e2ca73e1e4c763d78da3d658b685d310946900a2e8f95f4a0dad0e0df9f7802ce1ac5552c9ecdbec86c7e109bff59dc3940372c7f35579942036a91bd71a2dbd048d0c0a9249a094bda154c07902ceb0db563a8cdad82c22779fc3149d1d7398b24e712946c993d3b80b934b41d425932437b6c95a4b99e68449b4d90e28f015731faaadc3feb2b456b9556d93a5d006849c5cb9a4d116b11d9af8fbff52384442ec26a75cc7c71df331aeae990a805528593aa9e5756552997a7ce8dc5cba6cb144db246e0e524c4f25aedbc3401aeff0fa5877fe1a3a3083313adc8edf660a74622b6d45584de25826d9970201b101fdabb24823fcecad06752cefd61da24f3486a59e4d3e23d0dabbdb571781d0385e80f766bca2ce893c0346f94773eb10aa462912d95fdf527b347f2e2cf81b9391b78174f31892f6d1a1821cb6616ac4090ba37ed303480e5141092ae22d2602df6f7dc9e4148611234829ec326d114380df01c3f2f0486150025e2d982261e8a9f01bd26402c7454641c03e9e557fd57248d02f258c17886fdd260845e4f12faa93be4868dd25f553fb1132c99e89055f0952a517d6466b652f22b7cf075a87d63ea8f5340360373afda7ff555053a71a5401c3b7678ffdb8c94ce46ba9fb541f07ce5400d4581d555fa8be5d3c7770e0bc9fce422c362e5d927c6387d85e619ac425fb4e8727988d1b236dfdbfe3b5551efbbbc16c0324af5a7db3ff538892be83a162cc767cfbd33965c8f97352efdc477bab9bb008c239bfca5dbb166a958fb697db202e47e6bfd23363c8900edff26f918c03ff1b4d9392ab42367a7372d0e457f4eeb8fb85b1","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
