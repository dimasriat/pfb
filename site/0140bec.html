<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"043101cfbbf250f0dc1ce13d634870a4dcf892362485cec51d1666defe7a191bd45542510c7ffb2e775905e1c7f89c8ecfc77ff15fc0abc5683b8a47d98199055ae6958caad89f36570f49a79ed0ca8a868888c6821b47a40f6a4cbaadbbd4c183208def5c6594474bba3b372e09b3d61b0761f9026ba4905c3da7835ada8cca82c07dbdecd0543d772b6fd56189a262e642078df3678d6efc7107fd4472c95cc53a8be513eec5a0bfde1ccd73faf3874834eb592fccbf00bc997a52fc0445841c15f4313ebacd0486b9d5737ed6ccb923f15377a4db785c349cf2de8733c0b11acd3212849ce7c0accd6e6e8561a5718fd8feab0da5d62229ceaa5573cbb7871799560f6ad1a5d91fd7d78c83b17ecbd1cc8e4c5c96a874cd55c398a947baed0642d3c18102d1d395e378b7d2749ff5ebfb15244f463868aca8e98222f546be559771accb3a85647bad8f86bf06d6285145802f00f9f00b1996ccd026c7d0eced69ba3116233b3a29d1612b3d657c8aa0b3403d737f2d89b2b6d8e16f089544b111a6d689b27c63da9e57cb0108c5d8506c03342f96c60b9846c6f22f3c1091c35803b2d98242780847e7e11f02d17ba870bfb636d4a21ce450cbf8364efc60432e3dcce1b5cfc62700c08189d10e536aac442a8e714a8e143b486b15f7fc45e82b5e7081b3f1df3fb25c1b3591be1a29ecd19a525489646fabf934f1c7c358140a91113b916711e72c0a33e18633b5f2d5b164d709e1957e00323e9cc79650d795283aa466d8c6ddf31c981530bfedca6b5f0617b7aa76c526695c17e759fa3b2a6cea735184d3490d52cbbfb9c65c37d2c14c51c58f57f10231fb9bcbae2d84057044060539dd613dcb52c3fbba04c76e8d9571c8d94bc2d7898e8edd454e09dff9972efca56f1af3d5bd539220ae0261c984f34d25d9b8cd7f87b7421f3c49cd407b05261afad071fbf9ff9fedc1ec307d3c74a52ead24f5ef06e5152e1c588914866841d3369679a18556020b86af246e59d12c6eb614167d3b8b32da1b470bab661c34ca5628982133b05de9876e85e7b26304ac09901d32f44fcb5db8b02fd27c9b3dbcbbaa66ccbb4cb07ebc695dc6cd00dcd63a66777aea6021a153e97bfcdd6239378cec3823ad83da1c8f7eef122935b12ca95f24b40ca265164f3f79363cfac49e171ea0b86b008387d9ef191756c4c3a9dd22946b28477d2fbe0231dfe51a749411e4c09c729e52482a31743d7687d66345123c714c1778c9e686818f2a52c19d5ebb49c622f7784dc8910541fa40d4b96eec54a7d9022e1f8b44a2ed5c775b7257cc003f9fd683dc164f18819edb229982a534ebe0481bad6b5857bbe56f3fbf14b226d0de02fc251d43925f980c397fcc93c7e5fc9612aef24561e974fccf5011769cf0b9ed45b15a91f669047f2af8851aac10a5782343d8ecad3e7c9a81ff5a4807984b145e39b520072e516df841a78e4daeac127dc5ffe449da6ae94ef62abfad9743a9a8af35cd83eaf3c5e61805ee4f8edd959ac4ddaabbc4966beccd890b54fcaa81740e1bcbb515e8d60353b84c5214448ab99bf9d6f810af984779a893f2ccaee8f4768fb67dd11a2ec516b4c624367bf94aa38f6994797b385fd7e8785a0e38d98e838d8e63f2907732340f1d9e3480cf7daa82c9a71e2303e87dcd6a7d92912b1704bd33b84ae9ea1be4df9ea16e85f70f8741d8c8fc60139a5b40f9f782cd449e2f798434df2b9862e4ee3e783e59d8cbb1964b1435488258c6ffedc9a7fedbc2639c257dfe4218eb2e8a0941c9b512737fab8ee37ecba60ab369adc15326f805c8ea8cb4d8c1481ed60c26bb8d12e6ecff2c99b13579d537238e8d847688fc8353b63953e3767b8846d73399eaaa50263050d303a9481cf7713de0bd5e8693fd920ee461fc334e1d7b6ea7e98321b7eaa5c76637852ce010e516718a368b1abcfdafc82782ff4b1389b96b5c389dcf4d1fa938be54f16744b09cd60ae3d0ff5fdb166c404ae68509cc301ac857d064f60bb940d1880b1e69aba23a2ad6c1844f128266a90a687fcaf1e360f02f17c67b00d46d096dc20c0d43f5ff8a619bc36938f7c59b1ffe607ec27e0b606b80836b0e4260ce4a5faedb72788dca8dd184c0236da4c9bd0904ba671c444b7425a6e18dceded3e8dba903a4ef7d31620a18274b33c635d966c91fb1590bf78ba4cc1cf7d2d00c3708fa0d56a0ca9fa3bc20c5971b90b73900be25b57bccf29ccf2b124998ac4cfb837e4090335aeff4a2a48bf7bb6b8565c1450ff67ec92bc5125a89c3cd69558dd401161e69fa95821d2a261517f016722316e0f9e8f7189ebb4a89cc9203b594f4abc1ec22643bbe910a329a4f99e0f6f0d02d8bbb46b97598b20b9548487ae44733465f00b9687c45b682e7206b94452bbed46b8c49c2aa6ea1987519e610539bd3b5219e8af49902c443137b7f81cd00a56413f26383538f9f1954f75b2441afb49d31698f9f7dd1dfb838ac03e607748df415ee592bb8a6b4075ed1785ed42d7d0fe7f4e8f0c73c6fdec46d2266501c415953c112e3d15fc97e60e296761eb782b8774ece94ff31e9bc2f93ce2ad0fe836958644a8cef4b241cf85f2a90563f64525e5f968ac4f8df38b186049f13322db4679e693a400f21cca1340e9a466ea881f7a7f83dea3d7f62a0313fbdbd238a2fc8a53bae08d6f3d7a79b6655fef6906b7b610dab8068876a45726331e779407bb27c14cc94226ecdd0223cee147e9abdfe8454fa6a9e2f7336ad15f97b642c4cb0d49a86519b7bb75859ecb0b77dfea478f23ec276613d4a057d8bbb776469cb692061cf67e7d6b4a229502d573692b2a2605ee7941b7b442ec5aa5f3726b7579f273c5e0a2264a53943320280cd555fde3a4133e27e838013ccd131c2ac6e7cc6c0eb71e2a58a665e434a14978d636ddf5e6161d3b9ea03c0e2eac953067b5f249803344bf02a7f60adbf1da8420d125fac1fc342d5cedd4896d51f0e63cc3969489462cad39a30bdfab128991126ac13ccb33fb6fe7407ccdbb2f55fb82c33c27ecf9eb1d9550cef10e992196fcb5d8a0cc4f88c7bcb01dea5ceb3e01115de860ebb2537c211186ae054dc4ae793e16373e74c4fb422f493a19ca2f8560c4fb260327976f325f7f6321c9cfd60e83d99770856953da85f8b6bdb15991973529e468a2e604200f092269d5b20aa2720140e9ad331872ea75c695dcfe918ab2884e5e9b042181fbe369fb3d2e7c04013e0d01e101303b326b27aae194e798ff438975975a3ec25c004c0f2f5be6c8519447f0a2fa5ccecbac1e97a73432c737dc47c8d834ba232db007d1fb26f256ee45a6788c9c010cbc0394ad37049c917295ed04508e1387158faae03689ddaa214fb021c536f460feca37cd09afa9f2f3a23c9781b7c75f799cca62f74b786051c2756bf49a6e51ccc656034d5c77d3afba0b01daa104d0cb03e794b3182edf49faa7611cb02caa59d4e87861fca14ece6e77ec0213ef04a4a0ddd9b32e4e0b7265b54cd22d67b77e51c6ee24489ad57def5f175fb5b7f1d3f6bc73c809242c258a3d19fb55dd38ac0ff2dfe1ce48120078a1dabaf903a22f692e531fab957944dd36cbf1f5e2f7473c880c47ab2dead486bd6827e8503f2ad24450e71f9629c1f8726baab214156555593cce468cce9677e434ed6e7bc646f2692efcc6ee16c9e6015389e18ceb14d24c9782e34de33d1e277d3efdffad09086813ecf71f6297e2e0981a24121ae81fe54c573cbdaef57cbbe0dfecfa80e68b1483b390e7451bb925cd2a2b68851ca4cb3d66edf3c26b0ac7bfabf22cddbb599c697e83eb38902af930d23eef162ac621efaa9ed61ec8f514f226d3e3ae56093e7ba4b7b705662aea7d99d1afd769f7a8e58055c44b4eff2369407baa2bd3dc83218dbcf74db9c67e95d0c38f820289942089f2fc3ea15e8ac2692d21ef98c71bdd90e273c51817d434009d178e08a6ec72cefdbc6aee63fa6f3526225aaafe53e86e6ee5d686bee973b59aa10e07bfd6cc97105ab1327b906ed7c7e73bf52c2782cffb1d160e5d87e8b26943004a1e0ba809c63e1e5795d571f20e262ff75efbb1f4cfc8816ba2b25ea21dabbde6fe2b34c2e1a61ae8484158609da619ff26606309f7eec18fe3be8235cf99be500ca351e5467ccf5e41e7a68d2cc3f370f58cf0d8dfaae20a5f8b122ddc9802c335b8c6aeaba54f69683fd029187e6e5b2691ef77fc65df8c2332f879cd1d2abbfeb2728def185bd049ddacba86a384fa2f0880dd97ad6e7bc5c66e4550ea2fcb550acc73e26f168aa1cd35dd38681a28133da96bfc1109e4e7c5a4a9d2df3cfdc7416b5766f53e945611432a355b76cfda66bb83f9b8c2e712b6c1cc24baf1c4dac1b983efa0f82976ccfd5da480e0819d71b6fbb6bd3947489a5498a58e26ee0f4bc9c24cdc7a063f6b64d8fbbda014b4f44f2c805babd6ceac04ef5b801997caa9c99b7db04d53af0bde211a453f00cd0faad862b58ba749f3796027b1abefe0ff0e5944fbc78041ccd906598db43b33337ed2d2708f64a1ecfcb570df573074a516e97208966a7e4b32abadd637f4cac30c7e1a6fae337b67c9dfd619d8df131d60fa823b8691dbeb13d07ab62c9e8d87db180f96b152fb9edfbf7a303cff251d70712d6371e495b042d6830d6ac17d0ce860a3ee9736b89f4d6619c3516516c2b43397df2a37c4bc8898b040a67080c521cda94c89dde3ef4413c315b37472eecd173bdb7710b3e1e6df6c10830c854d7c8fdd95637e077863c30dd380d1e4158b1af202d5567c05761ee1f6dffe74a29386f08f11f1bd4e58f415c14ab698db59d39b6779926ad70333d4c21416d0c6615d649897fb11928d05ebf12cd38a137c3c2f5dcf27e78a2bad2cce06e25158d4c4efb9b2ac7d01ba8cb5a8156e8fedd4f18871e855b162a35633f39d0902d76f25de3c927e3ed7932f5fce98405db161e83878f28386ffe1c7739eda0928cc9b31681ec9f882352cc5ddca174cd293e45afb03e907d52d81a0385ec6c0681a9dbda860b237ab7bd9f7ea507db1aed69e07f84ccc9b1ced764507ff9ec9944260ae2d1d80c3bc3740fed8816f2b211a39d48d3dd3a498c6cb0338741c16ed9ff1db80350e248d60bf4220581e7c8250c01ae852b6011294108103c9e60b16e7d44ed3df09f6d040566fb2c2c7b3d5dd2ce7116615431dc6f30631f939fa2decfe9c0c15c0ad78bf513b2766841399de656a7ac84a8bcb54f93482bf34831a6174fd25857cf23ac2b67a91ac0d97c97540e08962b44cacb747d1b0ce05d55ec0b6996b27b16e8fbdb4862505625b3f22540dc46567e49b124c229b8910de033269255aaba1ff96bdb3ec88b9685551191b9cb394c3cae3dff089c25eecc6437a7ce0b77f8966e35e78e4336ac08ea343306ca12bc3a378419806a89d2d722007140ac6b3ee52824ce5c9ac6726ed8e08c35d3cd77bc5ce595abfde426988cd0eb9294362b474519ad2251a4cc52f7bf4f64ab81531cd1e8fd69a25ba20a12d201f10ce72bc00a453bab5cf1e26baf43401a59302f8fef086541df8c0fb6b2de2d4399441de91c209694c6c8ac9e5bca9e5aa04a1df86163cb188201a323c83729bb23adb730bfa9759bfd5fb7a6c7b5c58d9dfa3b0f7eff77eb7cfda7bf1692d790683f09083886010723647b188e92ff17e6ce7bd4456fcbb07d2dd7b999ff3a387f0f30f93efd6006f9c59185e33aa23f4ddb91249d4c9d62633f440d09463dd08ce20bc48c10f48e6bab6b81587b6ac40cd0480a7ec5ed0fdd132466fc4908c27fd93270c01fe74182ef6cc2982d8af62758edb151f7dbd40a9bc2a0dd2470cce26f8dcf4b947e141b6eb3b4ad27a011c0d1917b712f36764447f696ff3033ffa8a2aff54e1f678020b0a0a1c08b9cd86587219d7da6817472bf9464e9097896016e1efe0d054837d948decaebee47b6196bb21d6ad0a98439a1573e326d63961e3a3f1f18158ae7cfa980c2f2b0f024fb48481b2523279dd63e30f766140cfd464dd2dd62f11c9d8feef3edf0047a94b49f7c1c418d7d4d893b3bdb69f02d1a327d7f2e6668a5cfd3925e6eaf3209fc49b982e12f944439e4e6e2b69f54fd0c7f92ddd6742296cd9aaa8755808b31f3b2ecd84b861826a8819aaceddc3dce6413f2c69d98fadeac847f65b767eafc97635d119405d3ceb177ebc95967af0e28c534ca2943366ba7042d8be88372a2b784642a820a50c8bcde9eaaa64ed3806360a472a6ea66913dd7599e79e391a2c6b835a3d0630348617a037af63965277b8d14524f7d9380a50e9c375dc9c167fde6fc8f19f0ef94d3cc9af4911bfaf394f25d0d55714367b9fe4d6f98bb73503eac07c00f38aeeaf04d119aeca89f6c6d363b1e910b2bd5abace7896837644e75eb4bd3f495cf37d88239ac1225fd9c7da756b9e28bac53d8193bebfd8c56938e48dcfdb09cc0623a4e28f0bc074061a2910da82b2fdf98fe7f66483cbef4f7779f0d2ee068252c9433b5c7f7c5812f25ce350e240d21b9f80cb175f20a3df1fd623b47b4ed26aebc0c991df4ffc019159b5fdfe4a697f7372494509daece344721a2309663115c6f3237d6d19171e270c203365dcad76406779e0f4ef25178135ad345a7871ab091004d24bcd54c436203cd6cf7506418a7c2199e93cca785d7b8d0df911046ce04dc80c3a5f0242b46b87c186b5564ffd8436a848c35d51154d13a08fb4db1506717dca8fd4c674e496bc0795f8254937df337c7341627555dd3ccd1487e352573f781349399b42e58426dad36a1f295dd85dc2efb25aec0f4dc820940815db6f02fb95d7e2022d47979ecdc9748ffbb7f658b2e21237c9e2395b88f963ecabfddb27900d1a6543209f66b76f62a3bb9af815a9b4cc431915f97efddc97c5f1af983b5622c15cc78a8c55b7dcd899302e31fb3b62cfd364cd702c16f8d8261adced1c5ff6f1a9c0d3624af4aa408d97050a914cd87dcf8a8453593a5d989994dca1ed7027097d7aafea394154d0791b4704ad622052ddc27fcd6bdf3cbd0f8debe2ef1ea715d6810a6692f6f79c4e991ba9f5df36797ae7e41b1afc4d1e779e0ebf04849823669993bbf604e6a23d5b0c6b73ebba3fd01eb293c1742d0b9b197b24d3c21628b4cd3e3fe811959716762f8aa9b5f5b55b1c79e715e156746a8576877dcb045dc88b285057926b6d63e799da616e2b469c0cc8db96be67372299843e306aabf146e12e53f65b0f2541e191384354284c44459ebc91b5948969aa46a5af4691b164516f294fc7387baa08f522cbd943e0674c68a16cc72071e2255021fbe36c7c576c2f8ede8ee3d9850373d64b1e4121bdb93ec284e590b9a9918dce757a2b07c60df594c88314741ae79ddef9314491aa11ff2b12c8bce8faeb1732950967c08cbb67d20d8c122425ec721712855015895752d0917294db50f384c95b90198aa63c2af678c4378da291d6fe6b3ac45bb89d6dd7ce810303693c0582fa3853c67b17607cecf871e880cc461aafb94e733667269a5e93fb191d3c22663b3b168b7f72fbc3ed42cc339bfe7d2ce23a412ad11ea45ed12625bad12784fa7145de6325f0d7015e71cbd6549516c887386153ae23ecfdc212e8efde632864feb1f23304669caf1bbd5c52a82727567b589a1fd8f27fe7c81462125b118eb2c5014a0205834838f629e4bb989d14f5ebc38baecf92867283c16584b78c3412e67d67393fa2121baab70f0b8c08aacd15106653c084a088ec3649aeca2b5981fc3994efc46b855d2c1ce53763f16e1917a7398be9aa5e6dad621ca6d06f0d3ceba26c8a6c6089921ff8f36430bc4774cc561b3f015ebce8b2695b90980379aca11bbf55661153b481452a58953e2da76edc1c4b1ed4c8355309357d3a01228b062e351919eb06e01e8569cadad3402706247b1cdd382e4dc2f52c94852381c30ed80b01f3ae195b6624fcd760fa532b0cf65ab3fd1047ecee9bdc968bbb9c560fccbd19c21a0dfbd6f5187a6156b59974c30d995be6dced208abe85ec98c728d92bb13f63cf5d1a3395f8003dba137e9743988915d7ec22a6ddb7db15fc920a3df94552dff48a400c2a767e07d4bccfdd721f1292a7396c02b47496a540c777d0622bfb886843eb69afb45ae93a879eb58f7ee626aaeb086a3d0b32074e0de21d9dedf9dd0f6b3a456b46abf1c3ef36c9166f38c63d600aec5197e08005202a67d166f38f17072596d258a296990ab0a8218da50f0b023cfe56a57580d5dd4b81db5b232391db9f44b3b7eb142ce04b1a0c972c47194350bf60683d2db6f63cbed1eb10e4284c311a28f6f2247535c3cabae6e915f00933a66e1c249cac469f6cb9c7cf193e4dee938cca0617e245abc771ad2bfc035d7986e7fca887ecf7bbe5f1b93f5115acb2ebe10e75e428459cde064a951b5248f3583566f209f6017cce4663c03af841ba711c8dd53530ae63e3b47aa9c6077ba1a239527dfffadefaa31e02ef3316a6d72754c1beb5947818fbb8a27cbe61ee7ae03e31c30326b4ea50bf8766e8602d6a66ac7cd59be828c623d5050b003e906c1285230187c5f721dcd3a78db42407af538565678772ea288135d1b813118dc0699fb7233d0f4fd5e6afb7ff723434c72f7288cebfdf4c9b7af280983905acb58834224401a924396115d408fc716a4a7a099eda69751dd1146d6a2b3f8808edbcf3a1c5217726e909ba7582616faf76fc64b19c35f4ac8d6762a0223d31d68f94d2302ff99ed8b92119fb994d854ad99cd88c7c7f23474d458e0508c614a04526cc0683c6f2735272759a663fedbbfdcedc277cfb0ced1fee72ca725d3ee8bc94bb4b6af559de69278eeb6dd8391260f049b0d4c3c8ae54a4aaaa27abc1ff1bb30b4680082f11beac777ab0eb248bf7cb4050701b7d6de1cd5167a294ba24ab72d73ebe9db09b4f99cf97cd3e9c86806a6a0e38ca1d06aebf88264c8d2c87e9e6b9411257c6ea5898124dca3b4b85353b422a410bec1669f195ebfe4133a359ceff0ffffc8da679182b5b30e5735dab03227990cb177466e681d6c558df2a6acc888d38dc949f4b511e8b69a06a03145d430d42f139d6200b35b20975b499694e174d10e42d383a917176ecf6b2dc9657e5ac3eb074956c006f42ac19f5d6be50b8499468148b59f3473c72e5c8c3c392959c5f8d83512e42500758b800eaed255be8e222e99862ec7c98dbdce9bd165a05b9ead1ff1836f618c90bd36a2a6554d840e5f254a1970b922662fd5deed97a68af99e8dc8359fe056b472a075e9e685dfb5653f2b7b146bb0447e26778e60139f8a80ea3d21986ce109a4d928a6e2b51295b006603a357c55c0287535da2b09844658e851cbc8a723e290539e5a6153dc996c8283b169baad4c979ba9a57048b9cbdc632e82060dad957ef1018d52b7bff467667a2168e823acda6389de8a0189128b5798108a2a08516180dc081faffcd7369eaafad2ccdc937b7725b0352ca905874cea977e5597f1a196d6b80277af2f7f2536142309f7a5da02a17c2facdcdd618d4b8d58300ec63ab7d97f9db84b2ea1d4dceeca7ded03f7f60e428e32a76f92a0ab36ec066ad53aa9c8c9fc627d3619539a65ebf18a287aff17fb94c0f8a8d80286b94b5348392a3614568f8c59452ea045bf1c1336d2f0987587fd5b88fe29cdf58a093aa310f71affa93178461618ee1a50f2239e9c60b78c785a895299916eb65e823b6e017380cb8fc7aaabd606c72517f9efbae368c2c9b2107fe7d62271fc1b00c277c9a82e141623802cf78663e8949454313c1dff7e5aed7589e37c1a46b34433d8925981e6c11214c94dae5ddd93bc5a3c2a643cc1870ef750f0939edfcf4a7b1b6d08e0ce12902db1fb2ca386f3a490beab694f704cc3e6b5c080727cfd4f5d051f1254ce1563e90b0934c4d3de3d4e6526bb1f0363e1fd88e7f9a47ce305c40028c6e9d7db302cadb0c66300c5342a13748415e1a31a55df76991bc518c1af1fd4aa1690d96c847d29c9278a5cfb8863e2aff6409a3eebd62c68347999abcc04c7a3ebe58a8061363d3c1c24c1f4a558cb3145f404e187e4aa867dbd7a3ab2385b44c33dd11cb18850e2ffb6832ab77ddccc6cccf84cf6b08ef184a1464ee39d5d72f8019c2cf96b2bae1263eef16f5abccdc7dbfa661a07d91fdadbc939998ce5996cca93447fa04d1a81aeaa4ba381b4fd0bf768d12951254efa1324864182783fcd6cca4fb5a381c58d44a5fb094941dba8747644fec0cbc74a8fb35576882255adf836c26249e08225ccccb408cdeb0e2008e0d137a83878a0937db31cea7bc5f0b46d9160b77fd5c785e7ee4201bdd47acb53d9e10c02961723d7592356affe38ad70d80d13872e80f21b09066b4905db2405cf97c80ffa5582aca0ff462f7b51e3796ed47896f5445e9f0175c8a34e1269987974d4cb5c4d505e0e8d485fd79c5b5eba15ff868b87875ed98b324c3b0680df1d65b3b60701ad6677be502bfaa5a3c202dcca0e7ac3ea6d7b524ffb9b9a524a22ab8d7aa0cc22835a9a80d9b75519697cc6cb635238002f1e41a371a093f15c7143add8c9db2c8bf33e4b346d9e591dce096f8a3dabed6d3e9e78c59d4ef4283c7c311bc281c24c43a4d69dd7d6af0f142cc0b26f4495b7f2472c49416d7375e51d1c75764cc38875c6ebec2b2446ef6b71f6e5077ac6ac070e0d3b07bbc55f03d8e6ffbde41b11f9f82ceb77ddcb5c658326addbb47ebf61a9354038e55ec97f6df489b3439df454ed286a61d50721d6f5994eb9f3516c0b208d5a7fb44c02daaee44e04f5511d824f219402512bd0147347d385aaec81d8fd5eb03abb0ef4bb2b6df58839fe8a1658b79bcdedbb087a23e7327ba319cc13340f0a82b77dcd8a1edd43770e7bfd26b9fc50d03126d9d0ed43d6c0425162a4cc8d7dde63084ae3c7c12661a99bbe318a09e9dbe234f7dc68384836d28ba2392191fc9f13e44c7ddacea9ac970e5ef23da7d8716e8d209768f8dae7b359f8b176b970470e949e88abde6b17cc980523f7b8de29fbd20508aa0e74f25dec24f7e51c0c8ab2275f4661adf92b8321bb316d43201840f2d290dc530673f71115efa61acf64687c2361b5a6889affe63633a1b6838a5a8d9be6ef22f25175c194bab65ce2189ae5fb5aed94700cb1222697bdafd11b6492faa2aea8e6a3eb47e526dd839ebbd79385c3c3c20ec98bff5b93e4bdd4209e35514374b5227d1589ad3b20ded86ae63867657d0a1b5f88ed7896efeffa0ba51bd4ca5969d2127ee2922dc3148512a3f2ee1c611671d6cb24628e2c401daef3f1c4e7c49764b6895791c47f39da5152ffb69fbce249bd7af6176faa7e4680e93e2c81b6ac70f4428aeaa371621969999de45624bd7a9a59eccd28eae18b5b0f04e05372d0d1b456334863a736e8d1a12cec69888aa2ed1a1497b7bab1ace1fa74ca8e41ea2e141db6389919a9666837ed9c1d57e23834cd4105326b11dccf946a4e57fc6c05de53a1755a6548ef2915a43009f1b12b0e4f9ff8cd6b3c8d0b3da2aa87703a77255310989dd01c291dd8eebef8a7240308f6af7d772d36766276424ee20c3b2f9d3fb2bf498f0cc4de1397ad8db00aa6656986fccadd58487082dfc2723c7f339f4445f79343b0f5df15fff1dc72c9441be16d9f709e4e909257e9cd857cb7032d43fb69c51f1a052002861b1db4a65d24797f162219fb5893efe4e9da67ad26f1ab71dccb3d154faf5f74f13ec503f6fec3d83ab4413a1b5b77351bdc7772a2cc8cef167bc2b14771809c38db1b07c9822fe9c9cef34dd6b984efd9e76a4449c3cab26f68dde464141ee2f413483289a2b555a81b0b4891f9ed767622420b883e68714db2679734e434860c3578006cb78e1fe8744f7dc8f047b41fb24c03161972d2fcb0a63e1cb0569d9340ba814f30a7e1a21f46ca0ac0671534ffb161831971426c16b9ca70c1f8476e64e3515e155ac6df51329dda9f1bb4fa67bbac1e0407c9071ade2963238e7b36df60042fb39f353fbf779cc78eff187dbea1234fbd8862a997d70a10cf4b2c8115324a18336075af4137faf5d6db21ef7f3fc558c9c41ef9e3e897b3a220313fa058cb80d2dd8f3eef0491c5398eeb86c9568f5980d2b93db7064e0d75f792c6b9408286217a3e7191c5c0d59fc7bf94c5c844153a6e3a648b14679621e43ccdae682aa9dc582384119285c2e4fee230ee7a8b432779b400e696479ddf64498b8fc02308e10a02d1eeb38f81ded15ad6b63b8e1731c0e6d9f37082fd90bd9e027bd33920ccb48b101f0a57ea21ceadc1e53ddf8a31d3b15a62657a8897c72a","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
