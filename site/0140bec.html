<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bdbffae4f8d4676ad86824525498e9d676e71eea334e211d3ddf57a46f52e20c23412fc50d78d4ea682f48eb7c7cb7be8219585db319afda7dc6bc07d1748bf1cc9c101f7911dfbfa5cfebea625155c11bed8180c88be696178eb42fa37f769629686d2afae683abaad40826a37a5e5e524089213de58b37ed5ed4a54ac1f8ea8115981dbb34032c9afadac49961484a75a6135083ec97762b56c772c3682b21b7cc3d5dab92b0d9094c991f2abf2f6f853381367c6580db7c6464e0c2d86ba3819d7860724d76e46b9d7231627732e90e0ba4b4714a7ba45bf8a4104eaacf1ff8f1784df6aa9e8647cf84bb17e8c9539266153d6d489b96031f90525e38cb5d02714cb252a484c84ecf0aecec1e762649cbae6e89afc355dcecaa4cc0c259ebc6e910fb0f5bb66f546b6905cd9adfb68c075421f76e308b4b8c95eccae99a443dbe7964f06066050eee4719b43b3648614d54593200c4c9b56a65e59738a4e9189e9b3efc385629fa6e63172ec03a817a60146d8b2be333cfba82f589b6be19f1db63ae9d221b79b701bc17470f456cd058e430f72bd2177603f83df4714b3b2886cecb39ef68de507f8e89c59aa20960ea903fc3a2e0a077d41187b30e8a5a4b8dc5b30af0cbfebf779ba67853933c416ff52c9aef8d825c8d79e580b5360e87c651eb17944fc9efc94259baa52eda2e7739adcc1ecaa17e7bb1fe6e7a65b21f01056172d1c56f96c4f5bd4cb0412a3553af5bf2edf75ede4bde1511d49621b58e692da2bb9eed1e4c8806991a7a8291e0838c578e7fc1d46d85742fe1e5a720233ddfc93ad7cfd53bd790188bb5ff43b70725f900e3a6a3ecfcf40ce649b1d8f917521caa15fdb6021f5a427a2bac08f2392f729f9adf06cba80ada034159a7b4b36cd79d579af473cf248c922b3fc1152008277eba49a3c3f5b558d6a0c9568ff06a0ed3a8e706f7291d6146d492ff9ac7f6348687799b413ca75ea83f32dfd807236b967168e4763c8dc33776f9880156eb2a5a371d083eac635a735e845afc17ab6dcf0a7afb8e040c20d6e4a062b70598d8bb30432bcf651f22560dd4c603a761feb08bcdb1c4fe578ad97d150830c1c736fe1e5d555fa32f5ee6b5d628f2d1e8fc449772458546d6d6e9496eeebfbca1f5616b94dbc2f696a16fa73c780055546de59d454e064f1adc77b3f63e5cb10b01883138bbcf425d15f9a6102a0678a8fd759aa85fc0b082b01b4f216dcbc1f0c1ec3134dee56a3c9fbce770c1cd2391185b935a9d51a10b6483063199a76ac89fe8371eee7d5cc315b06324074311276c1f90fcc7b7ff02948ae6f6851c488b7bff2a097cb80f16c60e1491eccd7b41685b84c1916a3755fccbdc313e9233f463c2aa11a01eafa7d1beb473a2753d8f423ce1bc23e7b987bc1efaf5659419e177cf168cae37e423ade92fe67ff8f1e32eb7946db07230de7a09320cc7dceca45434daab37360b563e9dfabbb3e2e2e0f2452963515cc704d8d158cd2300f18d0314b31598518498cc0b55d669c614faa58d53e85ea96dffe8d6fff2f37b6d3125b1c6ad28462c7930fc9ca1b97f8ed409141ad48c08b334ac9e846c4813dcbd04244de922ebc38f923af75e366cb3360cead79e63ffa9ca765f482f07058dbd8e2edbd87f4ac57d8b797864a9c2f3b1f87dc41fa65b8dbb0c732c3dc8665cbd0c70aa025165b8e2810e45387e9db36e6dcb838d84f8299909256f4fc7db303b9618508d0f26c99e0aff174e216bd14574438fe224b055ce3153c548f6af18d4a80daa4d38d25ecb0f59f43f5632356f92d4cba4520b69b726886fcf6ad0fd953524dbb57d92cbc8e2c1097c8badc8d3aa0d596ac207f2da5e1331bfe34e5c444f3ca388186c9100a9aa679c7c68c6d8f5ed331e609804f6acfd2776fbd70614c6581081694906ea3e48cfb733e2b0cde120668f67b27cac7136807aa83b709ed775826f7aad852ad57bbfe083ef25ee31c0737ec0034cc47ced6dd43d5aef8fd5776e052e444813881840f09a778e863c6ea8665a61b7de537bc7229a938d8d4994ce41cc159682f6f6eab3e54e863e5f9d5b90b3957f650d0cfee7f8af780f3aaa4f8f36f62076941af0d429d8369efdc74809d0d6bf00377f97594b86f32ec52ada6039cb7b05f24f9654a52517468a05989d66735954c3712f5664332c7a8f3b66752a8d0d8f71fca8d8a62572bf676d6e6b24f4bb5b888f4efbfe3f436d5d28c9e87a03590ecd33930a359d3c74e47131de3be2b44650166de7f6b8485efe07c835f0a29727a451f086a0c8efbba838d146131fd02633f35cb697d77007a8011ca418fe874ba05549d0439389877dfd75ac64580d11d40d657f584cb0ea616445bcd91d742e4ae282429d3be245d2d3b6c4e0f497206ed8eb7e8a572ef0deb66516d232ea99a1e6f2e58d136f972eef339f12095b5b2d7681617c2de53981a4186b8f7487e1db1e05498fb01440551085c75a2d618e00a4118ed1bfee492988f92471c6f66d00c00ba20771437f87e3b482563acbd330f0a48c165186c7063c5435aa07764ffd95a8a65d7c9ba4a75ed7f551f2d169320dfeac2e7e0a0386f230a1e696c4f56214e5988a5eb0db12bd3fa7194d89992fccd7e3bc8b7e6c9da2da36640ef225ae5be12d16eb8f8ec4c19adc08b1db870062d9be0250a8969ec53ba06aaabdfee36ef791cd18e605bb8e035c698e50a8ae8ce90eda7231aaaa497b7f00359e930522c35282601f7157e0a9945276c59a975cf698ab1d4c458a2f34001fe83e34df21f55df2e054f3735b48d29c9c49489d18b676050a7dff00e50010ff5e79132dd99625aef477a88420e54f8f14cf5edcf7a1376581fe8ff610d1c0a7913c23a093dc56408c4160bfd00435cd745cc3104d87e89e10b954fe197fbf56ad04f13747fa884ce19c8eb3d30fb267164a7573ef73de9aa00bd6514a2988ce2a986e0d078e8e3d798350801be8d079721344691459f8a8058e687da0eb71886ed73986d9d7099478710274c9d7be08008cf6bd8f5bcb52e31c57c5c7bd0bdcdd13d6498d05ff5ff49692bf83fc4ff13c675ba051d87c6ee0f7ac75d71dd41641e34e6d2b655d68e57ca1de8000d33878804f6e1d838bd036d616cab1317ac02b5572de6ce3afc72b48c2b07f3c0f371171e453a0e4468f36b23317bcd6afa0e5f909d7bdd420d1c890fac3239c94ff080cb1d761394cb79d60a2bd8a61e7bf74adbdbce46fd4cfa772573a0b5e5c0b961401f07575e4592f063fdd707ea4535c1e26494294bc80da48e18f02e58cf17ad1c2cfccd82ffff6a89f82cbba650ad5291e93510a5c49845b30157043020d12d4362c4ca59df71afd0d4b380cfd41f13f150d0277be18d779d581772d51f7e991d7bc276922b45f713341d91871351147c55414025a75bce107f4abdbf154c80e323f7197e07a00adf9a19003ab1fed0de3711c2a13689d74d82bc2ef8ed4425e8d7b4ba1136927faf058092d36c180e43086a5e453a10546826ee0e511ba006b2beedc75f524b6fa41028823120f92097ab25f235ddcb3f63f1ca1a7d6e02e84a18c88d0d2b7f976aae541279062d0da3536cf8b4dc3e8892eca61bb9d233ee694535a89f57547242ae9674ded937bd32db9afc740aea2fe46e39e5e5b0ef2674599cad28b3172f30af9ada251db2a1967611f46c2e92c485f1dfecab652d820bacff58e65a0fdeaf3c30db4f7dd1ff97e80fc5df9be4cb37f0300332ca3cb09e64e5b686e0080f39f7166b236cc798878b67d375624f0969f94eb929bf70f0f2d9944fea9b9ca348a5ea654e18a44349f846a60faa0513b3a23acc37b8c8aa1ce696bc0f1ff8f8aea30a19900e36bbf5ea1243d7c9d16930e7d3444202280456bd930ec22429c614b52933fa047788cb8d394ea7b5ea3e28db4dbb26f424888fc0deecfa8af0e2fa0e69aaeb29425d88d55befca7777ca8ad58c5dd2b44ec2671b4a342cf0c66ad8103de98f3027c5aa61a56e526a6427f98fa050afa65e99f5ef142f46f1904cba827d5898ce5c0012aec0ce5a89f13497c59b8289eb6e15b6e86bf84b5c2164b4fe6777f09f1b24e47b960e45871fc7f10f5f5a563a6e8bd68f56bb72c4d25ff123591bd54f06fea943f6d8f81abcc93bf7f0847a40aefe14fc4dd9ae0d66ff27a5e354d6ba39d75a590ef8e5487a076ad4b101e63178423f5ca6dfd0a0720ccfd3ba6f466fefd5a3a32305d315e4c0e53794d03d2694b5193425b133ff5d909bf78b8525d22afb387338f645ccca72925d5085769ff574501e8c20b865d62145aa5e4ab65f9310fd716990259c8af8ba780954c93453d425326bfa4b8e9b5f256da1b6ada3ac720dab7838fddb87bead04704ec471a70f23831b8b6e2335a16029cdd498338c53487da6084b8f6797dc7369c8df444bfa357c3c19784cda108d6d59207da885b17ee69cc53c50f6f134fdc89fe1bfd6efb1ecc5b5fb3389d06c3c8dad1cdd081e193702330d476b4ad78b626a72bad23361c9e0a3024ec63538a7e4e280c361cf9e8300e94f4fd684a22538fdbbd75a7d32c37a96b8d311ecb6300cf66e2bf221aa752ee780ec91f5089c5f21ca034c480cc870b5832da43c390d60f904a9830c7806c99c981769a3f9f99a9bce1f383cd5085634a5b68098cfaf50176f66a8b192c6579faad1de483d6fa2ae8ecb64f191b6d05aee31d89d5bf3db1fea034e151bf4777c1d96944cbee3b5acc41d95e7103e40fa4c42078b32bc00e410abff1265e19d5fef5c92c3940cd35767955f53f13c6d863052dbfcfbbf57446a4f00f5e06860f34af214c8d8fd8ffc3cff3828f7e6e32207d61ffd7256ada76754023cd27d985abe3bf84cf1911664d6f419bad964645338140f8b07d9537266a9d801b154aa9e4437d6741dad06e7a2a931a073c5311af78500589f4965fb132b94c30f6b052b67d3e775612434080dc3e848ff770ac78bcd686e771b4ac4584adf8c67c4c03f961668c277b5f14864c9caddca0b84755b5dc5a61f15d9d1a02ae811ceaa79fac0a893d236cee39d15ae99568a2719fe1febc72419ff4baf660b2fd5461ff54f4e4833bdc066a1ae20b405c65e9fb80c707d4eaf7cbf6a3f08254d65c02a745f41ac05b9a6cecf4861b6ef005188396fceb3526f6981c4c698bea45e3a0a1eafc5d15708cc9ff6f09eed7c7a7f706af0520c09d6dada1a913986f47d5d9d5ba9a81c6eec5f5cb685105c459249bf2f2615f7f78cbd0d1e5ae5b3437cab50818c4bc1cb9172127ac33f7f27c0f4890214d5a087a9c31df6b76a596ef63450d8c3178b419d317a61bc7565fdb1445f78a0fab958e14de15faeb29fb8bf0ec0b5ed7ad2e31fb571472c3eecdfb397040e393f58ff1a1fbea17fce0f122d914dc501b1d27f2e1c58d64a2c41d2b6201b3b165f7933da57c14ae072f009d9db001d06bd69f2c07eeb02fde8b7572389629c95d7e8c6a7119cedc6ce8edbab46ee563aa198216b578cd9f0d088a13518982fca3570c791223a614675cb601d1a954e40d8ba5fc77ea2e8b30774fa0deaec8818c78fd2febef08c64e263b75de0d2b8ed04d35f0d4996a3d8f894e8329b60aaa461a380729b78353c8cd847e1ed311565171c67fe80d77c7509c953c9eeaa60e9d52101b4971cfbe28093dc586b2e6a4b63a52fb5056907784aeca3f2a8b00e7d87a84d16574b168a2be3e9077afb17ae93e8de51035f0b6a39532ca6d646b26e42b3a7528b8fa2196e800cfa8785d6b54e866fabf456024214a773a34076554c94cdb9b1718c1af7bcb6ebbef764c1ae2f13e751cab7959146b26c943010fafbd63ad78377a64b039fce2cac20a35429d3596611ae272e7599cd3c60841ac6c9e9e9e4078f6802819a1f2668a264dcfbeeafc55f594a03d8c9218deb000006a5812cf7182bbadb3ad70aa7dc7706a1d8811bc2b8c63448775b6c1933e9160a8795f25715f61c6df104e835873ffabce3abdc3c64681c027ea7b39a97e5855336d812b49aa77982bdeca8e47f69e1e4275eb5432d48f4b2d158efb45cd019214dd20ee754ce354ac082db8f65288998edb33a1ce55d4950d29ca13b94460930ee2aa6843de2f0de25ab305180352f9376df87cc360257ac9b8dabf2bb93bc07471512e31e88e3d4169d96114228ea0ffaf773ea684f46812441c492216d9b87504d8e7e1b045357775610582dda367b510c1d3e52b62de4d69967674fd876288e9be7ee775a8b1d198e23a81c7c8878391772aeb0db1ac75b808fcc831f51b4e6edbc42b7df75a3d77cf3d8d7141d2715da30572803df37f2cdbdebc27053c554d81a2b6500f0fceb3d587d3ec207e96bb5a4c01f6ad7f1f44b7bd88df84eec94d5e3d5bfe0ffd69dda67f68f4d2a853bfce00a0a987c8982c1e221fd239cbf3b81840cf36ba71dc473db3e04579fdd05e11c94cefbd5e022b049c3617c737a04124257ca782ad4a3ff768a88680ead0859f8ae24d3358566f8a96716047399fcdd8a759b74c16e1dbb01bdbca980877b87c4049280abcee72bbec7cfc5b5a605acb635f61a8a19f5871faafb03fccf19386708e113170182c8308c41545ee23602943d024b65f30e62da6d35adec4da432b0e04266d3303c61379d96936e9fd1c5344294c0cbf054084d59d982133ab59bec42f2e8033820721cc806095e3515acfdb91acc148edbec5711ef3d5b22854b7e56f2704f28a0e878456d288367ecbfbffdbf0fd689042948b47418b6e97d5ab1f5bef6bf9bda72d8036428085f2fccb0c1e653cb9e21283c1e55303f39e61eec686b6e104523e6e8db87bc698ae166d3f35c52ca02d5bad4da6425011593e2013d2353026a2abbd59c0eb28100868792906988386c20666c4728cdf9f65d353b6551d5d1472829d81ade4fa810a48fba64c7ec948b6710b59f15561939d852182c882a66d6a027e2a06198eaec7df9cab9d1029f5343d615cef2701bd030804606154ad9b5ec32559633870fccad5b1bf961a5bba307bba693619986b1a1a2b3c088e2eb71cb30cfba9fe948dc017e11d4b59cdcdb001cd58533d5ff4e41236eabac2f45ae215dd29f40ca7706e1eb901260f38fcc4e16a2d01e0759622576570bc931013937dabed3edb9e36238e3915f918834525eaab740405e600f0ac0695f2237ac71054b66c8a5682f9bf4b1a50fd68e93aed4057b1bdee8a3d59ec13ed0caa1063eab7ea351eb328ca0f34e296f502456418f38e225058dcda40cfe8c696064c1a9f4ad72cd155718391cbcb13bcb29845c7375faa3aa4cfcc5a009b55ca3285f35a1df078dec21ac91fdbd223976669bc5762e6c90f7b8d851421a6adbc664c874124def110332b498c9539551dc4a53b7dbe522ab6349a2d383a8ec932dc9a77e43fbfef06b9385214bd5ce93f40aa164c0da8faaed9e29cd254db95fa7754666f620a02f4336bd17d41fe02bce6717f190dd399bfbfeb45efc761a6f7cdf67144b1ee2ad8108a9fa9463c96d36764df9718ba64d98ede62c590de353606c1b8e21fe00cb60b9a26ce4ee26a3f46094fe3e58f3374abab11fe9c2bc2f7fb2b46a9a9ab88c4ed308f53dffa63d2b0df92274e2fd3f128597b2c90855f2d76fa9068624314bcb87a01e5f36552d676c84ddc4de2f2707981eb35f221834cb1165e71875cbfbcbc37ffc4b885539679d3381fefec14e9600c3efad25a42ad699e032d862e133b6000809dd452d3d45d836d981dc8d75ee2f66668e1ab4082886ac91ad23ae1ce67ee8c548e3f7aab518c7d315cb1504a59e9cdd27a67424f75a3ad8c4e97807ca5e0524ca37fb70dd0be898270f9549e7027f5c330c8ef05799176de13a6237221411cbddee6b56a512512ad40ef6433c6ea33e2bdd223241ea9b3b64866affdf9ad49ac7fa7c141168e0ccfc6b9b6debdce31dace617f49dfcb425aa2661457d9e5a1f31ccc4146e01c52e6624dfb604a38fa1a11184cb82a407121a5bc7cea121c2978b222800f1c5075b1d957510f16780ea0120964f16785f329dc6f6e0f863553225ff861021485fdf1bbd80acac1cbb5b56ef2e960e6091594a4866872db704a238c9c211aaddadb16284fdc41a5f719500a74cbf1cca75a506a977f62f138a49871ec07345e7d5d5c8e731e34a4e0bf70d0c4e33c263affb2592eded0f0a6688089de90169413ba73feb8f97dacafaefecb3e93b38277c69ab36e76004d5b4fcad8c0844be99eb11eb1aad52527314ae5f21a8960958ca8ee8cf26435fb41d11a229380912975ec2bd89a9ac3c2fbbc487875c8a3b8b33ab195eba2705a327bfdbe2b9e698fdd6d3c7119de0d6aba5327d3bacada273b41742446b69e80eaaa2e33a49d6072b83cf9b5902ec9cc9926132b38963a5f4389efef840a1226fb35896d5ac935f5bdcd2d080f67169e550504b86d603f0d56e91ae23052385aa62bff9dbc53090556b940b8fc4381062f0fd82a70efe40f015caf3ce4b7b621f3930c54b1d20b1cbceb6d410f55169d27837c893743d69f656d8cc67a6873953dcd6aedd0809c67860ca2ff5a041c3f7b4a508977710208a05657b75d534da11a23ee8cbfb3eecd071fe31a78a24bf0a08eb6dfa1d14f5abd2c1ac231cab425ddae4a468ddd56651dfc3d500c3e2054df45f9924ef96926684de040e73b733c0786d07963eeab89366c3de11f5f30ee2bb77c1a49eaba7d617678775356179234b6323d9634ba4082a4dc42c76948bdfbaa89d52808ce87f1051d9345d96ce056823c47c28cc93fea8f4535fe9e9f487857cc9afac5abdd28e816de1b07f3a8c027b9dd68cfc704f0a64d4aa25fb4a6535dd969a5353165f3346c11807c9e3c045eb91df80c3d319bad14bb2bad67f6e77dce4ef688ca82958933d3e70e934a184e7d8f0d15faae72fd7fd931b329f84ff68397a18c88b8f965c8078c7afcc2d73c037e0ebb2a4378eb1ed940f64bb1a575ca79c31aeb7ba59f3b8daf1dba404f1dfec4a49b45733e5862c79bd233331bd6c4c1b1c23fd9a32ad09b6e3d2d83d11640ab70e4cbce0e531b6ba608b349f8cd18a93437bff89296d7283bf4a37350a7e5567611b964ebaaee2bd715968cc01262e0f456319c4aa26a730eacca522378bfb7db70feb77d16ff9fbc1bf596dcd14dd8da35da4d47437ebd2a99cb7fc8ead47018b2bcc22069b59d677b6c1ca4ab4ae9563f35899c21852f6552436ccdc5025d7d8968a64be462343637351c7904821754b2677afe5e1a9bccfdbabd42e10d06153c8825c4ed310072f4bdb2cbf574feb91ba0c9a7d13720f9ad27d441ee37abbddb2b628be445f265243b9ea68fa75a643c24d0a7d8a4358c2d65744145eeaac80cc34987fa00a6c47aa5145703bf665e2e35fd99f258ddae48c9e4d536237967dee9e8fb3ea7bb0fc0e6c5ffc6b08593280681653f56da4c3330f7e6f4cd6e3f0fae026eeb1ad654f394281e73143c7163df7530e81989471c6276ca2bb7ea296465301fbed4047f8c7d3b237cad87c335d71695a03be0df5cf8d4b04521dac81961cd9c4857954f1812792c61988a2471e393972aded10af5084538d89905f356ef17ef83f172afbf472cd1f16113a2d9f151c622edccac8bfc0ca898756f87dd65a63e4d9535a11df031f9643f59d889933b440bf07e86f7059343e866709f70f518589853340baf76d78b6a14d56eb534508f654182bd3157affc990ad0b2bfe112c65fb649cd5ea131380d32371b1cbba48ffc5ac3fc5caed76954c43fea9a63a1c29962ebc29f8b000f455b5c4e9c405a5bd3ff9f46f12c9880231ebff6b1241cdc38c8f5d64ab1af247d3d25fc2399ece09cef8838b8e41876fa7a5c8fe69fb51e9e725281f073cb63fc9262b77a33fe9a882cb95a004c16ae116efde39921f1a444f450b1802712cf013a882eb2e6b34608528a359658d7f5f9257c3dbeadc2557148f4ec6d0a275e6df09eb0208e53d4de8af3c28c1adca32173111c7151dfe1b750c1a6adc4cbc4984bc13e62084c1e9359c5f5b401c9cd76e124ea3c451b41d504c9e9733fda014b94377f3878ba6d4a0fc0f151a9a73508c2e944b35c407ab746846634ea0070ca22fe55c3bd37eae3b17aca9abe8d6bc022af9548496ae88e62d356dbc9042b0398650237e4a60b1cdcf120bd81e1c6012b8e8f3cd53a7adb7aa4230fc461cb5a2b39ca1e85d9230068dd20b35502daaa3e8c6a6572510e23a050d3a29537199ae665270c93c731a8725c78d20daeb71b581b71a014cccf3ec9c0929c1dcb38cb665fd04701e763e2489b6a0b7036ca0a171b4111c76792d82144f7bb00e60adb4453a613e82553fec250b2d43503f4a64983abd454999bc8c6c32f6ffa88ac3f2da3bfc75ca30ede2d56d3be3c57f94b132c52d3534fa09888f582bd58761db627b964ee8631f6cf5134a282ee83ff9929ad5ca89c791bfaf55950de8fdc9d3ebad4e18a7e8aa3d44d208a1357e64e85e5aa788639930dacd7323872001aa8a6fed6fc062e7405eaaff220cf69bac180133bf03193e5ad230bce8dc13727fc61c481aca4d6a5134d5637ab6646c3dfd234b103de961ed2ac2f916a4123127db39e10d0a6d959c916de59910b0e6f224b952e26a4aeee62b60a63d3b92d85f027faf488d53c404d4665791a3791057960bd97a242587284b04e6e4d36ae48dc422f946bd7503cfe266078a069ba50f227d337a79515cbdb000369365ab512a787487ca435684cbe2994fd8bc607c0f2791a60b2c4728ce71891286a1f1bce392ba50ff033d3aee664f7fcfee39dc88fc42419c7fbf651bba69b1156709268008142e1d3d593fb32376e93686eca3a29387b5a5d18ced0b85c8b747625f53e9aad5a8d0fb6eb10f69bba5f9f2286e578a3bd02bd5cacdbd9b0a1b6048cc53f98132fe780bcaaa25047c62a870c588f39a16a356f87c43def01e371b8afdad3ee30799390ec83fc7446045697b615a09df25cd48872e1c778cb924f0e4b32a8156e9006948df5c442fb797ddc390482b09ab723765a1e16f96a07c33479b3280b742168ea92b5f52068d3149444d234570703ff36ea1d391698d056a3e12a4f4b15a453231e0602da412624b5b597ce2eafc845711469d334cd33c01e9f3e555ab29617ca2dd4225f3fe005b78a865e584ea14c84844b25ae2f0a14390d4867cd26c9f5d260c3b9a7f9fb951ddcd3dda848706c4d3eddcc0ecb38c402842287c482a370dc936769506262e772310ed21ab06bf8e822e2c5d287a565e0f076c3b94156c78289cf472eee4946133ce5bb31827e65f91f8aaa07c83624129c592530b6f1489a620a3bf5b1d5ba16e5cc8ad0b8424d49ee141ff5dd85e9acf1173f1662f3308526581352f1239b6fdfd08fcbdb81ee39089588a929096d387eef71ff3d20f75ed949a3b8e9bc55de0a87c41c52d4d9bd","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
