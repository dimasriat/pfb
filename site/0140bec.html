<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8ffcc4aef7d414cb9b18dee1b541e19186076b9adb33cb0e24465784b27abb952bf7f8d7abeaf6076b6eece8c87d506e69d8cc410ae200a0e39d285b83fa9edb70f0481ae9f98b3d53eab9ba6a56fa6012096234ca7440f1965e15701f4f4375af5b56a80c2f60643b7e60681a86588589721f6768bcb04993717b90a547d2a13489e4c839ef9688d869261c1ec0231cdba66d3be991e8ca4b9ea77a4ae9217982500f7b26a81c95314227d01193b02cf600cba0cb262b94bcd6d553eb6fa82bbe21cdc80d57f4eba8aad35533c6901b0b819eb1dc681dfd3a60d6a953dee60c03634f4d730f471442f80ad488611d6bf22bb470bbd84a686b1b62e53a2eec88c65ebabab9ec80ba93d57c155f050165bda0f6b9e05a4ea6a1d2c7c04e8c4339d98b66f8225e4fea13ea94d596298acb807964ec9eaa1ea409b35ca84a9dd73463919ed9c521f16356aafe8f4c853973b4a4b28f8092c72bd5c1d53f37fb230034d1f3c8eabc08a17fff07d234f761efde4d000f5d049a7f6d264f636e528d95bc4d23727af8d176385cb4bff2b9d176cf6ed6ad8c1c81ae6af76ef045b0dc19a58c0efca0e8b4d7701d4f0fd08fab8c01cf1095e2872b591630893d1a345e7ec7d86f8aaa3f267fa0f89bb6adefad8584a613f2854781b7912680ab364e0064af91e10a08c2818c48cc962f3937ece34fd63f6c472051d4c949d6a0d4f73ac4b01562de2d2cc19d36c4e61b21dfe2cc452ba52f28bf00b83206339968971438855377f92363a515bcbdb02316783c305df60ed72ab7a8d0dcf1c8c5221d8f0ee4a689f8ee4a0d294c990735dae16de1836fbc96b1699cb051f2c3ab8deb2ce42cfab57a25eb4a3ae3f5d4d8b1eda9e2d09ff0df6c91182b68e23b7d32d22f4a33d1f8e8de96cd7f100319a7669ea9643a8389e5cfba5b1674b785ddd1511031a0af66d2321fc64db526f5d21745cfed3f885a68421881118939b1b248f7bcae93c8100866e8ad9b196e2c348002b92c5c11b6a1b391488023683fa66b8332838c7c08d1a34676ee42d104a720c75244f08b25da07a73e237a1956ff27aa2259c4fa0bcba87f4738f2de7eb9264d3428fa587ce95af7bdb1d3999fcfd06445a8f51ad865d720ad8c312801f736bf4a7ef3f64021f778cf74dfd34f5d81800940b37a1aab9b5986d81a8b7be4753260417e1725c103cec8a1b23a722f27bbaa932f7d6f942ad8dfd0c55507fdefbbab27a5b4b53bc2bc204f0766e21963fd0561bda6e6aedc0c31356419a8043d0024bae4db189ffe63127d0ed1654c945d03872178e94aa342ed6e8cb5e22caafae367de94a310edb716fc3bf325731fc44ea8e7ad50ec73ffc71487b252ccaf3119a2be13bc544bef950a54c585664f4b46a7ad00e753696ad5394eaa9760c0b615ed94f377187dcbf91c17a03d366c14aa4defa142854804d6ed349b4fb64cb01dd42a20b08f3db56c301a66b9b6b3058f426ec88934d54d484c88cb08cfa16f298b50c321d0d12dab037d2752abe14f2795a6c296121f8c8a566963c557ca9021ccd0b8cb58d4376dcdb8557f6a69edefc74b69b6a0d12cc06577bbca3becbb51998b72b882dddfe13a23285362ed5ff5bb7e30463f9c9ba780bfdf27ec983aa190e3446fefe80fd2fe8382ff5fca8681ebb214bf759b93da8e8d8831323e530322a8d68f9e0afcf7ab3eb314ae10510d67d4c4864b2b0d60bacadab3e9a6e702b7fb5a6201225c336abfabec088a71edc37451d910459693b355721dc0b5f1363842d89599006e6ef8e10ee7d291a067d3ac2d41448d122531481c571de3aaa3160f6fb4fef3b0c28bc7ed5bd955fd27cbfbfdbc90cc4c7ffb1ed6f7372b8a918a4f20e6a21e9c07beb5f7cf6af8219109680ccec2b15530eb7b76ac3036f26211592ee75d45955ce41aadc7b12bb3f7b651294b51cae4d5f8d3bddb07aa44da50348015c3cf6f4172336447f19846ab2b89e8f4b9b532f4e855b0a9fe68a8880642be1fe791e4ca625606a81ca75a5427142252ada0f6b9f19d7ef10fe124aec2bdf307d0375cbcdd012611cb5430ca92afc717a07a86809782827d0d3cd0f1e6d989b0710209757223a106f758282a6fa930d32c3139a8f6b6b219ed5a580366b371b7b78f8676d8f7fc177f48ce9260d2e72609696c7ca489913af90d845fa1e9e634c778468b3510f628bb9e64576033c59f12e60167dfab5023e1a202f0231692d7a87f3484c0d3459c7bdc1a91e28ec0ba7afe9b1da24555be4743a46decb361745c462f3aa7f9301656f3d4548570c19535e3939a4084cdb0bb98c591f1c89cc6ed729120d22401c67952907aec8c57189e5542d74d6578141664e30d3ea6808590494d0f83e127a69852bf6e3757bfe79167ec80c31b9aa8fb6932106b821d76bec6ac0bed3276f7e3b20250280b70568875b663d9575b8eca0e32f33300891ff3c75bb5caae0c0b0602116d1bf08636bb9497df1d6d7b2ab8e5832db7fa2b64ac3755655d2a019a64e47bd6aba045b4a852b380a52fc3722f1a037e100801a37ede58287799190d4b382e25a47075eb1409c3c808c6b3d133ca1c7df21b6e9b032d2ce46d6504f39bbe981c9feae2b6242bdf60a478b5ce763c131566c94784da13473e75596350776ad877ea644924c916c5c7de6be40a131e108eeb5858cd2b790ce5905e2c1a62492f7c68e4ea86d82e5654a777e71d9423bbe1b1d7f5283ac0647c1c73b4a18c226ff24a0316ae2f5c89f907db32c5c8c1f48f2d7b62f0960cb7d752c286ea1cd44c8c595e2005d0932d24a5a747cfab706e4cfe6784e64cea4da93505f4ee69b42f6ab8b8f711ad7976fa0d16efc3ccced35f5c1f77554076cb84e0efebe46f723e69b6aa5aa4b5e0040d18d32ea7c0fa01fc5c861724dc267ede010c102078fb38be3675bc1eb79ee7b453ca8ecae64c1ded4e84098a51e63be84f20a13b046dc285d0f3c9d1474084d4cf686c3bded8b05a30e132fc303f695dd9ea68b13f4865d3b704d16da5f06e79239e83639afb0c935c197e7db3db6ee1e1d5d12660288da2ae5198f11224047afd27eadb649e696ea05781e19bc80ff632ad8a10dfe4a9291a28afc4df75e1b958d0cb0380211a0ff64a72376543ed3288ceb859d209ae1c7b5ba1c20c20ab6e83c82e1a774252e22b81a505bf306dda0bf17ddc5c27369cccd927fdf8b3c84fa57d7d010d4c3b0012d55e4f32324b2303f4efb6b749523df4741f353caa60404e1a29262afb83acf51dfb92c2e544a659734a81dadfbc4a245d74fb1a762bbdc9043a1bc20bac66fa435c4f277d54bb63e630be4eb5664f3da1b93e4ed979a39271fb908dc031dc5e27957c213a5c270ef9500822032fd944b4072b23aef1fdc8d0c6c57b95ed6b50d7336ec26d647e39df8f9392fd02542e0bbd1d1c871c66770ec57fa1cbbe146b2f1c5d577b565e6ac42e79ce2ca5cc7bbc0acbd888566a6a983663b52444ab7b16755200fe2a6c9929c40c8500e960782394bf12076f32f7b9ce8e3868e1fac22dcd5f5a7bdf0c75729a6407983cc9a9e94d92c62288395f95ac693dc018fdeeee84d68e1df8d0b023e9528cf598c3d2d5184161858843526d987885d1bdda58a6c11eefb13aec289f323e671f28c29bd0e2507a7eb48525416c23799a099638b55b9b9b9d41e1e90ae842c17d2982d2482c3a77dc65c76853e52d03aed16fac192cd82493f4b15fd3a455308b80755bda94a398da2c5e77a90d79746f0e877e3bb468457310256ed57854e74c0f14b39e365f256718f33f0bf1b438d6822624f9fac8a9eeebcd3cc52819ac55dbc01b802b4c15eddd3633d3390576a21b0a929a020a1175a060d2a2b4a8231415c6e684a18e1f3a8ae9bb697b192e61da8103d0110b6b27c871afa509f24ba0cbc0383a4abc2925bc6537102a7dee5d36655fab32e9fe43be10d56b7d51f588a8d4aa32d59164dcef0be7e3a8541d1430f9b26458071c9f7686f297e0c8fbcbb0555513e9eb4ad60b2cfc97480ad03316e88f428293e5edb39fc171f2552f4d3346c1487d166b3a0dfb9e380e1a43020aaa091fd21b29d75f6a902ce46a723e5641967ec399cb1dd45d621cec667d8d11318b1f6091b47346a1de2ac742b470718055b062d754e0a5fc83a4d79da4bde2621ce9d5344af3b88304f10bd424651cc256e903bfaba6b112ef8e1c3281985093a21cb2301ed0bfab610d109621b67fabb09e4b6d4f80a26f6f93d245774f783337b0e7f4db01167225bfbf48e869a8a3b1b2dea378c39e6c45cb1954f4dac6e68a1a8f6c75ac1c8159ee807759ff72892db6cd2392954c32ecb8377207c85bf93fa328a57d53cdd7e6e65b0799f95ee862d79ffdfc3031e0d588963783185b7b526edae434501d06d1087f4684435f4ea61998589fa2c8872e1bf7e5bdbc9373412cb4554980b1b2a4cb126da7d5fb1047bbbb202d9e4ef54545a0701b507c89a64b81ff8ca953fd73a2b7c1d38d39aefd3c257f4b9c03194b8d3837bf5baf0c9ba7faab13cb30fc4b2af4d2141ef92fe93052ffe0b1ad3fa2ef5336e0e0f4be2668477a7036bf77abb8ec3c9c33fdb0a1e804a429a5efcae95248eabe5917cb7947aea63724768b6ae7901686850fda284d876cf33659372cf94beb38c09ccb64cb986b23832d9c54eacd24dd5d1436876918d9c45cfbde2abe2885a580de53833fc4d456296eb7bb2b22dc9f3cdbf7586a56f7fda25b344c368d0a232d5b75c704978046f22ef0828a22d59bfb705b1d505bc13a107ae22e246dbdb54361c0a70297bcbc62eaa4dc80a9d1d403d8af1370629586e049e14579eee7f8ec89ec4c0a74cfc07f7dd9ce72546d6ed6e73b63497140e9beaa9414f564d35cdb86374f6bfa6d69dd3cba82d29734a2c680be5e76c96f68ce9935adbbda1bc2c03f2b22e492d15ba0cd4d106c2f5c99273904438fa1b66183a49d4be6e4cb34237b966d40e4892cc48e0f0e1a97e25035ffd615afb8281abf032e19adfadb5a029b01994e500c3d2909dbb77fd084a08db8c58dcc2ff3996c06d4caef13e0cae9e9835e73d852e0e67b9c2dffddf00e37cebd29400f4ee095593ed6dd1fcb01e83aa7ccf6e92ca6bd68bb1a7105762cfb772a2c062d7d759d7aff96e187b890e83328aee0048910cccee0b0eb4d526d3cf717295007469d6eacf35efa37dcaa9ed81e1ac5c6c33502ee913a3ee57c87ec8e7f2f2b55db42d66ca39bcf08a00f22353cfd21ada763084ae5b3c1e238526e1130c23dcf36e105a792f4492efe4b30c75f1973c999c76df2aeedb59c0ab7d8a1992a28e58712d1cfd8d20bdea2707085b6974bede25c6d15748eadf7671aee0009bd28fb68a7ec92c8df5a208e4b3be3bd37c9e4cc200994d5f6d284c4839f08243b8e9176f062ed4e620a01c419aed6be87e387dd1ae68b90a8fa7e60d4b101e7d0755f056ed351413c76f353d52b598f55653d8481e649cfbac22f66f75eed97cf66281ec7b1b622020e3ad5a9dc107d8c5d379ea141753efd5ca3de5a12a5ad654ee05b5678037e528b4d739c88b11e104a3052991b8e86ab6bc75cdc8624d97a8b5ecb054762fe0077de282c8c8e901f1505fe11e8a3cc5280f0b116069013894e0121ccac200373c7858bf7bdcb80ef075f35b405b5c3a30bb7628a137f424f98040321941a62821ffbcab0cc99b3450eb98e782b33ba3010023b75ce0f498086748e928ce0b0b3895017e478d39a0b47e01dc09242a1a54c520a8133ded8ba119d7f739a512b17106538cba0df9c17bc02e5455064c9b2fad3df67f6d56670ab6968f0b0aa4dd6f90e6e553c7b5766f706917bf7b811da222aa3194f545420f6d7f999d7e2418da992ede4ae20626d64d24e4d480e594d0841f746758afd08361757ac6fb5cbe189d3693a941f5c89c57c8b3f3b6ca1e815301293858e42209fe03c6f9aa1165c1beddc1e62e90f2e3f5535a3f09bc223e687861be053aeb25d5d07fe032fce8069c106e7c186cf07528a03da09816339796be6c649cea9026d092a2b74d4dee2dbbb5b02691bc172bca0777e5b1c9b477d37fcb048457bdc54f96f7b1c6db6eafc48a666195f12d440ba3ccf53cc08f4187d00e5f9c16fbd50deb38c1cc3e8a7571cef9adf0bb6b3d0241622e0d290e9b87f18ed8269dcfd34941c83ad6d283469c9f7ddb8cc854e8eb2dca70257376cc5a2a6d6f486c0105906808f9db7336465a0c60ac3a7c1aa5001aa08a66a97b80e0d94002057aa5977c40d7d1f6e812124121afc048d86366b54528ef38c473b9850d96683dcd62c21fc8fadd4486be55aa02c026c9cc592353253d55c53bdea0b3be522ad7e3f79bd317bd258ba248bdb0b13d4db8687f8ae4002d4257c32f32e7481cdd9d135dd601c3ff1a371072b32476b21c06471b7922b67a775a9f5ee4f6c8c515609e73b02a0f6b2e8a851cdfb812a6f886b27341c543445be4ac5815e6e65a9c213819183548aa838c770f1511cb2cfb0d213a4f98e494a191ce2b345b8d3ede4be162d6cb2b831d4aa319226153ca667c4b04b7c5f0c7ff3fc2a289ce09467f4d97b12e5b061f690bbcef18bcf20ba13e8d7bf7c64f4d57c6930c2be8ed8e55f469d70b249866bc92a1945ffee7b1c3a84b6d2020d6dc512f8e763c88428f5ffa2adffed3356a9b8ed4949e80a60c2079b441e331ad95ed0ae2734cc382d6e38e76833562997f323e0c0b51529c2727541180ed0c15d2228939c1e732cff0234cc7463b14fa76422d20d72f0e4580bbd609282486d5ab02fdd198194deef93f0ab33cd15250998f2d800c93ab8a218ba90f8e0db24c4226745fcd50bfbdde15a6b0bd19875157433b0f78afad8f7d3de9d31be293d8fc1816e530400ca4f354b1d0bfa4bc3675c894e8b476396edc1fad17f6af10a1ec6655c33e414787d8f87fa08c02464c10e8f738122ab8e15b45e30669504494f048b8426a424fb5943289dc575fef78fe138e9e72d685b36bf362ab57132c737f6ae3911618fe889d2cae034d8bdabf09ddc8f606deacb9653193b1d507755f5ef267955004831c5e4319c59d72636033acd7c7f384f085ffa420d7390f3b7142c43ccab53fa8702b3231e5760dcb5224068719cde5d27d459a9e47e9b83f0a98cb05f533fb8a76334a1208cd01c174800f5337a593dbfd168c7b1c2922e299900e983ff0a38a0c20a6d9b144bb3301421bbe62ebb731629cc603fc7a12c6907683f2cdf3f063fe38ff02947a6c3bed361ba64b0afd4a4d3ddf1d66e400cd2a8063817f12b88aca66dd46aad4c672925e89eb8a5660282c2511023b37b605e48332026964b897bb5fc4e3ba4fd9abeb2742a09055d35601b2fa6a378cea4f155001fc6378834d7dee8b82d8cdc4d1935d2133d9bad5e7f92f93f66ed17d1be0e3f0c79752d576ea88f61300c9853396d9f4af0b4d1321ce71b244678f053aabdc5c269c80f429bb2fd3713ffb879ca521a21fafc16166a743b284d85c589615e868f07de4b56e2a05eb194900ed62223ad9fa3cdb906ec8e4387aa57e02fce171cce1527b1077775a01c5a50d0292b5dec2824f70de0c4199be229bc33475093880866e52293ca223dd178fc40e9116d6befa8ed4351b39070e07ab4cbe37f70e06287e81574727652008f4482c9966b2fafa90c671d964b79b5236a6ae060679964c2a6619e07014b1654b7c22afa5675b8b00cb958fca7e9d7d04f3257cd692b236d046bb7a8a0bfcbddd5c4176956ef2bedb893b1a4c559c34884c65e9b8d5414a7f5afe83499f6eee79033dd5b879e846ee582ad0dcd28656a615bb51a9d48844e1c27a00fc12d4ad60badd09e94d5aedf164449a8ce44b68cb2a6c53de8ab15e7d5d2b57fc773a7364c16b9489b5fb38e16b30272d865defe7e1f0d49f90756927eb462a29bfb2c53ba58ae39a643676619f6221ebd0ff6e4c8d6c9245420d2dbfdd8cfed19fbd8ac1ad91742ffd226eacadcfa736310a1c48853987c793d49a070fda4169c913daeaaf5fa7aac5867ca762213746d42a6295a63cf8014fa9cf5ed7fdff77d9146f4a9102e96c47a08d49141f1e19e5766e89095d31c2ca8fbba26ab7dabecf0e9f87081fe9b51736cb2fdf70bce5720ae4ac86aa5d0d9bbb2021f04b3066073ead43839fa12b785a22a3aa71a07ce783451eba74c61edf18e2053f5d7545186c507b038c76d8a3ad8efbd6b9a260ef21b7901e83f378a569dca78ae8fd62c36d27d4c4ec6d548a4e6b3833e5070bc71d789ac6a889c00324588f81f3a4d95a480559f9009f8924d9f20d53f4aef0e0642555b3219c63d49fe213ee2f05a00ee81a0e17f12c500f0db366d86a3d3761e870107ef1dde348d8bf71bc6f55653a392c8ae50dd8053f4b240a346b86a0a737b2986a28188fc48584ac60d3944a8075ed652ca0d2c671d3b5fee250d80457b8db9a98e2d673bab6b8aa91a07e5497b6632222e466a19217cc2139b645af4ad2304cf6783eb66428acda9680cf9d733dd1b5272aa68594582b4cc1346e826530a0da7978fab72690e3e26471c6859985e387338df2a64eac36f2d2ca58863047640d1dfcfa44cda8c12437d2e340c137a920949366833f32288cb9e63d8142d952d714d0423c947ca6a416750a71228e1af013a5f0ff46089d160920c843050f27a27bbe7d990f21c5c3999eaf10c129ed377881807a4628b8c2197d4a55ad7b329ca9f6794fb81e85b7fce39c9fefcc4a8f18dabb7f395ebf27a6d54f55b60671f898dda43af48ca8e41759ce9073bf6fac68579eccdd65092bc043a719d2fa83b6baabea46a28964de5f65c2ad49a53b8c86cb3d3a769b9bd403bae8f1327cae2eda07cb1a56cb695726be1b4df2e47de02ffdea66789b6722fd10758ad8db72545d48bb98486a1f57c7d9bf5e398bf697306c2cc269b0d582095a1dfa75e0af99f28515d05f14f480fe7a48440bea8b232b4c0949208d7b62e63963992b583398bd16036d61e146e678e4548778e80c8d3a5ffd444fca10762473bdd0676cefad55d2a85af8c2eed71957b5e2cb1a5d2feef7b3e3aa7c4d7ddb3a4346a4dee0b9ca73eb6fdc874a2f2086d747e907917a63e52460010df53c205e0f6739e03ee15167483786158b8f7247ccf539bf5dfdb00f3f2c5488b4af6399e7089099513a71d5766e8d64a1add6d4e3cbaaeb6fbfdbda4db16e80e13b944fd6da14bac29ddcab66173746e23f14ae74b1901c73b4c6f789f72b1d0dcc1684edd423b711e1785740c85272f0d0923178a104b9af6fca50d1fe7d678e4f4dc366f46a1b8e4e3816f2bf54a28078108e9692ff5db2f6ca6cfd48b4c68ff282e40ab55cabe70a6e8768baa7158af38d6780efb77f9504cf70c1ebdc7b29dc23c6f2592bb4c3dc48f9a1c5f46736b3720eccc87f71fb296e2f93de5afb442c9fb0947f97f70e9784edef099cc72533af91a682ca775641bbd98bcf9789f35a8d801e313175ea978545a25ab80f44bfb69ccf8d0b029fa236b0368ac10661e4838b1c0f9ada8c47339ef4614bc6f836d4cca922bd27323f7f12dde4fd5ec3891657315bc1b7c10fbd7489263feba9f064f8d4e6c7999b5f561eff0427c43faefc28131da67ccd1128efaa974ae6256bd63b4969fb92abc6713c3a3577166718c72005bc9f547ec877a3a259fd84fbb0a811376b0f7a42d6059a49be5b994f4f16d679d0b4df27d5a7f6a65893861ceb9906700d6bdb713cd79bb02dc28b953d981accee2031be672ec6f7fd82001cb03f8ca92605d805b2edf6be4ab9c78574098a0e16fa225d5a39550ce9bfedc7fd120adab747ac13523884f9000ce84ff861aa870f68b578f9f5ffcbdf8d217fe1123f77b3e61d16bfe62ed8b4a3f6eeb041978104311492a08b94a25384a406f79e3ec878a247a6097b1b0ce2d1a1f2cf852f05ffa172e8667ffa147d41c55aacdabe5a5604f5986bb941f0a9bb425479851b278655a2d720661b95f9ec0530a437740a608e31c3d178a1fd904e60b79322ebb3e4e8ba5a5b63efb51fa21d35db4a9ee7c16420ff8ad32499040af1854b7ae77b188466ab075712b0aa7d612092d0217686c1a529744bd303a0be798fe511dd22c3b35e3803d59942ff3999d1b37280d6f5e12c409b6eb895058576d19af106a35452ad9aa11337d91a596313e4036d76a32f2ad05e77cf813d0677e9465105c259eb1e1217900de1364d44145c7d8ecb065791ac42b18a7e8a119daa5f128f1cf40400fdaf96b2a7cec2dda94dc6d0218003cd67d8e85cd68d1d07b8c453d65edd9f1166c70a7471d276187f295918b6908845669a52cae910d2fd27654429ae7762c142474a754850a192cf98657ef5110f4ce106d4529fb55831f8130a2a2af354db0bcc72d1c47a167d1996e101976b5d5aee2fa102c35fcfe0233577a68f5ada14bc49a9d6e79caaf2840dabf88c2611ba313167f732a1b01f3d71f023332410e264f6da6bcd51d9c078fbb3a1523235f5c0336da5f150e7e46a9ba260bba41c3e2b015e10d57e51148b4bb3bf8e607271851ec321f464244eb05cafcbe45a6c39fec593bb01a1222b73cba0f6afebc4cdd577bcd711927eb632d9b7f6c2c372b00fd9db7c2b2e03a3bbf15b579b21afe334dfa4a15500afa9334038437253716b15f762b88cb479aca387b84875d70ece7fdfc797e659b4e9fa650822fa0704c4c2caa9f10eea647d14ca8f58b381f91f1b1415a767f68b2367e00cfcee8e7a8a5b6dda7eefe156515f02c1142a6a82688ffb6401a9b9a97189eee2d6d6f5dc972720050bf422e3b09a28e809ec12ed3cf16be8b8221cd57fb8d0bc56f30216a938224a8c462dccb966dd85d0aa418aaf1e9f8495a1991414a6dd2d6ee69d59d012e6df4c8c286fb70de1c3e089703e0fec88d70ec343d21e0324aa69cde82daac1138a45bdc50e530017e7979d5987ba24d1062474870877dac528139077bc5fe7cf1b1e71a23e64af4a878bf7f538633a00660f83ac771b2be49cd14a5496578d6d898dfd9d30c502eb070fd1648e2d65c80c5a613704ce4c366fcd2f1a80dfcee699e1b8234089b9d54c6aa477d601838f80a6b7c842a4ffa1ae8da26accec828662311544cdc4d775de09f98b91de2eed44c3305b2d98d7641a0bd9c8972b671bbeb5026a33869dedca63ef062ebee7081cf44c09b17c13478250079bce4f3717636bd299709b9221b3051a91b1ecd3e78f9e7267a4aef145f3799bcf44ec4c31d73434b54cb7afc7cc2e1e506248e4091255fcf1c8abaae5c2f4be36c9f0e19c7768043261f752e9fb58c071b8113bd3978ad17761b42ba289b1ac4ad949662c4c7407795f8a430e59ec23b3660d5a9f428fab3000b90241cc6ef46b56b542ab104987bdba552520775be48dffdc7cfc20b38bf55ba16f969d0a62bdfefac57ba96ef40238a37bc67d90415f73c1c986561a0deca6ce9304f21713b47829b37d5974807957a81b0d483374868ef514c1a8f79078df10a78b05be58f9c683ab52a9161545ad256046b99f2a4b9ef396f9d82018e9e2f3add51092f5f89d9932a15eb9473e89221f8c8c033641aae3997d267fb1006cbf874343b2be681054d4d9d56b559b3ec3d6fb1f1b39276d40bd976858fc6156de723908686fff2c0d74e8aabadfeb64911d0c177d18c5c708eb64bcce81730c85d29ab020829c411828e4fc49a8de304c1a458fe8698a1698c7a0d96875d26509bd15fbf9deb49a502c536bef2b674801649023ef9df67190b6adc720bd2f2d9eb385969992171b85e1c716e0b9ebe443e73f2dba80b60f27a02edbb124285484eb3e0a86ad7c18f86211cc148c8f93d8b4984b6bef9fa7a13d02450f54b1fd6978287b093ef8b6e8f8ef09976c212ae4456445994f30bea70024e2cc21e8abccbd0a7c53edd1e1c5b51ff668bcf6c54fd5b03d78d52e2d7bdac12a3f8ddd5e17d8154015be4c3495ebcda806d7bda58fca1c944749284cb8b0f3b59e255688a14f6182d28a9ecf030142a5881cc4a13091af8bd81a0fae95fecad97f2982b913f7591dd9f5eb4c6c2a55fc55cec04869446285d5893ace9f916cc2cd8914f0f68017310a2f69e627850cdeee8feefcd0f11ccab4f75251eb50962dca681f2c95935cf9890c765fb46e1a51b38557461777321394ec4794a3cc7e5decf8115c6c0926730d678d0d2957dd4312305a1e844ce3b71f23dbf004e386d0eb5d45dde333853850ac52bc1075e79bf1abf4361c5e7f90fda714ac1579219fa94b10d210268b29e9be8dc0795b41997e113da4d702cb1d118e524a93e5724224cd58fa70c821d56d68bd0dbd20ab22bc1445dd1b147dce4fcc221ace2121002f83cb49e48c6f459c294a077b48f3ea69cef40cef99cbf27b36219efcfad76a4cfeb116020f14d827d68bf4c31aa30f3fe3fe3ed8fddf40508589b5c4debdfdca0a32c13fbeab4c07cbf3003239552713cb2b7e2218bbf455c800cc01a34ad9fc078dfa06540cad7b249a8abc2a1ca7900cf764ac68966638c0ba36353272ca149e328497a53db85b2138dfa28456a5b77505d5684bbc1b81336301ebef8d70fc738cb8a3aed43f046064277fe54ed89207fb6952446c6e30b8a172257c997e4a7c60e367374eb51309659b7c4f9f13e3971ab41e8ad536ab6ed0487c00ccdfba856635046022dd6177fc23e93ecf70f1b4a37a05977d757f4be16dd38abaa9ce8a42ac63068df1b00cca5a26a115414320c92c867415a830fe5969df9d520b18652e21bc47febaab81b62f88673c4865d0b1131d506562d18b1d29a125941a02f7103cb446b2547c90a968bcac7ef9f2257e9111ed6bffb73b651650e8011392e96045006fadb9ab0ea9a4287006edb8c97f8d29e1769f8e47076d9b5b25f461aa5828001234a940bca25d70394f0da","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
