<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ab0fddfa0fa338c5da5f1ab48e8fb75f8ee04e39939b3c7f0350bbe871640b835c6b7e3c171f66dfc4ff3e38a53defabffa8b28a438d902d18542da09c92167d74015c69e6fd3ef96c03f85787e11b940f78dee4a8212ec222bc16e5601db5b87c46e32ba7f12ce2fa81e4ee4a919d4def9955c7b3747117f2e4328e8c4920139fe8d822ba510482b7d782c9c3c698b4167b4b1b56f4790d55c65257198fb1d9c705af12e33883ef3f68ed5727d3684d30eea72f95573fc7fb0fd21f9c41267ba964d5db2e2722502ec2861d4e661a3cdc7446ec4e382186b3fb820605188e58f7cabb8c41fc9485ffc23e8d8a20490c55c24b7e490808f34413899cd959c564e0d7f2b951e286fc17d775aa79bc95289b162124cf05db1fdd93531c97bc4eb641bbc5df348736a5fff3b080e433d23c0fc4a1bfddc0c379450c7e70c381c0ad410a29eb8164a9ca72508c6bb21c1a27f93f8888d561d1d3ceea4cb343f3f4b36ae60952f3ca119c724186eccf057a60aa176587cdc499cf4e7de05aba04d9dac7e6409456a96308ec4ca859fe0fccf2b2617e2853bdbd39c3b260c296e2794306ef39cec59efb5c7ca0d00fa1977303a488024a3484096c461caf32de85f6d079b5d9252b320554346037834f57b11647e375af5039c4ac3284fa40944f54fcaded0e17ab9690b28cabd719b7462a67ad933b7e545dc7fddb85901ab26ecd7c3eab56c3f4657d70a8679ef8477ac8d726c2fdecf959f80e11937417c52b72589f0e115c9a162075729395333a81f1b32a64624a44b9bd712bdc6ccc2bb89a4b556a70ed2c7fbe2aaca1dec59847c651434bd2d25dd0ae7527c1b4bc3fb83ed9d108849aa336e88282cda013e6bafc1ecd8806faab883db892d6e21a4de1df68aa6c7da827a6ab25e9dabce7f20dbbeb16b1bcfe5a4f2bf87359af9311032e83f87c19a0da32539344b1fb70136d084ce0a655128719c77b6816ecab1e79738b22bb7fbeca95c570783d25ab1e2875640488c1568065d14125008d8a1587b456d7269283456b03d2a582d294ffe93dff1f53d17ffafa4c57e3bf08b56c9392835862fea73245035c6ff90f6572dc6376b13f16299de5d7fe188d3ccce9801183e86e0179edcc7046c42896a66747a07649786023bd2fa676c3acfbc975199a148be0630538211e3c64a1bc2e8bbb23436e6530b6347d1d68f31f582e3cf8ca81821b4c9a09fe4f4495dbec9c49fc56fa4f830002faaa14316b6382e790a143fc609873febfc0971707636e45d33859b2cc1a50f62ed849de443b388c405cd717ff01e63f063c123615a2e27bed088d04e1d9d072c98670aeded7da07299ee78da36a79fa2ef7cceaa75198b8fe5a8c44321f40bc2cbe9f23a9d8dc60c8544be621d65ad25e53e6e66fd67ceaacb23cc97b2173471eb324626a5d2ddbc536d653f8673af49a8efbb2975c0cb0d81330b368cd02b979ac861ec083b09546f24ce68ae97df71cf45e294e8aee1ef8f0ed11a413d51a0789370879b23ec70138d285447931ccb145e0570ca79833b516bb141a7175eb7075eaf392cf015fe3f8318dbfc1fc0c68f2d37dc52b2a06f7a0687cd5f276757a06dffd1aae97171741d2979d9d370839a151d94ab451ca3a042261070643242660e11c856efd3f1b6b0c00bf8a8ab1d5de5614e684a0206ac06eff84bd24b71e74ca898ff2ec6961559bedb27c87cc721feb3ef5e24768234c4c22c5d9094eb57c04b550a28ca4f39e441a0daabedad2ecc4301a5a8666007dac95b60404ffe35b053d7fafe1029495e8f66b37ac8e91b9817df310b9b3fac4f50dea97356bafb28e2d76c33913091de5a1c4dd1c7b108d1001938069841530d9d4a4543885797340f74b2d7c4ea9d71a5096b45b0f62041087c452185631bef7ecc4c7d123bd34f9b0fea420223c45b73edbae163e8b64f6a355c286861922277c32cfea13c2979e0db83ac67e85b48785caeaca905815b31823d8bf076624797077a707608d9edcebfbe7d2808cb178cc50959741762fc170e2a67078a8576d869750b1fa01392a065e7d5cc5ae92e72ca4b0dcac170bb3b04e1d780396ee4e2337defa9da8237dee5d5e69abaa4238e602482261400f98e0d6f9ef013ef7f793040b668240ef3f594a18c03fabe68515aa92cd6ad604e06c01af61189a305a8a90410046f7b3a40124e805906477f2c90749e680e00f8e6f158f348996ef233cefc378272d3d9d7b5574fdae71717d3d753e94748393cb0b288c9a405aabb415773ab309ad80f4bbee298bc8c21320573a845068999ba769f812f17588168c6ea5198ecf1d9f940c797f6c7a8c06a33774acb1830fec03c9b78005c613f86f9624149d057c76fcd48dcf59c1597ba4ed0d8f44a9537ceb4708d2a81275a1981e9bda8178c67629779f971cef3273912602d99444f1e6c72d5a74bb572ff898a628e47ad1f66d420594e9026dc9c56667e84a8321bb7ded97770a91be1fe48841c981fca7695dc6be0999030d1841583b786c871f5e97230e0f6bb084679dd207e1d93a9d96c7a8bae27003365277036a271dd87bfd769c0239718118b9a4455b7f12fa3c104a27764d41d47ba10843dffc7bbb93d5ce1cdd8c9016db5c6f2fcc83b12620a62aa12477da72100c2b7e58fea7c99617fe92dfe93f94f23c7d522cc2f73ada61e0587e5a70655ab857a1725339080bb24b25865d207f69e3a5990892796c7f59da67c54f7db478025f1fafdfb5f5ade47d2c7fb1aef65dbf0c57caf46ed9d7d9cf497a674b2606caaf427b101bafc6fffd2b2fa41f908b22b88c012f07e02ac8636ecfe934be4f688ac141407418d3f2234efa29f418320f226737b223840dcbf8073574ceb7d63defc9d1692955124fb5c334e36318e0cdbfe5888a71d03824faff03d117c8fdbb6005e5b2dd12f1788ba6cd5bd329b78b094176eecd2b6268bb2be8bc304be30448bc2e5b891ba4986ba335e4cb08aca9ac0681ba845b94e1384bce6ec62d643a8cf37e7b2f2437b63e8c87932d5bbf4eba6ba16822c6a06cc63d0e0de25fdbdce57c86f5f5c772ac45e44f27db9cc267df9cfb55ac573417a02ba8d7de3b6c7cc1121a763a07c7a71242174be6baaa2fcb416cd17763c8d3d23e969ea5c0c34b1d814e600eb3382c0573e54562a7e676d6188d5d17944432954ef5c71cf482e20f295a5467effb928c3bcb3ec26b677b18401859093128ede594876374ee1201651bc504aacfa4ae92055636ba1ed0dd0867e970d80914a9a6702521c3cfa28b32fd6797dc0edde3e6f0d3d64e86b7aea49c85086f2ece02ffd7faaf0db97cebba225b40580bbb0b3acd7ea40a41508890a2a5cb3c1f18ad024d6debbfa12a28fd3f31dd166009a4903f30bd957d28a88cab2965a6b81d713da16de77c1a9154adce9285dd514f1e9adb18cc9e72812f0436c395e52403caee1ce30c972f9587485c943954fec6d7389b8badb42f129bcb2e99b8f93aeb2cd565174f8a6e17a61c87a8c297a7b8562b012f90df535ef179ff93483e2a8072e32c0dea9d2f4c288d33f1f3acf66328c5f276090b4fa506f12b15fe77a6c82f386f6a17580a7b41bac29af23db77d59919395dbe77ed05104ed0d5438d6a47cc9eb457f80fd9a2f760e29f2bf56d181c4d84a73415d324556045c63a268f8c30a73fdc03ea24491df8a47a3cdd139e354c39ea829c42e14a41bdfce62e4dd1a91e01c32fc3ec9bde9526895484bd96b06a5ad49945b1a1b0b5cbe514922c5ce81e14970975d949ee1f70d9890c34969f98c9b4eebc7b2e02b272fcb493aed349f6b0f69d10b3d1f37501e6ea02607b18e7d3b0ebe796efbb13d8e6931e2e5d95a0e79a85e8aba35af1dd0565d21cdcc16a1362f2b42833ab69081d1979e8c8b93c3cd17e05bb2eda33a400d2e3b8281c4203c78ed2d6e547babd4f13e2441da0ceb1217244b90f806d58917b0b1c1f3e9f97702c1ce1ea89048d57a02c161bb6d3612a4c19db4e110b6600c77fd48d51dd886851e5b335e22b985e7bd1ae72bf6a16ea08121e3b2827b7327debb5306e1b363955ebc08a9b66c51e7b4ed4b3cca9eed469401701305f627a10e9e6227eb82ff3b3c4014022fa397451c1f08b5cfe37caa704ab92cce1c04fe7ab1dbc4cb024e87dacd14ca361591c4345032ed3619562edf5bf64d4f2d1a13fb4aefab5a1c8b814aa7d536604facb8473f81afedefac6847143c426f0c5ba1e403e089835d081a663fc1e1b73c07456a7ba03fcd87376748a905a95f64963c58bbc55c0b978c5ad5276624faf8b55420d3005c970ecd86261b61647db25f8c41aabda945528189f8a28dae1067007205c1f22ed89a1c44aff479082014c996907a929f544e1045e0da93a20e738be460c1d552c59604893c91192910f7b3e741d8e0916f17ecb6efd819b459c07327e98c57f9af89361f16aefc999beb67c162e6ebf1337b9b386d007a9327341ed1c5d96a75d1a0367c6f59f6b272d0088abf573d218ef4bbedaac19f70e652486acc71879ba6c28a03e4003970886b80612ca69f0565986f0bd0459aaef3bf681d2c864099c8e2349de28eb692962d4f7c4ce3c7e942f56336cddb8e0892dfea37524af741feae1a2eac03c67a01cead047a883a396397d7df9e9a44608fc063c898ed72ab42d0953c51591e2a5c4fd3de26f9d2e3673661db0c30b6c44a8341a734093696ee782bb47fa491b49812ce72c1014a698865c72c8c454bcecc36f8000e758487aea0780a1f8ead8ea5881df98a55767a539d11a3e706c7c082f546f653a25bfbf524378b2d3b037687967653413ed8a1c2c1f2509ec190e7b2af5df468213deda6f1edeaa3eb03afe5990edac117a5d12d54ab46df781ef0e64c7a7ec909f90ed0e579d365dcbeba848e5c953a8c776b888185b9fcd6b96ab28e6cd13ad453fb6f0626691b8414cea316ee7d6d2ca8de4edaa114c93d94201b04028f3d74236e2efaf3a60fe2948d11da2231307faf591dab1305c8703ea9108fa5a5f458ddd88b80a2f1ebeb7368de8e6da9367e02cfc2b2d3ed33fe70afe15728452a0c5e8aca3f8d87b822c6c4a7bfeb88e5dad0590715ebb42cd636c27004fa363839f9ac8d5c0f2eb4b83d92fda104efc59badf40650059778bbab0c49a86d98a889ee3b0c9e6fbc95c9e75db0e247c3e8392b73dc6e1871674650c0dc529e8856c55fc53b2d3607e64502c8b6c899aa51bef51f0ed4d0cc2171c3a3fe8d64fd96622d63d279541487327e03b61d26a7a268635ff2fcc82952c9c2eccf87271e0ce13ba69d649f5733feff5d62da26ec4383eb9c30b1f1babbacc791a4298fd323f3f506462993b26e363ba6e05a08d0e3dcc972360f92f5cd4d3b224fb6db67ba896ecf29ca1e2d0e33c49f1e6dc784137817dc99a9e77dfda39524f80448a60fb4b6bbe62090409ced05e58a11fd1a8da22f2bf22808597e1629b94c5f930f1884f6e636a012580e489e1e7ef928f30b75d4257ba648c3bb0786af588bf85be06d7b4d9a3a5cb650a2ae3eff11e129ce2b1be4d63b6f3f06de4f9df86fab9a3a75a42d631eff5dae1865e8073634f5255bd7209cbb9feead38ddc687da0eff1a7ae3a5068c777d25f940185a8d1b0ade10f5e4f0e9fb55c9e1c08ff1fad8873f0dfc45cf20f8dcc86c291c9cb24eb661c897944093835f1e80f69c213b28198d0a5baa7b6a0c1482d8a46f4f62e6ca816c608c7f72b4b76eb3b1323e8c8fb7be3f6501e9bdfd11ed72e5a74352ce1737dc95a39bdd13ef96a9c2afeac20c5642153d9223266a876788c23626aabeee7344b8d8d9f415bc7d368757d6de12cbbc4207bc683fd3229a2c55adb076b4fa675c9db3fd46084182bf202532cecd29e1c592ce706a589f189ab1366bf7a98034814dc25c6cab35bf0bb6d5d8d201206421aed4c6d78413c0eff447ee6bcdb28cd03046a9e8db9cc5a91df8e4d2d23fe120187233cf155504431a8f92de2af30339e1dbb65a0a90ef5d23dc585ef91661ec0a9d8cf6379bc0700fd91f4327b62611d507e0ef8f896b550e3c493ddb87814c42816bc5e98989f926ebba6a6f2a2c5da117cf41ec39e742606fbcfa58a12f6c64c348430912cdd4ad169acac64f2ed0ae2ee85f432fe84f6e614324614f4a457c0e0708ae3327f69af8bde87ff8bdaeaeda6bdab69125143bfce8cfb994f0c0790672058c6fab701fb32b196e17f2826001dd516868b3e51bcd04ab85e95e1215e64bcc6cb8cb6e3254597cee5c10a0a092985a5c3f1c5b9a85ff49abcc6c8f8b475dd2b83665abf697d50a16d17914e1edf22e224978473f188a4f9407b85741be4b1e9d6d3b5eab0ac419f3ec0deae43aa230a2422d9922535d88ad2465a05eacf87f9dcc235001281eef7a0632325e3edfd1eba20e8c993d0569e98215c37d91c30085ce5fe6a984a1ec7b9672eb4f5ad6f2588a2d8139af495d71b27901f530f3397ba628bdabf5a2a4f1582bdde93a11d0bfcb8e52b09c2e6bc792541f51cb0527c3d7c63eca3c190c602193afcb7027ccb5098a9e64c6a523f9e749a7c5d05fc93c6f779089a1aebe1a0bd6a305b51f75fbfb20c0be6f1c1c46919e6b495ed765fd38fe25ccf1c33958e84e8a1913cf99ca8493875815fcca4125bd96430480ba81d58bc15b7b98f00725a786ecebd0a54dd0adad3cc781d16c5957fb218158a36790dff2575ca8321927709f99d3b595a7c1bb75c967f038a93ce4587359aff5f802b3a86d344b439cd7b55ef1654959638d0c5d9b1b661b8c97f0b5c6a8d92c70327023d38fb21f3c4a18ce3654f1928879cb41b74a1ddeccac8e697f9fb362f46cd350107051da9282aca01b57105f1056090cc82217a23bbd1391cb48c65a3fba493c9e7ac8ca961616caa85c814ac57a09854f83e6ec5e61846a2cd63a939515d4d6d338b1269e2701763675bfe5726594265fe3fc4886aa106b108e8914ef025047069fe2632b1e414c6a9d5c45f6711db1f27fefdce49f43018fffcc8874ed7c4b59f58ca844c3b8239dc6196fd6ed7bb31588fe8caf783acdd422f6c3d5069f65c277d101c8d8172f631da28197464a430b7d0c5633316a65ac5a8d6e9bd3bf9b939280c2354ef45b89d1b4db236df1e880056d458131c0ed2df7263942d086df39f84e06cad87e4eff4dad889e2a2ab56b4e9b524f1b1499d2cdb93de45932f9ee14cc91ad9accf9cefd0a7318d2bed319f7e796387b16158f8acf69de12ed854f816863058577f84130881d83e4edb1d6361cc0c2a0789980073efa80fa5cfbe526bb6ead549040a21ed5c625858576b3a266336f8a562127b7c44a9ce7d443d5d3333feb09ce39d574bb8d6302bf0d679f761510290f12c8138e867b9b9df5ae88fa142392cb10f5643fa7bc31db6779482032b692dd7f67c2205cabf61b15913c40b2ce864cc7a2afe51a85107670b3cc4e3422070b221e4418ed548adc1e9da86a3a748b5636d717b3d9dbb9233cb44b72bb9bb952ee48d492dce47e80a0e6099dbdbd4ff6d2dab9dbf2244582cf7d560f1878ae9d05a5f32f463feeeda7db7789471b7599e414b90b75fe113d68a437de6978fe00570531e23a0d954a61a04104a8bc10e5de49a993f73e0c4bfe4c59eeefe94666e99a0f4e64e3fc8b481d979c06da4ed1bc80bd6a93615ab1304aeea2e1138202e8dbbebdd2bf123419db1daa5487d4a6e8bb7ea81739abb29c81bf645531709c99c4385ed686cef05720321759ad4e916a6b9f17e6c0efb83b555d4d5c934cd7dd05e23eeb84279c3bdbb66cef1a9aa6f59f07e7f1135b647d22bb12d298e37cbb9f4f8ea7f1a31b1145e693b849873a3c9c64a5810a7ae52932d7a0eeb8e2294cfe79caacce9ec8b748c828473ab863cbce54ab50019311d50dc7db45112a7b395dde9c2dbe20f8b62aa8c24c64b9433aec4553d7e0a3c3e6903b2a1ba3ab11b65354092c75bf292c4c5e946fbde0f992e36b928ccc1205d0f410b27d518d3068c722b9f84cf66fbc57ffd6f956ac7f5bee2529ed2a324460883e0729fa5651f4d4f42bbc9080f0da831450c7033ccfa1a205bd71c5584afc818f4fb7a85215703d79408c4cbf412227b2f5b0eed4a40503736285258ab92c95116782a1286b35c0bdfdb4c508771beb06dddac15b9e90d2fe29493baf473c53ba1acee46aa67b05624f753091513f401ff3bd6c8acc914d3eaa2cca25fdd2daac2b292c4a5b0b0fcfe6a58e17c29eb509e902d76a87b9206750bf90464714fc92b1fc1422380e5cc01b58037565b7c02cc4030966310ce72af0d60a059416fc9940e4d3428cc7aa1765a9c6de743c1ef654f19c21dc125a24b4b5b753c260f19c732b960466c0ac0e10ed56ac98cfefbc68f351025d4b8d86e76c2d86cab979539f6682411b66a9e58d07eab2ce06e3d950255f9b1ac25085dee89db396761d50407d56119afef6616e3df5cc3ede8f72d540edd3b7968bb75f61fe359525705f67e34b542e2d28e6aeb8b9c09eeb70d0b4a70ce65a2cae5a084fb8e47335521704870d8549d9d0f5980b3d3cdf3b92552897fd7d59fda3344859c512ca1bf37a1c73a79446b3fbd0bbe89e865784685db21ce8e75c4e0e4d7d361d591024923badda0bc5cdaf20d2cebe28bb618bdab83445778c5ac689fe1ee95e7cd1bf3a4ab460cbeb3abd3419deb4c67d8a61705d228b0d226938eac425c71f4a2aadbd914ab28a7e1e2c9ae5659c584367e04e678ab9fdd8d3114075aa222a0f10abc517bebfc06d14674a891a81a203f5628d85e9c2ce730572c3b3bf68b5af4211c62983c6677de5a389da73fdba07a496902fe78371e5dff11c911df4e00022281ee06eaefef4cfa3c3b76978f2ad87c9b83d55e1d1f7e9f4f052b7397c8960f4ae1804cec2fd28f743e736fc294c6484ecc7a5057f54ecf88a802d2a540ecec0b8e34f1971bdc69bbd4987d447fb641ddae3b3335316689fc1846ac6ebb3f566d7137633aace18477558722b9f36b21a6c529e8635a10967b5ef32e0458d98a099581adf0883b8997558a3deab079e1835a90e030949fac3fddfa01f74a13d13fe486c236b0b50675bab45b948e6816c4d0f98662d103493b88e5c06c0a87f8e02de7df8139ca60d0e179d0aa8b66a0fbcfd8d3b2a2c799142f23ed8570de76f3e0d9802ba14adbf0d4ae11f3b5198f69ff9b8df449d03988e766b235e25ef23b281a00f025a092d66e7fdb1d2cff50d54f30a15775ab6116edaf2bc3c31bb216f06de1ba1c957cd15a24bc7d6aed3c573e2f0d2c4e6b5facb1c4e1f5c82720857591ded3c227c9d1367f837b679fffc88c2cb2beef0780f78859a0c40a47782a15e6135ac273d19608fbd3c474288730ec750282d33abc86b84d824bc23cfc1d99baa87f276b0b4ce6262c7f1a91360fa05198a8645fe4876f9cf53185638f6a56e9afcb704fe4becaa3fee2d899e792ccc393a7a6c6f54b6224b8032b0e45f4a367ca0228745201682dcb5822907bba2a78d23c6f15fb57d4b8b4fb4eecd75023e8f1106717156929e131557414261415e722b9cc7f71fc96d85423412d8b22bdf11d23dcf7ad1ab5f0a24c1faa6172384bb05b345cc25fb8b37c8f283b728b0d40bf298744b3daf1440f64c4f06a7ff6aa2d75baa0dfacc9b8c668b42d005a81494dc1b4474fb8c991750f669a74c690f0a8af980258f7dfb0aa4b9ccf727d0f104f0e99244cefae4764e62d3f6feb3f8b0179a2525d3d1bf20239893e0b67c28829d42ee21608e0bd01c1adb08f27c0303a1d632d4aa956499f0620b694e048e7860638f8e7fac2b0e97f1785800a9ebe6015df66d2d92baab31616ca56ecef011606803d95e464fc7f4f1b6b1834222026cbf9376ba6c95c5bf2e349b4b6c7dcfae9af1b3c90f69dad41bb6f531ef2fd979ae2fdeb10d4f759eed5a3d05fc5461f80559e971bed7c16a9a19dff3dfffafcf8714ba85de52e020fd4b1a3a526585f869080ae24bd7989eeab2f87b2678b081ffbbc3dcd6b7ed66cf84f704cbab3af280a843094a7c746651bc38d6b51f776fc8239fdc65e36610e2b200cfd4c3df9b77aeba3816cf82e34bc38aaa56662c2bf759a0911fbe9f867b9361be26fb1436b0e2cdac39440457fe54030e1ccf484285f74c600487ee6f4e3d368a6b0574c7c206a9a4dfe4f9fc2b5290f735519bb1a3b2167f71392cb47c0e8e67a082d9e725e717d060daef43f4c81a5f739b5582b3fbb08bf116c0203f54bd1908e40f5f257ed90f3668026b877f963c67bd3216d3e8ba61f3c1232e3ff83b3ac3b6dc761887d1f24348184b14ead1c5e1fa8e8e8d88c4470c36d428a69e81e3f1a076d48bf59a8b8c06d3a40eab52b03bf3fdfe17ae03fb92a8e6216337d836ea80840134ff38b396c5235efe3d3b89e5060ec4a152d41dae95d6589a4d63050d02af940a8364e8bda3508ecf0c3c2c03f305c67fa12de8f2727ca9566cc09ea5fc6119d7726c9ff218ec890383b4e22fe064827d17f11f1594e43064e2cb12d716fbaa6ffa12ca39607ae75a7566ebdf6f6b98ab6fad90ac57ab523ccfdc19ea0231e40c3c7b2aeec8778ae6c6d152d27246bc3b2daedbf051605ade1bd9184f087588148285d2d4b4e192519287de597582e5f71352826d78a473de12cc86e367146bae0a76df3dc8a9695bda5ceb508e5776a950b98dce40b1cc63a51a49465ee5a24969c767dbd02daa591b7feb5aaff5dd5730aedeb68bf8cee67e96646705e07a5c3ce38ce49541a8b8764e4851977e338377ea5550aca661d095cf318960e6f0096af2b4a0b100c9ba8bb8af91e92a56d74e658ec64a97cea2ffcec5fe28770b69de1d15693c3727b1dde76a9351e4d71a108059404fcfcab69c8187460ef4d123dd37026859646a431a2ddbc018640e5de265fb1bfc6d21580f620aa420909a814485ac2c9834c3286c1a94f04c5bee19f26d8ebc8d238cb26265c2ad10421b8c796cb2427ccd573acac043b2d7e5c22fa40a8535d81fe20cfb7a1524cba821598f45b5d074787213a3268d910094fe02de4b7d75d9fde9e6b742d8b28e2cc2688a28f721ec56c7020718ce9e4009e7cd5524bad4e21869a4102b57ec4bed800d68e40b4b8c7e2cef325f1fe8865afa42d84bbf6584007c22ab41e319a8b25d1fd0cc2f2b720e40e166c6bc4b82bfeb81c42ac674a3b9f708dbf399e96eae058931cce97006e03aba9737b2e0b6e85c14370ee0c39211c3ef5c7d4d17ea6b38fd4bdfd323ad861a40aff8cd1501242192a89331c8cbd708fc09307ab9b87cdf643690335c5ce124d2c4afefb2ee8b37aab8fe4a8f87825c5dd3f9a59dc0a1e67c781297e8d5f0161886eaefd7e34b144434de79986732480cdcd39c0842453f8cfc69620a54ff3b189e89e582c6e265237974616d16683ad617a295b13dc680e4967b693b3193eb198e94fd1c13104ba8a892d2980a2507804d8f1d6fb1603f7eb50695cde04dbee1a65665f129e6e6860998dfd4e855ace87a3e4f465fad8c8b3220425f257c27d09ec2f7054ecd954edd49f62b5e26d43edd5f2c9143a61ce68616f5ce7f69eb676c6516067f20d7d4b97417aa6335a7819573bc1a550acae29535f77a91a4c4fa82a5cd0f5df6fcbf11790e28efd94587837ca3de3690cbbf11e447591470a6f81c265604a1635bedfd0e5774c82fd086ae059449367065e19df1b5d6ed3582c323120e73d64bc69c1e6748779da8b57a732f88ebd1924fdab1b450dee80ba637a083ce74d7c446d9c141895b12d85a68d2170aa3fc040e281be43eae277a96546ffed23b47813383318f7a173148c6bc54da24c925809c8e4b5ba1248d609c02a8c5aec71970670e70889fd8af7d33de4a469063deae851aa01813a71b6201dfd277a1d2ef308802ec0366974013dfa7be4369f40e1050955939bac1ad5419358a806b79106e29976ff6ba96f61aaa292ceb146ff1c0da7cce06bd0732c9f1d722b92f06abe188610e3d7745357dbdc5fe4d5bce4dd622ea26175dc04b227a958e89e75baeaea7078b570c1720b32e165d7bf63e1baa84fd5dcd62290f963e83ec47be2e3fb1a13e9453e50257c2e2909157f77d04ce4e863328074cd1ac8ee08c1816ed930124a536140a4e5c7037fdc5e943d83a2c6445f53a17925e8616304ba28e112642b91bbeafd6674287dd0887dd751cc503d1eb889fe6c709513f4f8eb027084dc4d9f407c08087d21a6163ccc958bb8074458a27c79b598cd0bebdf71974b13a7e0adbd05b0155e9f883f9e540fc18541dbceb6e056af3d90aa8b4ce23cdc086b12ef97080fad6d11909e5e337f5f5ab0c0be5d6a2c10fda172c31cc373e654c22dbe9c9b1125a6560247791d99af2de306a741defd0cbcfdec32d33c9cb5643a4dfc874528f05325ba5f64f981ab2ff6f5acbb990743a0b2f33474a20189227ceae59b588dc62f9232b8180824b5c935c9174d6b8217dc9e25c15cd131ae6750ea4df9a4a5a3c102042c8dc74a6428ff7c527a7ee7521db8b48e9816fda4b51ffe6f25edb903e49af058d16a84b2d4964fb895b04cee49499f0098447b75f44bcad5551d563339cbac3976964bf4d283392c4aa5967e045b7f32612228307bdbc96d05dca209e43ece39932f57dbe85fd58957f2deb5880659f853aad6cf19d9d2159cc3518c4be514c7469b11158bc89f46a763322b27a2cf25a783de4ed40f6700b228e7d6cf7d25a3353560c9c4aa2a20cc3bc55e9889c67d73cf8c3b68686406a1db92cf8ef5a504a6eb45b094b3d3d0544192c2858123db5ac4e680fdc86f9dc98890778c1c75a1526de985e25a01141c3a6395d23794d9a03d292f294463cd02fcb1147c41a48cfc3aa172eb40bbaf04de3c1bf8fd580f99f3337acaf5049772e1723ebdb5a3a09f3120555b924bc79","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
