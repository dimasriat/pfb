<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e4862c525f9537d33962d1ef0ffa7d3081ec976f12f8006b7ab38d2799f73854d910a96f6978164057110464854bf5ad949db380d188b6858392e7145b61ffb1f8b9ff39765f7ea8395cc30043593ecd66af1010b89e7280691e61b344640270c56e7423dea163815258d73676aa9a2907573eaebbb3bf847b357c0c4e9645b9442ffd4b61219a9eecc81f6aadf86e4e23e22e2dd9d9c1b081b2c9f88357c7107bba5b24708dd94b35529181f51777f1cc19bf67f4ea38de2c4e24537128688432c0fff7114e9b2be6e094e5c9b94ed0293d1a0861854b7c5e2f6a362047593fb34682be13be8d36d093787e572ca7d6adce2b0449e20aa06aabec93e1b2c8d2ce983916de771f58813f74fe4bc3354a0402f2f4673014210384f3344c91d132e09382c86f2971176c34c7723488da8133defdb6f3afe9361c8d2505401fd0e8d1c5129b693d196144484a44323a27da2c4c575b05f8d7dd1865220b01c4c916f7189baf0ab3ee6730bb1c77785002b9207bbe9740fa8e353f7c79ca10688febd54fbed6346cff44e47588a76af42111a1e4a71d5eb50bd3e6fcca2af818fcbf05c048a9dfa50ac6f423f89d860819de9f416aa3eae7c1d122e8194f44d9eed367a408a0ea96edc62a5c1272f18c83c0418193ca1cfa77e919a1cff384d838788f7414e3b59bbf13bb52e6b7828e5e1bfdcf7a70b5093c693e8f827c3dd9d1acadafa40f29a85d2613afa0c7f10cb19e1fa4421666221a689210fd71de500e2bcc814766668243def10503e49d36ccaf85947e8e93a14d3fda8dee98b9630e7c64c51bc851a378f7d824dcaf2c1645ec20e25eba3e3f6e54dc3ca3da51cfdacbdbd0831197d86184bc700b914b56865c5523fd0dfef660380ff99c20f760558d411f913e333020a84fa42496e702b7084b9898956a0d888e42eef31ae3d83c8153d90bc48c4d53b62b762fbd36a2e64229fc747e573166fa7894e2a9573972bbfa5fcac45cb33ae104dbfeab00eb66860f2555d44fb64beaf5a4cfc15397bdc48ff6158512bcf426f9909e9e0a0c2ad1bb592ecd6ef699cb218214b13f868b9df2ffae3ef4b19f941e77da4c6e77a273414854a09329f3915d483cafe2ab8564822458e330dfadd9b7738b1505411f2d5f48ac3bcbdd0b4298b57a8d18b21dc66c783fc9979b5b9f53e9d7b8b3e60f24d303eff95c2ab78c5fe86633b0ae044646c413eed6125ce781b526c7f5f375b15bef608d4527b773e8baece24b8e43902316467e18d7a440cb6003fb83eb00fa6190ca23bc571a9365e664a4acd018aea07431a98d76a2951bfd09d73e26f6625161f940af0cbd54aa63f2300bf3d682715c6148484c76559f03b715b8835f140d46e999289dcf3cb8150f560fe358d2573ebd98d5b1aead1703787b0ddcdca0fa58c8580fcdcbc4db83ea05d93f1ed7e3359a437d7511378f294c976574473a3c91e58ff8342794d4a48e27b9254ab341a561bfd4cb95e6a174d3b5c05e45376556be3f197b0c9c7607508b77bb65e328dee27233a75867143b0b284fdbbeaa56e87f54e8ed18ef826a5b977d0961334f4b280a017fae4a59e5ac71eeb23aed06bff84e1dcb5eb9fb26fb0bf084f1ebf212831094816a2b0b4835f034c5af5d5bb80758557b5c7ebef5b00f112632fd1cb8ec767eaa39956be6f6c5b98d1f7be47592b5de4e84ca32ad2a7dfd732ea4e58c3a5e69f887c91ddf886a9e4854a95649a2fb786cb8ddaf6958309c9de1d243493bb0eb77f1910bb0e8120c18cc1062fb965182b615d267bdb610468117d3b634f9ff2d02c345f2ecdd1b2ad92cf6b290618469a7ce9e65eb6539fc8ea574f8a509a4e62f5997028943ea06a61772cfd9a83861739c6d39591bb4ea826243b2018d5a2269d20d06f0703e30d4901695cabe55325c19335049f68ab2858574cc6462392a09fdf08cb9682e4aaf6e62540d25c23e6257341ff7f2c301b3f280a404f118c9380df033fc86071f0c69120fb0ff449aee7a0569d6f0339b01b9db43317b3dd00a6c8f0c5cf94e2aafcfce0c53a6ec566161e965c67187d6889351c873ef0c438380e4e9dfe768aa55f88d070a2498934a3281e8f900b88fd90a4e2f23114b01f472207f58b5b90f09c6844972734c08cebb70f3a0d346fb11b1083e45cee7a21c5a744d9f327672c7f24b8b609edc80bf104008bcfa5a7697e8276a1fb2604bed5a4e5573eec9df87b8f28261f54f715a398fc196f2d0ccc6ef07514c86071f476e1afca5a2dd74f5c1bdecb5143ee168c7ebcc6375209ccea426d870e6c4ad6895ea550f570fc6b782653fec22e13619df6231bcdf767ab2214352446735a77e239573c4490fb199155425184fb79f6fe835c178e7d05b5548c84658fa3c747fe2ff245e82c1bda29960ed46654fd48b38eef8dd9e6bfd39235db0ed9364446412258825af04f64bd299cef1a16fd87d86e194a44074029ba42afe5d4a2522863b986b8af01b8d332c270ef3813a4f8e8f4a239a8c007944e9ddbabddab1404d3a68926f69de700c7bd6a5ddadcc2be159dcf4a70abc8787bf3a426c0d32722d454ef87dd955724a6ef11140a7488ddf780e89fae4de886cbd8c0555cc8b0434da3c284bbc2de1fb7f7725d9ebe90aa67305f88b59d5cb430c1bfabf816f22330e724a776cd3c21e7afaf70ae38d1825e99debc1b10505a0778b6e82398d2589d9e626408ba83c0a5c1bdc56fdb05f91449e09548721533281813a005e1c52babd8c4be4340629d48c107fa82a813b3605ee3539e167b3f128b92e606872d978923e17a6ec862817f63fd890e7853e57645286d91f3635514d6e8f46f3a23736d286264eaa9f5a89f6fbd6535d07c59213499dddb3155e12526f2e73fa0f1f3f5423402ae37b99090ebd1d8a3d9d9a629a036167db5debd7568cf86caf2d7119b482f6f81fb64d9189872610f611f9419148b42777915f7f667e49b447301c1812d0899a570914f17bf3effb5778b4f1d5493201dbed4415ab2425da241cab872e0edd6a637aaa760505b217fb0947abf235157634f1c78c7e7d9fa683724490690cb5e4ea1624b02a41e79d76c69196baa255e51a9d9a3a2d185e42e360e8cabfb53df4f88ef74e487922a7d42942cf113ba657cb94c4d98f9ae021d3605984869d8e66c024a0823fd3f1b3cc0d3d6d6f8d4944291eb152e60eddfa0836f93de1379e4cec7103698fa7f523cf7b667ac97fe2bcc8e1be23f198eb6a190d5e5eabe91d1ce054766cf3d302dc319cfad5f29c44560ea54afbb5a10a19d4bcac8483ab60f8802dd47d7a56cc596f8cf398cd324f8bdd6b2a83205e16643651eb02e664053423f3cabb8d59e37dce443e84d4bd0a3d1e65e13a06648a91f5ec132a68ef84cb09c59b09ecffe0c59d9eb90549afde50c40777be05c9574fd561fbbf737af5099683f4a1feee06f23b5786e5084528d9e7fe84050a913730ecbdb9d215b11cf8a15395c6b9a10a833291d3fee188f8ad781bb9b95216f096f443b6bb3cd05002cc5a327a1cd5e43b3f3a35170eeee3ddcfed3d063fb562977ca7ef962cd22c1498914e993a198ee7f1ef1c6ffaad9525a18757637edc3ad54728f692d7f05656f913bf22e3603bf3174025efc90cd2c7091190c81bcb3a0bf9d28db17dd650dba8a0e6d584e748d53d9713d6d62b1f7d37654d8950a8acac2b034c74ed528f9c623784e4d2c6839ea0f1562545c7b2585bbdf623bda4670b400be28131a065b5ce7259798d5e5f667548b87d95e3c8f60bbf80ceba81be73d91bbbb8784d3e8cfec07f0598227c45f8f396cccc041964c277bdb5d05df19e35a4604c83aed64a9d64577fca8cfa527ebe633c2292d6da405f6a197c94e6ef456f1b37145ce2df06bd38dcdd198131d98f8ef0d67b7c6a41eac9172d261599c7a470b91896c3dc2c98cabbd1dc7ea44ce04ab0502000f535d2d978003328976e5f49fc699743fc60d0fe4ae0cb42c395b827eeade6dcd867bddb5861de9d6e908f18d937f8a540f08f844a88b1d79b83a069e970484f08932b1f00dbe69333f912e1fb7fb5fc863473ca8fb3186d5f41b2fb973eda782dae326a57d8fc40f0e03112483d9e49a2194ae9e2114134571701c623ce3f8ecf454480141ef2412fef03d8f062cf97d30e22a6be76a2d396a7d835897477ce4d7403b1d8c34b4411db4fb908f9e4b884ebf198f7832fc339898b03764be4f68ef8a0d8324bdcf992abab9dffe5102ece057630bff2432015e2449fbe4e569293f587dfefb1db9d5d2a0a4176da85c4bc81d27b1336fbf575e26255b42b9160f46b67afd6eaea54c493446a4cc155ebd4cb3509a01a3180966a11e909edc1c52ffe1ad4bc18025db270f3028d56874e2922c4d4946e8e8ba17aa495af8f63966294670f3281516e7c3657aa46a01e48f7e2f5d7ba2931f3d04676920d04fcc1c81d03441757efcbe9963ddc007b54e724e7e11dd12af94fae8216905aa9c066c874f4335f5039705e2984877e380b1a04b1b2f4011bd45b3c961a38161f7ed823cbaf060a3db47f35fde3fae8ab64705fadbf5fa884f8de1b2b54e6f4b08baba8f1268504f2a1887de9e3eec256d2f5aa7d26187177741ee4647bb0f210ac8d283826016b8d9845049b964bae1a29ea9d51f1c6cee2856276e5b32190655157b6615023c700847e09919eb968062b884edf6ef149256d0b8517eabcb0e59187fc747fedfbaac2cc9dffc7218bc356fdbf76e594624026bf73a83ff6f6be5f10abf0bb5413ab5ca6e5c5dc22301b65e242363d9b2da1e555306b8bcaff15cc2db756b93c44d28c979d271fd3ea077127fbfaaf774f8f8ac0035e812fe9acef74e725b82f09004e65a3049302a12b8d0bb60ae51661614e1a318281e8a165bb1e95fdbfdfbb85609f1adc6502269da9e468ee63e54160861d33562559775dcd5a69995d928fae9f77ffb945309cc968f2c3a09139ffd857f3cc449a1fa283c1657c0620ac09bb46f501fd955b7519ec289f40af0497887629cffc4c0898e712bb34f9f85b0eb2e5de55b768b76bef725138d6c7dce0b420f9fa8a9a940b2a0aff7d36674934f40c646e9bc078ba46a5f77006d47bd7f3eeeb6cdead29f23b44b13be7409db396189221ce4eb4b61d085bb983057d231feaeafc43d218a06b7115c6556125d4b4750caa10522aa261c838f6e57181d2f36448274c1382d40a03a8b792769cf2a55bd967f0cdb7439fd8c4518c4213f7903e5198e6472bf20178e80d26a4e6a7608720227266326fe70a4660195aac6bd92e599a30a3d003a3b0e6deabeb208b4ab2e84d8430a46a7041630204a73ac8f5bbc3e61f9685194ba415dc0fe7ed9b0dbf0220bfec16f41ca8e67f2648edf36e93b082f042da4bf3e3c6cbd6f7825fbc4de7455402e26c3c8edbb0330e81070fb49f436f9352f2a6baddb14979cc9cd08255d78cbd585a49638be39996bf5dedef34f91a5d2789c46df308e482abe0380bc81777eb89d1c7b4330c6370b0c22ad9645139d18cf011d0f368e9e2e1f18d3b3fe925bee6e74a344cc059ac6a9a1c02eace3cfc10d44eda71bdfef8025191d7c1071d7ab40e6b544d2349be88085cba14aa6d778ea823b55d2725a98253762227b55272311b6f34dbe734e37b4b4117cb4ca7efc3f4a43bbe6a1d531277fe77c0eb683adc12e3f5a7b02fb10156e68c7400ef3222e5ff097976f3976adc9799e36c5fe431ad30d957e0477e86fa58787cf67880d285934665432a5d88955380a7b4fccbf90f2868e163b6238738c017a14e41e6f08f326b64d159da5433196f1e1134802e77abdd7ecf1e97c5879bed2aa770736782e63912e61d10b50536d7fb077836bdc8edd1e9555538532f81c16d135904c552fab0c4f50cc128152004e5e9e5d727f3b8840f72ccc26ae11d76ffba2715a0ec8550b298e4f1dfc472341b5071172cead9d14d3201929448a2b80bbbe3a6efac9787deed36d092518099a44338ae15681ce991e49cb46aad510de487439a28fecf694dabbfef134534174a512727ac193fc577ea5d38ff78c71c701b92509a69470a6f2fab700dd54b4b338cc35fcff074144a11485dd9b71800f7273aadacc9700c051a49922eb3cd5bce5876c4d2fff3c603b3cc2428911a634996654f987f5a38c3eab327dea68892b4338926fb132f13b3bce81e02f6e2044aa13d25ca205175448aa4905f34418f4e79ebe5d24e105fa77b8c2591798ed2f2bf207c7bb0060912952aa72367426eef96e63a5933592f7b7d40427a21a5d6546e63d4d7f04b4fb7f31ae608dc0287c541116753096694c99261b54b2e0ee118dacf279397a5589914e173a0e09fa9b2b567de109c0f3e1d5fc31f51a5e26e76fdc478382487a74885f635bbd81819b7083ecc30f4dcc7157be7fce66874e8f55dd797780bbe368fe71b4252c66943a5c44b96afaf7b2bcb7d4320ea6078fee7210fa8f926a0687ab8e211e8682dcaf9bb7059aaf6687716068654e6ee01832e7ef78fc21faa65764607d8ec76a207ee51012ec174eb6cf792e1a52548f4d1f9e60c69522026ae1b4fb9098289879b8d80e89716d105ba0a459c15d28874120d57f243b84f90512b52da7994090728703a6d22c4d4eed6c661b022bb02bb6ecfc96f91b20021e25f70a72a92f2b0e072dcf88921f3c5247798cc28d68bacd67bd4bcc4e7e7a48f00fcfc32e3dbcfe198be0b161b5d63ee6915b0ac0cc062bfcb523d106a5f0abcd67e7a5107f7a5922b51801e83072e5775e704872a7201be49f68f4ec8b25be04ce61241d7d270727d95fd079b93eeee648c79a4c8db6746f160ffbca501e43a4ded26dbe9e01e3b739f277d96bda43a27ad6fe4bbf7298d8055e632751cddea3e2834d27568d4e03fec6fd1a4f19e0eaae0f7c746d7d81da5efde2b01a3806db8dc1db6ea708ebabd91f476ebeec5e79643e1c97531e384cc6fbd35934360f2f3edf990b24e02ab1490792bec8af77f311876a51ece6f30a818bad9539cc9c3c4c1feea256e240649e416ac215ab4e0757aee837b3c14a01afd88a8ce683c7a5571b40ae1d8f5e10d638739b3bc3233cfeadd389c0384e0a0ded225342ec3304698272bd03afe1b37ab866caa4389844f839220693a841ad7baf99c5b3a6bef9e021246384406a54a3f1a76c7b263136b4e784a974e9f4d04f63b4542cc9b0322f6ccdef64228be564a834777d8d7cdc665f85aa0727e539c2aaeed6390e615a54c93340175362fa02c583388297a6cbbab9c7e75eb452915fd31d6d9f90d1f39aacd6bbb6817401f350681cb553af6672e497b3f4db1e9079a5864245a42f838734e6687ee5ccac7953f4fcbf6e26292d5c9f07fb1a822c27e77d8b3683a21b2ee57a59e865c03f7f44db4b83c8ab2b41bef5052720a70e2dc408cec728de0d4589a736e1ea1e8433fa0abc625b3254825255cdacc5b1fe269e4c18a07e9c23b36bedea709f71460ab872acd462e7ed0ea16e38a2a140b30ef8482e27e7fb76217f17d9e59f340ccb40c53e8916a7242e972fed7092e968cccb5a98c2e12abcaf6cb3fd488b780a7f1b14d7d345eba4c74504cebac4408f8873b85d13b27973d2f2e8d73e7abcdea1f11cf51bb6fd10a3d9bf76fe494c4f1c2b4d74f2d6071aec7a73f9bfe6c0fc35379281a417fd7304238ebcb40e9eef64a0bd8d5b15817b6beaf74a9b5b469060af7ef7967789f2e630e0a38b656920c84e9e5227841dc355a0cc9b404f02206084b76222005a6b87542b262fcd16ab237b9acf21c5e74991beed3eb5ffec98faab0c540653fedce2a0a564674741651281084fca7d553fab575965771b88e44f9a0d3d051865aa4cab7c5fbf2b712ea1fc34557ddbdd3bcc99f38b8e36db9e39a320e0a7fe044114ab1fbbcdc163ea2db514690f68398a977022867fe3bf341313841e2519c63509d97012ed55afe910dc5191cbbae3db86acfe6c4965f94aff3994b7de5e3cbed08335f63a3b91ce8164542f0a31bbcdaf5db30ee815ae8cfd3aada2a0c88b2948ef0907c3fefbc8a9501af36cf55434cb7500d87d5a848acb55fbefc2ad303cf5c32be9a49a346c89bbc18ad679b14dc00d6565be52b351a35dd597184b1a95820fe74c4bc615548a62c317c86d33cbce71d40869b908b9ab3589875260a0adec0544181804a9c1bcea35a8a5c4fe2fc0604a670f2cb4142217f84e234880c77773f5c55363360ba7b8f4c7f1593bd95b326a009f806bcbbfc30de5f79c75d8de6ff58a63ff59a0af63353df86714a9b134f2968024cc05283651e7fca06a9cfb777daa22fcdd7b25068a1ab6350c285ca771f5b1e3b06b8e12bec97b5b46d7303f2ca8aa46a8ce8b2da857ceeeccbfbcc97fb950dfd192cd794036cbf0de1631f94f5280e5d41b5f12f5e1180eb2e8104ca29bf04f214866a4499759bac83a3a4c34c6a7db127f4229300924b246891d281eaae2502bb8cf1bec35172030013bdb53b6e8bf83d4ceeaf8374a1b2c23730c4e7ba4ed9c53777ad507966fbbbbc41a6dd01b7959b843fc5ef8d57b8f03beb7c3f24c23d5d7b512670159117bfc3552eaacf8687a807b32b29c5df3b92be5ec5e8d6a9648ba4ba666bbb3dc8305091d9607c6aab252ee8045525a5ef0bcbe3ef46fbecc0b426897b08e642f98a8a5e9f58d7e4e1a7f2b85d5f1644a3d2bf9c7f8358543f483477947a1c8610cb595f9eea7b22a9b34d6884270b99dda92b9aad1f4e030ecdeedd80b154c04a136ea41a2e8a5c221c2fb00e8d5053b53fc1847a66972f8b5e8fdf0a017f2970184e5951e6d80aebf4384ba1b2a38411a0fe599de15ad8a1e6a3ff173be67cf8a258b0ee219837a04365a3ba78cc3604f6596b906d10e703d0de00b1f9f319d2cd81338782060b7aa09d67f891099155c17a8d34ab5fe78136b8f0368f7bd85c8c6435bf82eb7e8efec61051fe03d0c1987e98649515984e83ee70a74c4219bc6199a48c8c741135d11e6a105ffea901c9df767e98e78c8f2be24c78b6c089369e5f25a80665b87e311d2eea9857848602dcf13fe882cef58d89824e85c3e484be4cbf35359561b66cc785a271b877cbd9e8449f7437f2ca12eeca2505bac1372141e171de951ac3906262cc9093ec61d27331af86176649e6f31bbe9029b7585dfdfb87810420713985e594dfad4bcea3ddd2e207f90ad787c7404ba978edfdfcfa2bfdffd423885642cfa3376847eee5526763cc7cdf67b28ce54ce49c90bfed1da788aa0fb156753bb5118035a2ffb4f2a32caf13b16746126e1fa45b2d1109691979881b26deb46775080fea0b4d5fd3fac088540206bed55fb1228608e1f843c39a8c4ecaa5993b0f11afd1369baa199ce5b7ead4ec92fb01cc126656f82297621580440a3852e90d62724281386e2e6258233a88e1b097abf98c9a137dee5f120889575b4bdbf40a45f4193d6c916a5baaa7fe129a04555273eb88ea1f07ec81594a3d0818a023275cdd628fafe349e843f447df5f230a238927b66a22f4ff782d1c21ab362905a5b0487f670f24e3f3a0d0a8ece89898352ac578b8b3859d7b45fca30a9651267d3355f7e3bbc95d03cd3bedec2d5ed9d723fe1c42a0e4a004e9fce372cafffca1c10ca0d1a6e8ea098c788eb43117297b4e23d9f4005fbcaa4a9c7c9607c931fea44b0379cba4e98b4233c9a86fc8c323ea274adba2226776b156cfdb51c3cb92dcb531b8e26d19a470ba338570406ff135ad3680c93bf6dd04bb496648625828fb6411ba71067c2896a2176f5e4b84b3756ca5a84e00fee567a73304bd3c713bbd3afa98b43ac5e66b32fda14d2e0e5e43d734281364bb6a806e1a29633000d6ebddf17512ca6ea7d04a816c132eda3a845d2abe438e4dff21cf5d0d13654efcf9c2496e96dec46df6f8f63b42f20620c22aeded578f4aab1b20862c44e9071b58cedc58ec460cd38a3000b462febb846e3f695227632fafccbc051def09169105d9e3d8c428e3eac1561e76929182d9576f06e6a662f37de3a5df72c7a84b0649c8a51741cf7fea43f625d3b852b438a345dd798b51cd20886b3e512f2bb354b0eef7015f3bf0c862ba6681bbb2294ad36bb9c2cd6eeccec268d3c18827f21ec2d956e5f9eeb9edf5ba67f88e7a90149026181dea80dd1643c3e5ebb71ed3d5b6d368739739cad257657103f0de91aef29951c0f87b8fe4d26fb32e0c5ca0d0886ce9b78c8746806d7a7e9dad328d81b8c9b0f6542ce8fa2131215610426dcb2d77d94e8063342002ba78413e4f9e6e39f1c4e53686f267cc55f6b714ff426b4bf2c1fca49f33a9375b0dad3eaa95e858ceea6fcedfcca8604d70433d3b93414a00909b62477790e4c4be0780d16b903045522df082049144692823027e79266a59afdfe785b59a8ede0704db9e8f499ab22273055e04c0ea744310f8f852d7b3cb3cb1afd7fb89a0079e206f6d532ff55c3b9536c4095cc8ec27faaa0fa2ff8a8b5cc17f98725660c3b3f7497e84d158e0d6627cbbfa2e1452e87563541a9b1a2405287c026f021fe692ffe0d90a6fe44a9d936f72e003a2c15042e6eb3c7f7ff29aae8ba9968dc5a90dad4cb983c6d8c664d2a6bf40b6e4fe9f522d7f04e3356fc509ad1a1d4614d69373a5e4d2e5c7ba1b1fa833181f5d30009e6107816d986f869c3337243fa2459a3d7d26f5475480cdd4830e72a81158adf45bc7ec37b4e66e20ab09752630d35b02a9454d51cd7ec54c853a335b44b4eca9249481c55e824fe741ba00f6140048a59c37175a55312bb8670ce232a9bfd1f8d485b1cffcd57a5e717d8fd5720e440fc184cdefd6793238f0239ac457bdcbff12ea70d31c4f497a84d45bf6c2daa2512be9366fd610d197bff0286715d51357a4c57992755d3d8cc45ad8f1373ce10eeb27932dccb246d66b2147c36d0c4674e2095ca17f48df1c0ecaae0cf9a82d426ad7f1c63cf2c690136ca0d932c7dd4c380d671b0c008aae73cf8009eb63f3ea5bc9013c2f2c815426c89d3a986e1da595dfac13d87af6e2999ec06251a7f9c1642c18410c4db66140809b84924a9386c4d07ff4a6dfc17e40e76c4859d74187660c3cdfd9e44bc29361f4511a5ba4e28d3b757022971c6ad4448d7a14c6c1e0d9d3dfb49bbe0cb9a3e4adbe27ff5b1de2540889c9713eba742d33f1abc93dab377c6e38c8c9dfbae5324b58e9521e40430b809ee939c6c19c57f128c997e4f75b0e038b50269d936e28c37ca6299a767ffc3d8fbc019eb15fd466084d86a883f9c172e5852ddb615bbb43255700ccd44e1af6a06df91c257c997f3ca3c115a51ca5afcf56ec40b2a03e96382e1b2583f1835d1ff18d8ecdb12d15975d506e430fd69bd4c5632117cd3de98177fdcd6747b247a5523871a1701f1727b1009f4fc40f9aa8f8d73dcc6b721e251e3ed5cd25efcbb998cfcf39aa963e6080b11f9bdece5e5d3a5d4e3627665dbc749c6bd08a44840dd39475174b4a7bb2bdde7f17fa2adcdc26c933c41e7c74b0542f922c5432291384e13a008caa175e2b868b7bb93708c817543c40247c48165b1db457ffc2af33417d341c1ff2941c2cb09ae784abc242934762b40da255916b5161825a86b1af232452fff0aa2f4331df8ae480d979795b22be053a43f39a508bfe0743163a34721002f1dffd898ba11eaa801c9c1df884f3cdab7322c0ec8d209fc6631bbc78f81a6e1e497afb0c65b33fa954b92706bd583fd2857e8e7eb8cce0ec06e423b58f0e550af09422e5d8d192ea8f5e59af0446345e6a301455e6cd52d644ebffdf68eb2535d8629c7b7fb45bac81ed130da2cc3dabd7babe4f0c0ad7c3c25c7e0788e24be1e79ece6530060d65cce9d7079f4f6194327987bd94366435d0ff28ef791279d38437a6fb49adcc8e9f25e263e7eefbdff739e217af18b23ab030284065fd32ae9879eaaab315c4562733242bd601943f3397d8d440b1701b64a3577edcd37a845b726f51ebc9ebebe56012c37f9ac4f7833ac84d4c43d3bfb7851a596e4169538e23f1a06a5af5f64b28ee768e042a39701aa630ab943dc74d8a526f712b1a2390bc4d272166857a6034bd6c31d1f190272603d227a531e3ffe6077dabf9b8e8485b4c8949a77598dcc88e473ba174d9b63862e1b25995411325a874a2cda7eab759511b73f83582de9098877520eff77d1b8f8375c4ae11545476c399c9949adc1c57e313e2f9bd7e2ebcff87ddeee5e76473f32a46e89cd95b0c24bd6ee94af22f8a64e74d5e38eeb323f4a66bc6818fb82c9f43312fc02de7f79c0dec3cd92cd7a801a09cead415bcb419e659c39dfbe1612dfcd79bf4f49b6d2e3edb3e8643cf0e808a3f0b9a0574a41431f206544b431c7d82eea189ef522b147c36a2f2a7a6e844fbca65ec386c954e0b18dd724a2413d9d4d770bd899195d7a7f8272308df150625d2de04c8ba99bca3aebad49e524d02e8424441e4f711ab984588348f4f2d169ef8a08067303a40a99e0f7b3d1d5402eb3f3184e49029638b82e25bef57c9d55bfaffd86f94e206160db108d4a15f875abc9149c7e4f088e7e1557da7d22f108477a76d83ba948723af211ae41f43568e4166a12701bebe9dbffd61735312a1f9dc3439dc4ac1d42ecdc91a2bd78ef51abb8e8a69ee9f74065e4c79f759eac394c29ca14a98037accd2005130dc0ffb5bbdb8cd3dc6ea6d4fb0fdd5a99c90f4bca49695a190f6bccd08f211bd2d9b68aa045d28729666838f32b99daad033b85b8fea2581e3e02e5e7d8ea16011d303a54e8477f180e94cc8673652a5addeadbd10dafaabeb99c7bd9ada4aeed0891985310baf394c4fd97a4058583599aa5c79932f13cbc74b61a52f7f0d66f83afb5243d9cb5d7f1bdd971e63739aba4c0a17fb60e17f1aafaf2e80819631645b817c5955936963","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
