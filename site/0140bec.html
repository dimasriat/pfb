<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"df8c2aebed4f872b0805aa8d28aece08d27ee0a12e1dcbf9a59df8b9541fb16d871843948fa02654f309e2ac75b2f8fe7f95efdeda199190140f5a6e7021d523671770c4138ea8fd52141c4eddaf704d31782a58f80c5af5d5f4bc7796c1827e9ca752619afba39472d1b29830b45217d4dfd9ec5275ea5a6fcae3e28be1ecab118dfd773a33961b41daf4c5014ff7fd9d23a1e9ca02ace9154fcb97b10b7c34293a41325956bcf4a16d168255bab40d6c4885186de44efc2db0b4f683cced7d3bfd64447b918a10d4fe7366cd020cdba3c5d2a6c86a69450f8acad89fa730a41d217e116f0d9ff66c0f2a33f87ffe2063aadf3813a261f5dd3fdf329fb9c9ca05e24ab9412bc9f28d6ed83e9120189fb72ac1c3a83a151289fb8671da1648bfaa9ab1b00fc873696011906bb69fc9284692259ee6821ce7fc8016170e7f412eed3fecdce79d0ac7072ab396aab25032875244a73174eb3bb9d7a3649cd8a9acc2a7aeda3d40ee3b2862ef04c68160046cbbdc3b7a84fe5ab65280478130ebc9a8480876f9cc1f1d48ad05ebd94b3e786d1a47be886e72f54891d4982b6749356ebfa613aa2e6fa49a12dc9e1d6491e10d7bc33fed4ae69790cd22fc63fa184f810fc5ce47c63f20deb41bfe351c991e8b2f04647428819efca38ae7758b6dac42fd10c7c231c4eb9e55dd806912f1f305f4a8917a5220084c171c0bb757e38d96928d55c0300e2852beebc7b103f5940ea459dba389d3203f921ac92ab7b0be9f3ef313ccc0c1bd62e9ae20749d3be8ab6e00ca698e91b547c7c6271121add2751d8f7e941928b70cc9912712ec84503a88bcc9806d5cbed9ca104050dfc0a06c098937e6142d840aa32ebcbe682902036be0f0b48ddbda20a6cb7a6da2f7118634681e1070b8da1987a5e255bd733d8949fc791cd36c8ef6b9217cd42f0907e54b3ef9724ab358b49cf2840d814372c3ce6c20163c938883fd4a97c4a456210799c57c814f0afcc495b88ea072beb9846408f429bbbeb635951d2507ce1a57cb808d526d1d130956996ff2e5659f44614ca78fc6c04c543046037c9b159af6daf9de977438e5d6a639caec6a90f880b041db27fb7bed3ea14115bf234e0a3e96b6b83b00b3d87bec4640a2bf162ae78f31b79e431da54b032bd7a5189140e8fc743b66549a532a4741dbf719e107b27087124eacfd31959c6a27dece412b13a7eb8da0d2904932432a5a9a8f9a09cea105c1f48947bb7c953cc58a7683cc3089d9e1822587feb27eb4ea0b0bd13ce368f93d6db97ea54bda790c25233ff9001bc7b6043c4b19ece5a3d9fa6f80f63d8407f9718cd0e32dff7172811ab54bf2cabe3f8b0611a7f8668a1e09f4afd701298e8c2461d4acb7f08dc9882e3cb5280685aff546493b291e30798367db81e8a78c81718a01d31ca5f2b926239fb78a21c96d2ff9c9e36454fdcf9774de2ceea778d427c2ac0624f214a7e07433cdfe56b21f62e768197de378f8627b5a3910c58e617f2514fdd802e3a98e09f7ec2f719f6d4d14fec2470eb4528f8be7beaf7e448f18f0f17f31de4ce2b8e49b0bf0faef32712dddb802f0f207b841d4533fd902c748993c0033eadf653f5754866917ffd36b14183fb8f7c3fe2d5dde78d2bfa17aa7e68aa9b37a5504462244cb2f4004e053b9138b00f07cd1da3e5f6438f3b07c56c38233b764e8a02013293232be7b834b8217065eb15756fcc579a3cb5382d9d288f5c7496a63abba79707b8f7be64aa26d82bea9e513402d6036248dd98961530cb56ac184b00b6e21501d732f527f4eb02d1af86adbfb6eadb2de97bc48c49e9ad480adc7bdaffb3b7990878e35a38bb5eb30488a9f4e9015ff273c7d0af62ee6d2d311332c5c3303a275dd1994a6258c80186562b80810e09e407b25bc475c692e98e351469598fc709d01af4d4bea7dc8d6c9dff807e5f43f34c3c07b00b9a87e14731a765a884a813a2e4a904cbe662dd0a17db71221a303309c6505a26b26f93aeb4c891acbde73a3c35e1d251b9205ba3dd20621914d089f878d83c1758504cef622134af60441b76c58daa412a4dd4cabe8df296b1532a655888e09b1cd0160c2fee76bbe17244b8f1dd9a212dd42b155780d6c408cb2fecba7fa295d4098cb419b63a01523f5b92301c15b8485d6938e3c868e88fb6c4a038059e3ee798b9e4369c3b781ecfe59a912ac9485c33df8cd4250e35a848ef581242c737a51bf2674f7eca05b578e1b33a98d0c0f4daaa93798684647353aadb8029fdadcb9516e5bcb2c96d131f04858933e717bbf013278e2805ebdee38c11582ff39639ac78ed88a74542f05664b508c9bf71d341c124261028619dd2a45b7fc5c8103159d7eb356fe3dbff2225ee71d09d55f80727ea5f57997f9edab7110eac17c38fe4941f599066e01c8afc71be9822ea45880c280318b9ea5fb560a82e8b6e04c6860c1a8b374ad0579de8eb229826879b86735d255b1079ee531c489befffb4b9df52c5b8d7657c96aab97f47f83933fd90c73881d663c859214d5cdbfbe438010188e8087ba00974fecc6e9b8f6263420378946947d71cb677b393f14e572e2cead7b981999157d19bb69fc013e92fd0ea6e06e1b118b3a0f5db0be50cbf3cb3378ff4dcc0d64d0a11e3c61e37b90f9cc7d9d59b83cbe08478023ba672b2e2194cf98fc83e07aef5c1f37258f831452f2926b12859b8fff70fc41de28d67b5201061ed3528d79fe7ffcbbdc40b78d4a1c3325bd4c7dc6d1c62dc11308274879a706c50c618248f5ee713b7f9c91900e7ba08e95792ebdaff635d2b3911c96a28c05b81480e47ea3176a17cdc06befd3775efe85fb18fca02c16e0a67cebdcf86d23e6a463d75fe0cdb87c5484ae768fdd2ab7b98ebd186aef1d4a93159289fd2d1da1bfc0f0faaa5e10a9d24f84e5da0d5ad9619f7373c75384ce514b2f5abce3e74832c38f9e6910ff60ea425b1ee603a79049f86c65654196505ae3c60c9e2e693f729dad7710345e42eb65ceffbb86fac380a09ff9dc49532ce0c557061cd384d570277ae98bd41e198e60b8356d7a05ce9e2f6d1501831fa5966d47e3640578aac8a590b27433ba52f3a99dd352393d5db83782123c18d91a5dc0dd6e6c38d9b038b9384b43e8553321198d9dfa4045959d31471d82487267370f006f482434338fdef9fb15dfa8cea724ab6abbfa0bc95312d0ad322721fc552ab6c35db50166fdf5fdd754d37bf76cc8f41d813da541d0bf68dbb9de9018c5e5013f5b2f25f3c201a19936bd70b7ca6cebf35282e915b723fd7b246ec5e615d82467cfc8f20f4e193997c3e08218433b711e06f4ec90d9d0fa28e4d4b06167736d4ca19fb4ec1aed2ba0d1d523e01c5a2e5babcbcb5af3c1a34231d6c77e02ecf3d77e2700a756268e1ed767556b80f5213b52071a2805fde08d6cfaf104207e4af3c4ae3be2f6f988836914a3dcb7b05bd3ac9f2bae6fa87695863aee168cd6838ba284af31c9338e4785bcbe750863f6a20704a86299e9e58146097511acc0428e28c4d320eb1eabe5e0e76e37128bad07ba2f76acc155394b588db12cfa01d12c46b31145b439ba93d4a85dd3889f87e784362fa70915849278f6b019b26e1db5cac5e58ebba9a3e4da4caee268f4706025ac15cb9fb0b67fb4cb9cfc862bf8e410115c1ade9c9305868b4b5eddb7c18ffebe163554d98667eeda732f76dbee234fd0566b842da787362a28a00239fcf27ca983132dfbd2701400d0dcc2ef1204f02b22f1a8fe17d2b3d24394655248fdeaf433e5653ba7ee6e1ff492cc6893bc37e1aff327efaef928a9ae7837c95191aac831688038d83871fb5f693ecc9b0efdffc6b93ae8129d20d3192700eec890a5ee7a6a335e099e2b7d7d68d7aeba1eb631315098718176d7b4b3ff45ca5a2ade21bbf5149972644501ceed866a9284611c750ca4a6fd7c15368f45333dc16a792676e5a3e8d1b2b0a8e81fb4fa894f4e31f7d7f83b07ca92cf15a421142b2d2f9a3b3c2d96817294c88e23596cbc0b7f1350612b90bb9aeb1ebb203c7c7de4953ad95bc613cf04d7af6b33d56a326861bceeb9698a31907f341435ed28fbeb58cd06f2a8b9e04591d32e3d92f08ace214fc66f05e03daf5067129b3d63a06c3abb913ca00803a29dbe270b42dd27bfeb77f4f6fa0d7528f6f14dc112ac75bf575ef02701f6e052e4abe557e1c6813da5f3d172d3125fbcb8360edb4361455215615a66813f56ccbf9098337247f170102a163c96f207f0d23e37ffab70dd9884868faa3694f9d81e086170bbed44f61caa72e41b215cbdacca9f9b01c3c40df6f94ca151475efe70e3dca578abf30382af723b2903cd48388c3c8fcf43f982f556a229b405d5b094dec26d5341cfbbad93311ec7b5d44847eb551d1c2b7857db78e84c87f0ff69d3af72ce0ad64a3f0a5d0ae71e8bd39aae85ceecc4ea26e5ffcb673b8fade10e0c3db5472032e337098165d9b01b9f2b16178c2d61e5551035d66b58a75898348223844531139fea695c445bf077a381706414a6c3991a0b9c49a86772e428d4798cdb88eebae5dba6eb59afd1cf44592cc32f34ecefe3e5dee9852974fc8ac8b350411ab37ef3dcd8949ee4093ac53dae4bbca27139094482a74db7177eace0128087f07edf953aa6f1c5d9793b409ec411c98d4d98e68b28639d8cb2efd78c35b349b676b00c7aa70288a817a0afc107879e4e88bec1db9a6b6a880bf9e808721dc7184c05c0b642908f63b148a6981af6e929a6a59cec39d9b70eb2488ed03c2ba88d36d61bbbe798eda8da11de4586ca02de14bffca0af146d8c3adeee635a26d750f2967d49a131868c311bdde0bc3ac37b21926d3bd3107c073b79c31d1e738c4c7311aefe530c0272deea74880e35d642148d9cd41d64efbfe0fe1d689783b6440cd4114cea28f1504399c7009e0d8d43b87039dbbcea8f63fed22f6dcaa465857d5f0d168f3ba42ac030e49ffc71a12c4f0b7ace5ba3e4b4eb90882008c9dd7a4a75ab835eeae0077417273b33b9512fa550b3af13ffb0ce848559da0cfc7472fd21bc73b71ae88189fb94990f682598675f8aee022652865ee0cee96640b1d9506a70b4001adb4c22a5a847b14a87bbcf726086d8743aa35cc7869b263fab4183e77d665164456d18d679640f674bd225ece674455d2cfe77b394f738416e122978f286fc5b6adbc9991315d5282ce0a3df8fd4555cacc2db84f691d303f4afed863c4828db00b4afd8645083f7ac643622e9a9d0e822b6899f98e909dc9fa2b3315de42a0eb31c4d820baef6bd7d2729a3138b55001d01cd2f20b53ff000a1b5add2d4a071271d5af3ec327ccfd6632c867161dad94dc289c7ee065296108f1f314430fd1b5822daad89480a8954e5046abed1fee3f4d62f3701c8e3907c1d894945ca611f36edfd9eae605d2e410db18a7eda81e90f7553370f780fed767b068789c9ea454d17a0200ba3a0c6463a15a184767c5e0414e3764093b2e0ac567b5080dbca6b6b8310bcee59e021ff5c97997ccf45965c9bfb9386a2620a6bb60085c24de60b38495866f38aabfead1af3b8d13bd098cf103efbfbcfc8d6599a0d91ed602b07a84774dcf37f2418789213775f744605b1f928ef162b0e9dc0b1bdffcecad1cb11011bde908f570210ca7f65c050f9a06c461b2e367dca70b5b45559b6b73cc9203632af18a5d00afb1f84a6a7e5972e20378990e7063ddf31f612d7b3e6b38640efb70288dfc2ef09adc2d3faa8537b1135562bd82b5bcc52a6daf898a47cbd2fbc06e89bb083e1a9620973a0c2b248748bc4b8e5f4bf2fec6164bdb31d495e78b077f161e5351fd812415a1edb8a0f8c770cdbd9ff34081c185bee6d250451a9fa0d0a7a7fd99b21622dac7d90ce7bbcf8494919b096db57be6aac661ca9070681452e55c62072d2aeebca09b81c8b29d891d4d43289bae61b8ea3f9fde4e3493f835e48caaa0a7b12a563ee5134e07e88e3c009452292f3df9cf45f9a876165a0f538b5e961ef4ee4e5e5a6e7c1309396b3521407606444f3c99b5d35e09860ca08a58344ca38983b218c1e14e48623f87e0b0abc1a8021e773922ecbfe71adda4ddbac645dc22b9b08e00afc1eadb2506194be36c99e62792f95542c7165d12930c0dcd94dacd543756a7a35eb17846ad6b79b1d42ddb7471ee9d5238c4d0e5aaf153880eb0f9af09a3f38477d5008cd37fd09baa6f69c7716f6a6bb944d76f5850afe2849b7d611a158a9de3ac42ec5c2586138c1d1329b48a4701eea31cc9a310693eb8c19d020213f62df14a0c61a9651809e3d7e751995fe9523060a497f8b4388862ffa83fe087f42aa2773cf9085effc12c5f7ba4afb9c1cd8c34f81a4adf178e8cb5ae8a53dabddc196aa9ecfed915f099d2f06a1a25d9b2f4c8b4bf1db9589c5336551b25aacd064b6724c7165dc2bd4f9fe797c7f80ebb157f821f3d977a262bb5f4ff7b49fd97993fe72293b37881bf56b03fba35a21254c10eea6483325f44e07b6bbc22b7d2036a02d2d2bcd01b1a1caa5028ce2b3812a6486c454977bbc2e94ebdc9e4e4fdbf0a91d8d1fd1b24214a81e28a5922170662a0b897d907d232bdd7047f3142eb2165af760a846300773acc13acbeec9b85d2abdb891aa59d774289b4a460157031eb64c2f3a332b5e913ef218b1c97b9257286a04f0d5691b951760b0e971ec10d15296c46b4c67b2630341ff285da7d61622694707dbf8cb799e74686773312732066b0fd98823be8d6a1fa45d21b2a8857106e7aadc47bebabd1555e8810f4e84b622cf8c993c4a47eef387a1f760dc62ca0de44084bc6f65125300caa8b626c29b1d42e4b4a8e55df7f398e0dd9a0552b7042fe0ec3b7b65f5605546da6d73be553144cce07bf419fe59c0e99e479c54b9f82740e8094a31081a98ee504b6dfdd663c4e9de54fee4d6c67b25202f7c70cd6ac99266b28117dc1298fc4875280a513e1f4877f481d36184c2d0ff780dfc4706f3084a767dbf22f8a248de3f11e28704806ae7161c1ce51a30d265e848a48f2f312456cd26d8a3d802139ce8c79513ca8a5ac7ee984faeae042fbc1c3c19ce91bde4c3370b139e00d4af6f4e30da1b975f9d6209e23c46531384d53e757c6983770d031ca75f210afca3763d3fd41a6115a7c42d7b83324370ddd55f45c4dcef10f734b83c1e6ca5b3fc8bd771b0e318cf9f51dad3b24bda837271c595f15e0540e570024529a8cefc30b9effd93934242cf72d31db51e8b7a160cf37f52e9a8f36c3650b08e217793f62270a6c79fb78475df56fefc3505774c01e7f771960e4641798a16fe8bccfb16679ffa3dca41d6994aa52d349b984feed94d9f8af37d430fc6e929c43d35c37e5eccd366890c25c2ff6e805c9303c14c78921e227aadb000ad3720925c5fa3a2dc1029ec5b303b1d9c8d374b073deda2cd0956eb8e2dd2e798f28f0bf0a4c63f3f2995168e0c4e01946039913794487b43d086ea627ed63d346b644791ce5d6ae6d2a2387ed5333cc0347b66654fdcf0119c69382a237905706156c75bc39a30203485b1ad24dad83fec4e20a5f8cd930b0e8113b42cf5a65a79b28dc3008f3a7aa83d640852f0d783051520142f3e4f842ed1788574de326bd695db9ba3a03fa60999a02f0e877968cafcedbfab9be2d4658e7b5c66a6dc934007aa2bd0198d8c3dd0786d5557d31e23c70533db452d9f6554c26e6bb28203c7b24bd9cba9ff38dd681266cfb84ebec0815bdc50dcfe283cfc2265904d8a9f4b12afba8b201206ed8baa83d303e58c72548d5a8dda78614e40e8857712b13f00ac899bc328cedf649d67886bf4ba9c19ccf2b98dd77302ae80621d59264afc8cb140608667a94a483ca690552fc39720faf4b24996904731fb00bca6ee5e01aca5cd0fa9c43f7f3b63c9075a0be386c483ebc43f87a82073e8f1ecc93c4645e0ee2c9a31b94b8cf38115a5d50542cad0521042fbc19b061d2b748480cd5450d7cebbd044c86a1d95843e1a2968b92e19b4aaa7067d9300068b1dfd9dba854e2b68a23df827bf7d794aa3ab9b229387f6a85a066a42f3fc61e66eedb689e7b02d085314223a1d52f4b79a7b2602018b32af6fc2e6919921f476af0bfd13e386c9bbcd1fec858332f25be3d10365724a3d084cd9fa705f958aa037a2fa939053b0ce3ba34764ab3eba5a54b6cc0f20366515346a5961a84e24f4cfa36679e192f7dc520560e4936dcee2940fea6ee047aa85d6683983fdf7cc8326fdbb57e85c97f8ef51e3ddd34c6a67fa43e6c37765c35c91dc8ad7b1944cf595f69877fdaabad50e42e1cdf97e900d970f3a6779637064b6df537ceeb00490260589222f237745c9b1b3555822e5a9565fd1957be14bb9d85098bf93cb31478b8452ac18d3f3cfdf61899e07a16aabb403896e13d17948faf7c04c102cc2201bae53033afdbd71d09e624edb294d31ee1f48b053e8ce743618716703c4286e9ebd8dabb93cc3d8ff2c6cd120b15b2117306196a4610131b0ade9af91279c19c937ba1465650ba19846c45627301fcfc2079b4a13076b9369d3471900b7eaff43cec6ca93c0330ca178fabdf4362739a5f7fd62a89e0d6d79a48dbcc3b389b0878e2510577621c92d5cb624c90dbb760ae8dc0fdb0a43f1b82edb91fdfbeea4cc0bea530d1e651a1d0408d7761f6e68b28ee0fe44e1846687adc328b50f752cd4f78a06d262f95fa899ebf5639afd6cab3b18235e2bcb36d459aeda6e258ae9454bebcf11856cccebf8cd24fa9b1ed210381a6c2f6253fa0c05a8f8df14a4ec553fd3c62dfc8b2fa84d5dff5fb40efdbcd3e8278721fe8b00d7b0fe9ad2c86cf03e693c371b32919da02abd31f33f55c0a4d3ab3a580484fef2bef7b9890ba8f586f46f6330ef401b1e99b797473f2d5dd62701e616743ca7aaddf3350bfa853eb98519675650dea99a638359d6c9e55505b1a575dc57b9d49b8615a2451576146faceeaf9513fa877562c2dcb786bb76863ddf410affe989ab37e9ea36324816dec466be882efbd25cbfe0272279192478e4ab1386ac070f2fdc4ab8039301dfdf2cbff4f4eb6106043d818f76528a08d127fe1bcd1c17c3670ecf61e96c73dfba23ceab688dc7e4f0f9f875e2156f3c8337729b5b622d1029793d18bda210447f74bdaaefa55a51bd8ee607fe9df38eeb20803db72efef7f610d05960538f6b80447b1a7c2c64c8882cdbdb69921ab55cf42931eabea9fa256d49c6e4c29f5edabd9a72a402a2595a7fae2e260f1cb8d487f25cc293c5daba87590e02f31fd9bb77c8e6c241e4d5f03da790a65a89830f010d9c07d367c11e5bd13546423a0c9831243211a8f26d85fd7581c4a3c9ce663a6d49f33ede7b2a54ce76a49d48b5776986cde1ca25ad496f928c95ffc5bb2847dd7200cd8d90e04ac7fd86e3118800c3722357cadfb906231a886ab420b822d1161db790d023236297a2f36cf20116e781158469384dced345fd86e82941d3c5c37c534b845952c4f5b9b047763fa2847da1b4495873033fd5921795a662f029117cd5d6c286764fa8565328dc8ea1c5730011648bc5120f980278cd4c8baabef54e69567c54c0db90dd39cdacf6e9d8302dc0e06eda6d89d84a856aef6b0690291884aee765947ccc1888c40533f55fdbd6b4d312724be9830e0e2fc9bdb7dc6ddab576dcf5901d38a32f9a8e4ed04782798c4c1c5f1d83f92d076df06ba61b0d2e392ff3f7951f858d6265763fccd82a7d02f34ce24c29848664577075b77392d83378cfb1a0e6e6f7568ee80747892b5c783afe0f40748d9c60254e1b59c08586cf81568ac5f4963d0123a2590b75eb7cd64cce4e9f2f7f66697f4b76cbc48a29251573d8162fcfde740964e691891ca46b457471d7e3bf3d0e44c0774edad7753f729a6ead20a6a14d9981b2ecd2e69ee6b5375dda01719e30069bff572478b726e7f6ad71810cfeddc99e1fb1ac01e71024cc56667d2471af6d6c87cc6d868b7394cbf644e11e5c979e690e42464f26fdce42e7c3d385e36f287daa4a98591083711d574aef8f0b4daa86a855ef01360aad934ed5a74f1439aaee4cca9072d9e45f02bc7b876941c120eb6bffd7b30191a0c494fcaeec68118600072ddd7a059b81c2a4df521631a98c5084a20e83d3b4cd4c4cd19c622ee05617656e61292252ff69a1eb8cfa13ff56c829d5a7084421c240c75cd3a46359dd339c9e16618bcf2ff9fdbfc8e593c37f933ff6dc265b595607f06cd6b95f33a98edff99e73f5ebaa07573c64257ce93a561b4e697dc75695aaba07fa8ecaa129345deafafe1e3d61845d97d4d2b617802158a0968740f7c38009c6fd8970c1193f72427369f1694fd079b37c1328a17ada356426799f7508f0475468866cb8f9e41fed239c23414cc6cedee206657a6dc15dbcc5f2e026290b3fbf7e6bb881758041b19da2a844b2162fb827779a13202e495a93b18e8cf99ae06e2937a14706d6962d584dfaa0e15a33f103254b4eec46ca80ddffda2f86af04957dacb7ed321965887066f0ae7125dfc236d88ab4b54d02b74e3e24de60c5dfa16c5645217284ba0632b5fc8948a19fa6ff439f5ab23de700074cf26d62b76d3566c40a3928b6c1206618498598c1b5ad7ed4ea7e5f239eea4c02d66b5ccade0368e5108efe91e32bcd9768bd9ba6e5f92dec176cb0e2486cc0d70aa814106b13100eabd682307ef2f227b630d892fa79395e4e9a670098f8f4a586e0147b0524e370255f43bbdd369069dde8d06e71f0e610f1f82f5dc9e3e5bf07f850e33777a3a881f10da3e91b08760febe78ad892eca45515f9a555cd19d9a001e0b9310c40e76e6f555432ddca3fcf7b7b8f95f6b1d965d975005741762c9fbff6cd6ac2d9aaff505c65d1cdb2ae62588a0c5c74a9440492d651693816e87b3827d08945244f61ae75c30968b7b1bae9dbfd5a26fabe0a5e33beb0f197e9441983763a7a75638acbb424cb1fa1be185c287f55f7fcd82aab65c3b79fa145e77a04d515193a97d985805b84cba01695b6a52521eb6ddbca908127db2ce374ed236292e7f68495c64f95624aa1e83a51251800568d57b159449ab3ed4c30566d36439bd1be748ce26a05a81605912a347b8129e2dd4e11fb9d864f82f32dcc098c76b18588ce66308f66113c67a90d205d7eb0d106da153975f696b6f38d7cd7e67ab02be42788f6e17a0df486773e95f241153bfb159cfb0c12b75be944dfc37d4c890fc98e7d04578b7f815faf2375b1130e9a9590ff7947f8be4abebd6b927b6f00947325e0b239e871db27113a58b5986676704944d9f2be1278499f5e09224573b6d74768c4bfc6fd7dc42ebbafb6bd04a7267c3e7cbb03f5167f59a3902fe4377e6aa1bf4136d3608c8148a15c06e0ef656b27197220301a3459be1b158c3179c5e53097ddec9aee605e30f1e8ad3ddfad0be776c061d54d3f73080fffdcc0b0e0d5d399aa50e77ef2e6d8f70b456cff067d472c4d32a912e24b9d4c4e8b279d5205ff0dcf67772c04f8856d13b9eac7d42cc4c49b3de9a4796fd8ebdee1947024e442e01a00030e6ad548d1e15af27effcb7be737be22cc2918ac44398db638bac6c5bfb0749f41e57387548365802d2046fbb3c13054b35bbfa35cce952923c65dd1e07317d27da974585ef07a5f6eba03c7178c7f590cd17320cb08b8866a131eddee60c67bf10cdc417ca2c56cebdc75636c52a2daeec8cd1f9cd3e18fcce2fbecea40ad61b688486030ee67fbaf9c2285de69b4fba9a99da8d0ae2a000286ad22b93b262c546f9897abc48ef13f33486afa21dbce224d4cedc44944e061cc14fc02dab05c06e8fc5483b9a0b81bc350dd2eb650c9955ce40444fa2306b3d4fcb2c6654c6ee9d17ec71f4659a7c7c59eb5f440891d724205317fd8e13a27faa14063764bab9a56ee4c56f4982a21da0f7888ba219b101c5b8b8578cf976205886747a493fcadd5d95db26d07521927fac5cf05180cdb72d467c30131b298c1845402b1521d0761738c1f4eb7a4fee2dc0dcadde74b13f0e6d8489312e995428ea14903b3fb9d95de29ef1fc04af082776899eec2b0cfb2939dfb4c20eb870cad81b842691545238ff774ac8c4f4bf1277a33bb364da166cfb02fa1413f31483bf4d7268fa9c7ecbd95feb8e1e53555bb70d89123a7b7b6ad1f495da49bb941258947bedc238cc8e73c3afe60c163ce23db2c3f57e9b56b4f386b7485d77f365e59bfbb6d9670203464d5579a8049080cddbcc3191efeb218d78354e7eae5c33167c87156f03efa01e53b7e3ec32b0b1562b6c39ee1285768a8fb7f5edb47ef11ee8928","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
