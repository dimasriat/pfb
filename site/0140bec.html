<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2602a91e83c9e89a75fd67784f4458174ea5e21a69439b348df4f3c722db961976fb24cc7358d857952c25337fe20665dc210765878096ca7696d48f8b98bc9fb469dc43110820c61c5a060fce40ca4490fd47edf858b2c9830ee1a0fea82ed52690cb21c416685abb1d91d89824d070ad3bbbd6cbaa1c2e859eb904e894c81a37c513d9ef2f2793a9487817b799b28655669d048603e9905b262d3224e23ff61d2d926e798b172bf0dc3feaf72964ac2af6c4be488f1b8f5c239a14c7e79e332bfacc1fc131801a2b2b9d8f0f6addf00d65d0bb480d5f6e0a5b86acbde41c2c68dad7cc231707b3b3242d0ecb126e9b393fac7e91f737c44dfde7d63470a3ce6148b6c400e280365ed160fd02faf5ec5d818ab06da24ce90fd7f70f493d8dc6f2e4b86159bba1d5e3ed945e1f8f8ffea908a17fe0eec6f8a1b0f19ba7a5040f2c8e0b0b0c640ccb89c479d52ad47b3df4e3af8c70c47cb3ac32a9de4bbb81c0a3353264509204fe0bc5906afe31261cf34bd551ce8ddffbbd7095143ae9ac320e22d3bb01b121c9216a8461f8420965a463c2d6fc27270cdcdc95839d07a3b8c51eb01a60ac3d05790f88b3b16d0994cef3805114634081c2799d212ebc791682e14ba8e006b3fddb27338d49fe5a8dafaecc812bed3ac2ce9e7cd309f85b0dac3eb2eb159194c748ea2c19082e6158f45a9ebb3e4d0cb8122ec8b3c260cf43025903125fa65f7ba278306b5319ae078e28f74b453cf37af253602841bd956c60b47600829967c871296ff380adfbb7a4121b7920d84f148534c9ae0d68f17a8d16aaf1890838c926a03de0fa7eb8c2e0f759b41d4d3ca1e942eadba282df5668789d111fee1ae03f1914f4e34977f63153bda5c5e448e13e1fb4e583559fc3a46c46cd8434ea56f3a569ad7d86cb6a2e1f3e682238e261a14cb10d1e60fd5b09f3b1d28effbde6f112594cc415e47cf12cc304526528ac4f1e7a055759da80e664a1b9a26c85b2165204dc9c7fed5bd681ba0c4b18892d50cfa0cee1c28b97fe7000207c82f43a0f0343675c439c5cf49c21bfe7558bba409ab03bc1cab7c04a1ae782a9f6ec7b0c50758521b71c6973ceb42599666738e1dbfb74de704fa8740a1e2f08d1574b8b999e7c5893a95b389e7ce9be94b53b8b10f517188607ef9c21bb12e9b7a05c85992ab61df6508b052b5bb1da17b0c325715636f44e5aa9f3fa8ee8061844c9f1bb9c3785d7482d10f87e5bb616b6967ff56653544b99e7f9bbac6e306a082c2d42956e8f31685c1ce07ad664f565e0902085cb2b38252da187e251169e4955db3dab151a1a044f4e5e2519a288cbcf36b9f81952dc1b08c27e58be1d94650f5f47831b8990224112b030f68e9e055505493187e05cf0e28ec545c073902e8ffa25c4c77b1983c5be2b4d3eb11d2c7b99425feb618f33dab0031c8e00469df7bd1b0ec47f8787cfc0a0b3ca1824628aeed3cfed4fb0720c2c61f529475276f8d8299f4e641201e436d49fa48ca68bdec0252d1894a731d021b9bea87bfc96f91a66b1e5a2e8d344d95766641ef012ba9dbb1ab19d1d803d90eefb35fc475a373fd69b1d7b0b1b80c20c49556e79c8600906ed27704d101edae27a0e37bcba489b587b58776ff33e4a5f14958e185789570ea3dfb245856da960595fc1c6b5e61c729c5dda5e0b09ea2c03cff7c812bfeb64f8271ec1a65e461607f5792177e54f7f2e99ef8d9d29fab5efff642df197ae350dfbe6798fee9bb311dfd29c7ebcad5be79e595a501dcb869bc3c5a4a0618910294b3bc6c537aaa53ef75cc88c40075c8e744813a2e052f2bfab46e7913e446285a091922da07ecc81cc34622f7d72d8ca1320b53aacb3f8078ce14913cae6547a925ab2a0bf0850e78ad46614654310fa71e9645702b66ad61dc32d0592de2a462a15292785c2a02107e396e51fc92b7b7e3a0df16abf53b485240b9f68b464e3fcf61d6b0b8ba2005f74bf50e174ed754fd6ac5aab536c90e90e29b6a638fc0b9187adf571181d7ff9dc61f53269538f8d5fc30348c64006bf4a8be0846d60798ea81af25848591037e826cd6c33a426e6c7d34464872f2b7b3b363da8efd48f91359b1e674265f7c77e94445b6234702f54799211a0938bef51bcb31c136e6b3d07905a6d20c1a51fade4624b0aa995d5dd60d4412e924f9c9f27d93b2c37cd47124539c1cbbb5f639f5e4df942060fcfafa1047e7ce847da0c9694560ace40cd5b3a02412f5bdc1d8a1a16ed193c776029f15ec837c2b8f37581c7c20bde9a93b88cd913a642ef3e49ed3935164c9ed79b1bfca6e5c8f1a0ac905f23e708de4c55384246fe24f0b6a7e7a73575860631318bffbf951e5edd4359c473a20dc510b3af2627c8434fcf8c21ff792a14ae8f02e4cc2cfb65ec06af712547234fb8094328acaa9ca6816402434632d88989495ca73e5136f51da226fff0b0913c4f7009499d578dff760888238da498cc390f46871bef56a04b2b81c15ffb03459571423e0914c6fa03e5a6054ba5007387d3ca1134e78741cb1a436a9a7446ae64058250a7dfc23f06382a87dedf539af971c98bfc8bd6c6bdb975deaca8bbfc0826b5e466a70d4099061f4efeecb6ba251e0e0ba2f18ff746953c768e48650bc9763e9405a33d79f115bcc03bd27615bb3d263459c3a625c0781b5284781fd91b791f02d30d9bc5619d8810952b86f012e220d159a5828a035f36ee27745164c23fed417c2ae486669c2a77f2dcfe5b1af0572471ba8745d26654a9e21e495b72d8ce53cc5b8126b9a4ca162a195dd25107c083fbe4172fa69b604fbfa4965a6324153589cc81b9f7e4c8a576f9084a54736dc3afba65d66771c2d27de31f0db31488b1abd63801b190a42074c341563b802af22daa31a369c6bad3f8602857d4071b6d1cc11548bc834fdfdbb8c81eeeb15747cb663729bb8cd4c837cc4e34d9ceb6f4a050952b74830e7c1ddc69ae53c35fa4ffb2a909f7bcdbc99b27028e00077da036fbcab8128a8da93913c5011226b040e3809c75f52abf78c25ed5a21f8c77d17cdcaab0f40671572054a6da1e21a701c774c142bd12ea63af81705300f1e7a094a9b96df95fe0a5c40044e230bb1c0c636e04410213c744644ef3a3bfc398f154422b639ff7e1e2db2dde8f7dd18f31a49136bd14f3e3389bfb3936d479ea23938df1730cbebd4c7681e30dfe7c9fe14e7da2d7c1abdd804fca9ac263f7b2e8f115585715069a77f874dbb4a9801283ba607c1252fef02c57f8f355d3864c02cb7d62caeb63c21961c8a4fbacd05094aa0f054fc8b1bec3ebd7b66a059bcfa9988c9ff4ce2e7a3836163c583031051cd5b459a3198a93adcfd96ce952f15ebae96802c7e10ee4347a6131639ae35de6ad55609521ef306273d225d4c7180a1557156b2620aa53f2e68b9d67db30f95dd687bfbc5e4aa130d0af4811466915b8b2ffb38bc467ba6b63efd7e237eca15b1039bbb50e64f1490e500a69c960ffb22c7cf20681ae940d32612f0f5528236dfa7244934270c40aae4b9ac1178f36d604b195a82e5176e01df74e6acc9d60b7ab56a0b1727ea88e2a6fb2e7b0967a22fdeff8fe321f630b192f2aee788ce514f4d9dfe319190dc8c0d37513b16e8547119dcd0f9647743a08221a3706dce7fd06b03f8fc83fd718b0e55df66dc5e3b78ecf1dc733a14044e7cf0ed908b98814d9b221ca01f87847efa1ef6ef67691a27ddef8b973ab992451da1c94d4ce70659ef4835c955af9ae9a1330473dbda421348a69c11616057fd5c80155c9b9c7be05318e33b63b551417b931e7fd948190c839f33c5acf17e12b71ece8d7a91f3a3e537b78c620fd5b4f692d13d0cd5be7c78bb5c7e593d527490e878ad8942fb9c1a9416139eebc2298cdbdc64515cb4a19368496e747f7299ea99c89e2ee8864412457e7d8a1827fbb8c2a3222556a0dae3e98ced18e5a9f6bddb9eadff86cd543a23bd6486b584c55f2ab8f33032366aff955202e3af6e4800afb071624280dda362b98cffb74c2c70fc01e3788908d7a1cb93f5490a6fbe9caaa072d16414d04269d41768f4d3c8387051c117d91c9da988f3cbf54ae1944c1bb1b156b7412ce9980f0d2f0d1aae14b7ad5e9c3041a59d47a18fcb6718268bb79d7cf1945a4659551227f90d7bbabce2130bc4116920b14a4c582bc79107b110c3a472544aa4e25211999a2cc406c9c868de0d750146e1f90343fd82b0ff488f09d95b6c5cb4a572785e28b833010d6f608bd01aeb061faeaab046538b5a81bf213c9698f02370845654daf3871872cacb2c958a7c33f75f57c2204dbe27a39d9ce0c15ef44c08ee0ee57d77080e99716a8caf6df0b11d258f3fa464a3a8afaa5d1230e3d086d9f0b45c8f282603b733c05f135da4751b8d134fb425c4195787670a4488bb5071c162fa1e6c59d4a78313b480b75065addbf23f4f21536eea30a24e1bc7c00cb04f307dda3e0796d9ff57b7bf09113c807c632d386d634e0f115f758e54e50448c173fced114958003958ed4727ce7a0cff37f34b82a13a5cc8e0d69bb6a6f5b29f899571af568b3da442a293bcf851d3f3bbdb50898d64f52a0a91c338331c3fd1adad1b70d0a114875f6fc85117cf27a36641dd7651ba437c206e4f9a590414dbb3fc48796f5770826aad891130c3e474e85063ef74800f16d5b9f2dd6531073f9a2bdb520dea292b95f6cab9764c47c9cc7622fb9ce0ed5e0258cba60e921bb3832b6039f469ef78b4caa18f3bd505590388c8b83cd5b3784d17934011b8fdbbac70dd1c07bd3102d0768a7e4c013f55067db7baeb71eb49915f5001cb955d17c216ca3fbec6eaf301c558d5d8f93466364ec0b01083eff6f3727caeeeb5e104e24648744ed5b98f80bb32dd1321744417d161e49ec3e30b4da6d27990e1341124073629b16c6a131127f071dd5f13c31a436f924e964451c77b7651f7c261115b0e96747b76ef3cb84b211424e91a81b6486c73c53419e2923d980bac89124cb9061b08528c9637db9dcd003b39a837660b647078dd9bf32154380766bf2908c65019d15dc8bd0134679b9e9f6705b71b3e9713f5aa150b6ca569e3c3f0566cca1df3a9871337c3c428842a3acf6c53a3c4ffff1fd0678f9d90da04ad4545162faff1e21a2d40c4fe857d5a934d87b70e58d745053f56a195cac059947d0ca50ac6da5e8a24cc9a5e843786e116315141e3ac6d1e0471a64a54c2fe7b340a946f20ef5cff3344e8c07d629e97e2379f1c863a596d34e1e3f8af62c070100d2203c464a96525c9ffc56ba76f68639a2d41b166756eade37339b721c301beab2ddd7c0fa2e8b10d0cf3821380f0a9cd8e7a689bdf0b0990659ae705133c6abaf47ce9da29c9338fea5e3c78dccc9b6128e624311ce01381bf5434eb89be661874f1f543f81d5d9f09293f3770700b7dc66d7b2993b1538e7d9f75d3d8787bcccc26d34d1e8607bc1363ad2d2f79b70eafdde79efc36b6eff32f05d9fef1b62de629aa8f59eaba8cfb6b85fbd28c82bf64606fda8f9bb6792cbee2e0eee5878116f658a2f5c565e7eee29df76a857b7673b5327f42ebbc50b3f89813e3a3e88ddd4078d8754be9486a765ea7c627058dd92ee5a23b7b8f5d68a34e59697b7bd66442362013c9c6e4bd9ca11ee1f4420e370da9acafd6a5a1f1b73620f7405f27f4d08e934ee97aa65e162c825226a674c195ea0bc1fbdf128169ba3281942c3bf1a47d1296ee54d342c39b9877cf33567b87c1a0bab1bcbad7258924cf6f3066bab6b28e331f75ae60a5afa78130b60d7a9d364b7c61a9338128cb58abe1ebb345bc063b82839e1b0a918152d5cad17e085366fb2bb765da61104b8596d64592dcc4a4e370fd0a8f9e2e9369a04b0fbd6283c3b6dcd13e908cff309e52d41a158b6e2ccb64c61eabd341e144d6f03a00e91134b2f76fab5139f544974d0eab99043facf36b2df873fd17fc5446034f6e9b5e5153eb762b73ee07448a2a7a3509a0df60f55c1a8d65cd4d0b94c1c629894c4c5c09957e0cdc352bf046e8a5c1103b90b67ea661458d58fbe176f83d9e82c6ef603ae5a1a509f48666210a04eeb78b57ecce584f6485d3c2ac7d4c4f509c02ee5dbe53dc1c18cd3c5ed259dec3b1397f965d52e1ab48b404958de2a37e838a908965de18999c73726cf52786309b5793da10fce7805445afd6dc12218cec825ebdf942075204d613503d4e82e3f7571209afa85d32c163aab02027dc7b8925a15ae773f414bcbf2e202c013cd5f611c9ccebe857765df71a40134eb8674673994448ccc591109873f661bc8a032225b4a3550b4b39995792e85ce7d498667838b33de2ab73bf61cbe081c29aee7e962c9a8a91075e1cf0d2b1d5909c5d1ec12360932c68c1598e2ffa73b2022f5dd7866b8410a6e2794b2791ff48108c81964d9098a729484df79eed1a6e99dcdad5e78a5025d625ddd1b4bfce4f1a3770d1fd33aebc7c6c5f68d02d366cdbe9976cd2ccb1a03215b24f94d5ce9a794521d28a397e1fe68797cfe70178db3cb2a922692b408a446f810ac9e2162cd79bf9137c727af64430bc7a40511d7d6bb0a520d3626611a4de639e5e0f27966956ee57edf1d10336c1bd34eec4bd2f2c6f2afe52e3d5f15dbce164fee572fcbdb178054c7e5f2a6c8e307ea9e629d5021a9e2d7964367d21dbfd02e8475a8ac30c8219d09295b1838c311795a0dd700fc76fd8bd61df41147a4b2706d2cf6c6134313df329d67e480ba6856ce84e40d316e17ae75af2ab875f24daf303bdae2c465ca3da443d2daf5a7332f9b7c34fc3136a85c5f9a65d323b084923a278fb233a812f33ebd8ec63a1d8f8627d3848eef1c50335ce078e5895db115052221801e2fbf80568f845e9807d121ec63edf0e26eb14e1825cee82b2a089726858631f6a995a70eeeddd175f6b55f367f631b0d6f951f0eca3d29d8669cd78b9d251a78a94a09b3f76e02345512fa514c33140fe00f0b97d7596694574faaceb1270e70faf1b2c279027aef06e73c309724aa80a4cf92bc746c66c9133f7a50cc86618a17194b2c223d43be13a82f4492d0e4ac25fd213522820293e351c089855831c2d5096dec2fdf141c074b9478796fcd4d45033a46543afb73721967866baf30cb94583c7a79012a1617310a971e822a3dde79b4ef8bb82b6c21100aa9c08cc8cb4e2b4a089f038cb01a32a18c7bf203ffce14e0938f7e234cc945cc3a5e3ed2af0ca2cdd26a9e509450516988c402c4a6ed095ab910cb939e8d924cf7a16139cdc82393d09e4c9a33af6de33e77d2a2d8f855f849eb75d169ec52fd2801e160b057b86ae8c58a68b0f7e605981902d0bb2060bcc3f3f5971fb0dfcfa8ce04bccf43570d813f67680f6eb23812aabd730e364328fcbae541ef65d035f05588261180554c7e7377325a7c60e0f2ad9eab33d13459b256a695480ddfeaed58d2a5e2b6f70560b107da0ec85ae20728f368283afa4e15c2b7bc8a4d14e873a3feee3fafdba38bbff2f871d19f0429c99b3dc855e659f4e3021a571b3768ad03b3c4e15045af11ca273cc0b873b39cb2fb185e959c9796864e99818afb8db1af519f7d54183efcf8ad19773f24f9f66e99e7bdf0374d6380003f1d4eb07edc1fae1635116e822059810abb34a1c5074cb787639cc8f454f17a2318699210b0e7e915d7de74c7a62d2de2f7cd70fd7f3c04696a2708d58c2a714f0d772c403e2005e7ded4223c52686f29bcccffc5f76c5d0a31ae88d140326c2355b71f980a3b653261ebc7a16f07d64cb78c31a0e446191f6a34b4c95c08181e92bb05101f0577943b906c60a49e1c55f6eee84883ac0d0ff31bf50bee07df9193962dcc94f0eb1f0a6765a446ccfe16d04735421137aa317b6c9a68902954005906a0b6f246d9f285f54a3409bacdd622e5ce7b917daaeb87a9f68bd35b687da21411af1e2d58bf1fed33f465ee39961c8b1c2c511577504d9d66769b1eeffc333cb10d9f9ba6d9be9d2b8fd611dd551e3470e3acfda1ed8aa4acf77def2f3101fc1ef8b9d6e96e7186642cabff6a8eb939b9fd93bb68c7f4ec5547374aefe4f907b35e8b1737c6ac6fa45434fd3084b17347541ca6d38464c236dd9112e80733f98cd1e520794411fe4465ceb39c37600e71aa137cbcb4169a4f1a60029761c57e20d66f1e642fb8cbb53d49a65a00ee2145c2aade630d956ae2a7e66503b3b549082a4204c633e8acd40c0ba4684333e174c4689c922e2fa88c97cca5bdad4c687ab4dbed4332eae265e56b84fae58be303aadf39cda8e8fb65661c71eca381667566a2d3ea096c91abefd3df964349df783d897214bc6f31e92122ef827a1f27ae7e95dea03edf77c3691ce555e9914b5d64d169713d6d87aa0eb3f388b5897efdf92112364a8038fe203c8c794ec770e2fed26dc98ed1ff56d1a008caa72cd5f349c78afc0b8a3aa9eb294660d19a5c4653d9150463616e8ab4022dc7319e66c03c63cc15a3173146f43e8ea174ece8e41d1a62f72274604b38a25dd6d0a86edeb612c14b8c31f03e29a48815d1605222f100e06ef276d41e5c5b1b71d169abef39459ec661914b44888624381d5b3c0f46b1192939db35db260b33393b6b40b26a861a6e24477c76142ad801df654519fdbc9751cd7b49cd9c3edf85787ecf3f4b94b32d88d65fc135f879e6ef30d9537727048a8b62cd5fd56b6c4c65bb2bb516893042bb2d0ac83be31e59e44a28b6a61e578d0917e4141f024577f77754f685d7a69e67ae4e2850de6523e6d6b20b58b20ee7b4ed81a03807180033745956662c4a8dfc1e17000f7bc6b7b18d9ac84a914ad7ed4eefba0be95fd8946fd44bd37d80b86cd4f5dae050369a4cca3abaf281797cf46e688e951d9460645003d340f6947095bc38675ebd550c02bf8357d1cf04f40125d818e9a35a85ffecd39719e6991666fec363de268b731f38b358bfbf3b28bd1f3e20a86fb3c655d8643f573549ac16a7e67777cad395762de6b8631ce16e6aee00a301b9b99025277b80074e8cd3ebb35a972abec36ddf61f500720d2447ea8829487e168335637803fa13956cf62a7929ae0d69793c5a050dd639030ee750f586652ee5a160bf3743cb4e1766e8ac7f06461725cf7df0dcd99c2309d82549ced5863e14ed64819ca2c6c2766b9cb89c1426b880aeef0da1acd41744fc020f12df5638500066ce9c157dab46268bba1f3e9a2d90a1f96145de5a8bdb7ed92cbed405da7c82767260347026156a3eb86115dc5a8a462699e8b2167ea1a5984af287b5c88832430270794b957569ba64691da97cb48192cd96326d2ce814f829bd91b1e2fd70474ad867d2760d9baf46c4c99ade6b8b87d210f291b69c1da433aaa081b2d47010543c7e0c84b25b82488a0f1c69634e8e5caab8cb35d8f11b520f285eb98799d1240bd46c7d0c5cb7fe5e08807011afa81413ed16ef17671aa8695bd2cac50398c3225ffa4821a7a46ff5b94fdeaad6de7a644f7ed69e14c88e9cbbd091d74951f4f45cbbe8aa56fec8e905f5ee741a8d59b3f89e25937f37f468f224973521790e7800d6d2422c4310db5c26c8bcab27bff4dd91998913059efbe81a7bcbd7260a8d82c45ee5d5ee9db4c1d6a66ce624aa38ffb198410f22f00eb62336edbc2624a6989b440761d62f95042024a9c6a21bd8ed79a433baab4778372be5a808c3e10b4bef11d44063a32d32e5a881659360395fea77c023b6286f686f38b92da9783b18ca4a1f97c51f99930ed86bda132ceced48363fb559192e89b67cbc25c552cd3b7a08d27a671488d4c331724206c26c32e57a03baa555194e719dd7e4705933ce3aa64a5d89ef51d33f2ae7cbed76722b4c1608ce9be82105960472b7562c403bda8baa2e41b959880ed1a6a887abdc15af8b18daded1363738f8a15999d7c93c1e69e7c00389f05f54fd073018084e665f127ea70198b124d612fe0b364a9b6094ee44fdb42a55b34660ba8af576cffbe3118c684d70bbfc3e9bdf6fca61e0daca524e575037ae938407f59574eafb3d42ce688c0fd5efab9fef72966f80ca467187132bb2301714f2a23051244a4a99694845b26b26114052d162a8a617af19e9cf00fd14d0f8f71336fa83588726386ce0eb2b4a3dea7d919bb388d8fbe8b30c2c4e3305760b463097127389cdd5892d74950c294c8d68296be32355c8ae6eaa3ce44b803e9c5aa74019caa42c446c557c402d5b5237ec0ee5a28969cb57ccce63e45c830bce83f078ce7c3dcd5dbe9a87a0737de463b024a70e0bd9297f0473fcc6bfa023f326e874674dc4aeb30473342ef824d36f8e52e51f47b2a5bf0411327bc6d587f10564a40278bab2e680a458499ce5bb90624bb0cf47f7b2495fb3feb2b9c93b851747203d3e717a9aa90638454db117464267a4c0dc4c4937fd40408d665ce16608715af881d910e81178a21bf49aaa0c970923e42f592f5585f7543e8bca204aa7b99226a1b6e6708c1a1c5e41d860f0827b4ec5a9d899d2932045324bfb0a33ad9538767f424e6109ea75abe0a136d3b0b62f3d7cbd03e03e6e0e32fce12bb107e949235f657a52089f6757fa01ad4d16dad3b8949c661eeeee1385454924f626a281a2535077fe08f0e34a91ad1d20279e3c333938fe5d479bc2157f40445d9e0495a9fd619c7db3195002bef517046be4ac2cbb1a0c63e7b2cffc2a624731cacf4484f79be6a037bad62f455cd203b05a0370d7fdc597298af193a1a71239fa61c7ac3f4df475446746c02beec1c75fa79a66fb13c8e34863b5aa146a5b6f1defc609b681cc013a27880442fe72f2d7d3e5b9a8ee6dd73ca5c10e8b7a1998faeb9fc5e8d51168b368f1a7d7e72d547b84c8aab9f633b53f42232d1ae3b7abd5bec198ab6713c67184985641f4cdd9910a780e9c7c36e21c7bb062ecec5cd2557f86d4929fb2b7e585a0fdd3efc3a3bc38627490bb8e7c9b3f590d5cbd01d18c0131ee860a107aa30ad73103c40f5f5c9a716f0987e1ad4c541621805e2ee82b0c1c04f38a13df5d511b159fc0e1e72d152eba1e7c790316326195b370dba7852f90500af7b150d400912f78f23b159c2e0d3fb8259b868b61b7665be5aa1400f3b8b67ad31357f2ff90e3bf31e396b8538c0564bf5b52ae4cab0a95b52e5fba28de76bf129cc525d12b439ab64f4180159d82fc20e706d90e422859bf7394640b929df54f240691e942cfeeea857614a1d5faa69f13344b70112066623d3195a6d60a2dcafd572aded04e2485bf19190b6bf2a01cf0f5e33544a37de04fa2512d8096e3429e0892d2ea08e6fbde3bab3f0735dac093f7d942fe9146d4c5b9eabc01b5231ce2d6b8ebb63e89e1db4cac9a7ba2de3473586f61feeef8783cfd16b55eee81f74c96825a8addc2beaee9dc40bb67654f33b2b981679600e47ac5f9c8902861a70d18c380d63765880c35f66d39f0f34cd720bb0dd73f06694d1a8fcbbd262efc9420ceb584491265ee6e868d3018f678504d65d382ec22ef2c34a63af6a6fafcb64846c6bc16d7b86c84fe3c2c42af28f65363965fb650aaac447f7e6cac7672494ea41ac4859931367a3aff5e521ce8af06d8294d5569ec22b2eaf6c714e2ae54d9ec09a22b1b42fb177f82d608d4a631213d8e191d2bcc6d6c4c0c86636da006cd85c7c6efe1528d4e4473cf3a745731ead49a56b4786632613da7d5ef5e4b14429081bf5b3af76197ea74bc10e50a87a2c6c7acabcdfc871322df2bedff00906fcaa0c80dcdcce5c7caaccc697cbec6d70f2fc64667f9020ec8a206c975926b4ae14ac19618087d4570acf68b5d67e6eaaeb3d4dfdf2ac8df91fe7a86810c4a3563ccd754dc8df9e66eb1022c6b6a29f31858231d75f06d4cdb4dab54844cd6f7667a108ea684c93843f73c46bafaba5b71a095487d6e76e5ab5962bdbe5ebaa7a426a5015c234d87e9a49675bbbda059bc5f23b428f0fbb873fb453261d9573a45bc17bac4ae62a20bea8d394ddd1af74a0fbc26c82be2588fe5f2d826953890e64aef62e8c755c4419dae7927477f97b4bb7bb3ea3ea51e4fb63bf508fd2d98548d4946b1e34a2f907f9400d85c04dd64c64849fedaf8d6043fd7c37abac03d09d37d157153774b925338c7915f4dddf68c9c060f32af03e6c2b49cbc70916a76c6a8c3bb3b793d1c3a17f9ce690bfb8e20b34d7edb236075e5eb721d5bb775cc5fc8c0977d4eb24260b83af08c6be82a7b595d1b09a4c7950d6bb0652198340a992692ba857d4cf528de2a1054727b5021752e9cd33762ff4ec998e4e9d6f1851bdbbed8e9854615a2e6b662e2c7d8287578e87fdf51c8f845598ebf4481b19467e6556ef5ed24b79843924dd504fa60230d935bddcbaa98138319500f452ca7d9deadeaf70cf6a50e0d7c3caf166dff464a30a9653090d4e047255b33ea8b2e837afb8cee4b24105bf4f1073af85af8c21061a0802a9c1c7919681430bfb9fc20aebac45b0126847eb3e7e42addc1ee0eee9bbb16270399289eab655318a1009a0a2cbc8ea84a7dccb6e4719a8ed064a866a98880c49023c19f0b986c2a537f8565b74097c437b6157a92332a4591fb8e5bfb4ddfbd20d74d9e622d231afbcb988531ea20374166d463c729947e89eaba158e0912e86e7980a4660d025963f981d7ddea6340af283957a28e02f00adabd5d29ebd244696705df6212eae14f404ec12b814e5ec461999e4f17039b619e0a634ede516fb187e3ba60f6e11cc3bcc0184d6da009e1e6d7e313085f1376857383f10e6466d3aee8b7f13071e377d80cbefd70197c7b567631161e8c1e32944f9c33f0b24a359f8b98e4443b23bdb4c3f8f46b727d25d16b9b1296c42a9d67f87adb3c7b294e6ab9a65bf487381bdf9b12575be8dc169119","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
