<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e49f0611c7e53cf18715dc1c3ca3f47c5507fab0dfca4e03e48458a7159c9ee6eb67ae65524f7837899272f08a351107231ab0ff4a6e2e0d1d9580ddc7672c74098fdc1f51b7d521a7b3217bcdcf11eaa3cdc2593f08df0330d833a5b63a95cb94fc770eeee8aef42e768b121f076b5dc1375a7e072722959906ed7c52cdf71df97a5fe1f9b768e6b31ceaa21613b239ea6f093183de30d657acfd7beb52f3e6d73f5d3dcffdc53539af9d3fc35efbe292dc92716905f5c43ad4348055b7227c807e29332705da1eef7149a6e0b2ddbfcc76f40d1caf6db3e8ff71581892207522d3f2ccb973a60d4e4101a0ca08eaeeaaefb498c7ba9ef3555c792320337392ae52f01c002409779a05cde40fe16657b3b428762cd7cd9be4bdef91fa0b4980279aeec38bd874dcdd0091d47405d77e887a5b81680bf5cc9eb2a232389158f10bbe48d0d099eefc0679ba5026a2a3c5f6e04990f02595574b558b72011c6aba4227fc9cfddaa341d588ecdec6d3611390023e9b0387feff586fe54aa764a7c873bf7656447dadb1e12748a935fb611996d1a7af28b68668ec051d60a4fde42f2d58836e162ff974155f94232ee9f4deaa82ba3c36ba0887add1e39593ee2b2977e842f143f03c4019b24f608f2d36cf5c97ae17f8af4b69a4e6407253acaab14af027cc4f879b20e6640e766579f09df768dfba0ebf1d61d067a67b87221769bbb5b8a571f4cc7f79989fbe9a02d21ec259e98185bd31530c532be6cf2478cb99bec5ba82a5bcceecc1b4584cb8b7fef7c6fce023af819a675fedec7dd5003b43fd879ffd15b882638c412bfb2791482e183e4ec8854100c9986050a0ac4e43ac0b433c169e3a3c01a8621e24fcde92986d48019de8d8e1e6f33311a320769a4629f8b46073c6ee61614d606be2adffc976560079e15cbb1142a99ab8e0acdab3b3f9e49a5c0423506709de4ade12c518b4477cd14aa4385bcac833ebde1777e8cac67449b06830d3740d7cdba9c513e561f42977dc96b96cb0a08f02a86f9093eea0fca12cb229b5216676ec2119326536f3c55a03e3a37c08cbbfba1d29a705cfc9e8a0e64558f5402ec0da0a7f00db77a04eca363932d674b98a093eb1ca12c45157185d3f7213c906a7072620ce19c1963499bde0c966197826f0538401168b3430323ac736507c316d772db1476e75856771e2df7bbd0dc310538be3da5387e238527e5dc22a19ca04320a1b997713af81fa580733e140c31af809c9cd84debb7038ee316ea86a97b31e0eb385d6e0828905ecbcf4d0811ec243120e5edb5f5c2cef1011408ddcc24b759be0a81069ad444f16042471ad0563515f6b46b0a4c892c946e8941ea693e69b915861206e96a88f2bdd42134044cdfa6bdc36f00755c8e10517cf3c9e294536669390199b160fe5826689be2c251182236173ae975a606df12dbacb9d4eeb7a5159a85463fc09f6e6ddb980d6708b8676384d858a0dfe53ddb3c27d2e719996dc5dd097fec4a6592034a8ca4aefb3c2b0c3c7c7797c947d4386c682f3c21e521e32e932cbd4e057724aa75f693984fe4b4ae2a73c85c9e13acdbe73c29d07a5ba56d6e641916fa7acf458b1269086ddc2950d945c24519e39945528d7b02f2e5fbfc0722aafe3ba9a103c8c9b3532aa293fd7488f253e13fa3333e9d1b6984bec42fc21240e74aa23f3438618e6f27599a1db160a0ff3430cfdeba5221b34d17b00430a6b2295a098ec602da155599e27fc8914b6f76b07ffd48b5a25370e106464ad8686d37eebd63d4aa820454640ad4bd62ca8e92d75205fdb133abd1b827c400b7ec6b540499d327f2d88d7a0108240373a4d4f5ffa5c6888298dabe5465ad09d67d263f97cea583d7ddf05bb0265302c9f4d1a245d695ba92c52257903d3566fc0e34d1e29c010d6a7609347d18e1d015ed2c0fb729b8abe3ad18ac99b381c76598cf2139c39db412b6546a1544b963a516a39a83983c3d652eb9915b61659a55cba4927b60317ff4a751d4bc65508916f36f7604d6ac656d8988bee96fd8dd18480c6cf95d63ea86b5fd8d7d367843380086e4d7dbc96aaff59cb71aa585155fe023723336e35a4ee4e4fca028f2af10d6efd781c2de79d7423f223560cb7d031a85e4b2772cebe2fabf82187b5b983fb79b44cd2574345b79b02aa71e7470ef18d4a6af3821d23596780989d8e4996336e41569215cf3043915df03181f8a1972deaf2b982d46ed4124f354c853660c3cff2fe6d855bd6537fc4c3c41a17eb2ee2a3bf8ddeeacdb9af7dda79d1877daa655b080120fbca824d9c63235e1de947501bd228f4cf032cbd3f31b8cc8022fce36814013a729839c1cb70cb1b8f9e87f1af2f5ca92e716249eb36daafffaed299c9b50f6ed9dd60c4acc6090220b4acbf018193fc817f09f1580984558fb221c3e5e0c03d0a46c86d8b7969614ae46786b546b0efd117f4a7dac8c86e2e78c0d6c5055ce4d6107fde12062ceb0a9e3ea92a5de9b7423ca67a6f9c49249cdc4bfc9fee890af6d150cd70e3550a17a16385a7f746ba28f3c628bef21000ad24e8963376dd02cf15b133c89be48e21152f9f490a9f4aeb9f8bc3392777bfc1fdfb2addc15aaf8af31b3aaf254917aaffd8b25f4a8b29efadf2c3cdf527ce0f84abba61a5337da59074dc42ed96c4466f3d9e3ca6b36b4808bd73783afdcddc6449e68814cb193e127628b9ae345bd981e03ed1459b084997eb351f1f085c46ce3ea16a77807aa20a87e64b5b6431c816df918ba6c82cbb3c8cdae1b813b8d68e2d1d99cdedbf6e4966f20005dc5f293174c403199bbeae621e3352f9f956945f121b737fb326f7f836262ccd7309a57311cbab85908b86a4e7dd43d0717b58945c8ccfc5f8f303b47cb91424f05eaad2492b80f3aa4dec7d8e9d93be91c9d29b3c8deab02f6b76c84b7ff377d2c17d4acbee1f2c16a537bf2437d99aad0d95603c338f6d13fdc72ceb86275a0d04e65a2bd4a3e05481c93dfc2b2ba4dac950ca21df1d47f9a107d458e68bbbacfe509486a2c409d0a9f38f8ccf084d29de12f469e0d81c9652fb3ff01403b0cda4bce4c9f3b3643f008969f77358b14b564b9786ff2bc7701decba5c02b9a5c1208c74a23b82027260b5e509c28723f9011c08b4056a12414ce1cf2bfba63f31024df08b9970329eabab714aebaaae459748fb43f89f8c6f8b2f283618c89842c498bad2f75f2a438f6a703d7782e9e40038880292ac682993041af9bd3227ab6953633555697449be0c6e11413260cb5a780f0ee2aed50dc4583f58a7540600a91815d78ea11388a93752c2cd42484d7698b09bb8561a4a5b3a593e98b1d00f9c2a6540ddcee926f5430a8ed1bff76c9dac3ce9f276bafbfff7f00f5881a150939fe16a6a302f4a1e99af2c143d114dca5c3cfc3797500e08c3762c580f2200f26ef9df30f92219561235820c2a3a0bc6dd2297a92446ed888e27c1023c4616cf6d8fc39d3850c7d61f81007d731385bf06c606078583cc05951794c6b6afc70a61830b64a939e6461595a4d50758be11720ff8ab7800d9b30efba4f6e548e9d660a451281089e0d53c0cad497a754fa81da693d7a0f068f0d3a92fb23c7f3a6ab5f6631ecc11fc01090615761ff8f050db85e7ed2347833f69d9aefcb80ec11f4279700107668ae3b3c33d4d194daf831146632dc7f4350ec36f785c4fc6dfcbca16cf291846158b28bbecfc943751243b078977c21ecf0ecbccebcd81698713fa5fa2f90616c941028a7e9f2b96412474424b9c24f1ecb5f34c5420c3f59119f1d0e707ebe2e8f142949eaf0c084d0a54b01e06c6565593899215a37e94807173aa259b6cb25adf6ce8c5845c0201e0183fde79fe638080df16e5680782f11434d562ea11bee14e7778069372647580761a5067e938a7635d03a79c6669d18e337d28d697c37aa42afd3b094893cf4d95bdf2dcec381496164d0ab81d6741854bcb11a37c56669390123e1a07377dece1fb618897cff09174218dbdc94cfd43fcf624acbf636ea497bc39342694685d85a47bc839a8014c512be3eab8f9172f4387c6d02627dfd8b053751d02e19c8c60af9bf62294a923c85267302def4df681986d33446a218bfaccc66ebc96c661e7ff70959ccee668196d31a476133da09c02a0102d90ad43ffff819865a5d6b327ed382e7f588816c659c8918b041e05e520b1e7c924728da37f8539c58375fe76b9929273974bccf1a49c34ecca640b3196beffd05a7860a9611cbeab292a65426ee6134f4011a16c5cf422da601ca1637727dc8a7786329453db447fd9cbf72fb1b841ba4707f26477a4f3bfd1b97b132acf845e4cb2a6c243dfa17be82d57971ad8510ef8c1053bb3bc52874eec69cff78fd65ca12522f4e7f05a97259197b0e8e2fc040fb6044dd70a295a53d4504f046d218bf57d5f3a460874d554d0f5254d59916f95043cf2a2c56e907a5eaac428aca5b9326b6b5ac27cc2774790f417da7a79194f3ed63334d4e4ce36573cd2335caa9f71e979a42cd92b49ee6245e0538c07673b77edfbe7707221bb65b2de619d0e2a5f0eabc3330c8e2af96307f3cd460d53eede2ebcabc2393a83704794e7bd0e35d353fc257abe9b07df9d51ce9cb20a86ea2445eef03ab76a1109f8d2faef8c30711390adf6e021ae8c1bc0f8900d5ed6410b25aed001b4705dd2775ed97b06a23b9ebd9dddfa33706624991a7987213c8a3aa58215a55fdef3b11d00c9ae85d1ff9fbf6d817c8bfdb4471fa332fd3254678d0a91d924fccf64d62a268681f47584d891ea58a2458c9845da538a1f6d9f83e962f88a3a7a208a06c928c2cfeb5b2ca5201496fd06ff63344e4e3854370090e4d8fbcd84bbd997accb8403dd86f15d925e386fd1df109ecaf761ba9a626bd3f366dc3af262d2b47ce9aec2cad4ef589446b4e1d2182012becf91b395d193102f9e4ea92430488023ae40ca985f8257ceba94c78853f9b936f3f463290d448a9e65f13f0685d8a5dfe9d22ff6f090f838e9bb70a34fe474f1073ef3b679e1a0bb70b378683cb86d2d4eee4c1ac0ea758b9fddaefd158eb28f702e8654972aaf08085f70a3414da9cbf9e7965c41e1ed017c432be3eb7f15278f240652087e8b2d951efa5cb66b6c35fdbc50f3152b0c5524dcd660b4d5d773a5bbe5113b0b0c60f00a0fc849b7f38b370b83b248d57b586aac27cde5f773b3f3f7fdd050d62ecdac420661fe2aa23a0678ec3a462bc254276ff99c1e0863a33cf06df6d9e6f92a39eac710d9e0e1e83660aa596e5fc87eb33881a4e14e86a4d26f0affd988ad7e685e4d1a8913f9302a923afc57af0c1c80d225a772ba5029014fae17235ffe85f8d36096911d787984c6f02fc64383c29df5bb83a05bb930a3be0afce9bc2ee7d6fd0259c2eb4d4062944ec5f396ee571d97f9afaf703dc992addfcbaf61f1a2497496f04811b2f9f432f6a9f4d1e5f55579e91c422425af653cd4c2652dbe067773da71ee7eee15b1a0448372f707fbb0b068477fdac37a69a8bec1f3a914b6b144b0a6eaacd3846e34a80ebd463321d1edfcbb3714609cc1e77b92dc716434937b804124f4daf21f210c53539ac204a523533c8108c6828e0c0934dcf4688b9fcb3631e11a54eb36c7f08f4d79de24b17a4a2e9f37d713c769640b9904f751cbc82f65b3b59505de1fb954338ebc5d68bc1c5c53ef3c10d1c992eedadb01247b8340be4fcb9dd24968fa267bb23c3b649ce28b6b34869fe6f31e78ab831eb022ce411837f2fc941196f7abab4bf5b752e25080b91e9b4f1ebe0d2ae96fc5c5e9ed766059e77025b8bb79605ab3e712f1a2560c5ec5364b5fea5bdcdc7fd04e4b96e64744a600d6f498b6808af08220fc650d2cf6c46c315302d2572a4f55944b8228f1ebd973b236c3e2f891b30f5a721abd4b3e8a13df138d7fd2ab7cbc3e05c5c9ec756366e9e5c3f4224d26c1eb2a33136d513c734475b1787e4e3fa8c7c91cc474303ab4b7df99c503e87eca6d9abf57f7fed172a0190347106a7e4951a5fd8f63b354c319c36082fefd1aa66df01d1a34d9e4242145250095d0c9ea3461408f21c0b55a4ada425214a2100df4f4404d0d3a4c1176ab6679de1da556a9c36441b960549ce2e982205aeb33902def8fd1f90dbc5f5b5c7bdad3366427d20d4591921aca84d9eff215231b3dab7dd913ec25ba3bccdc30b886b424126b024cc0df08cdb6329915fe257a1198a17db333c61e3de13c0706e0ab8fc84ddc4979ea3f319d8ad5742d891006f5c2d93f10131ff601090e09de61450c90b32bf938feaae91aaf07aaab7bd555ba1ee0c2e6ebb410022f616a323ae8afee4ef3154424cab7ed8b227e5c0bcb5037f5ce3d58886913587d9cc4d61616f32e0e6fe24ae133bdd9c96f683e734383abc48b9a295606c2409068492942566d06b69e9c3da3d4f9ef5462892ca10fdfe3610be5841660e034dc8d610940b96aecea17fb46a3c756d26d6129c6857281ea35ada298ffd72a8881ea54b99f6f53884c74cb5fa3b8d5a40cd0157de1c66dfa8958c56a1a6cb8eacce7feaa5ba430aaa2242e6cd922637d721bfbc913d9181a7e9c8d4af367057d64456f3a468d229ce181006b93448864040152ba0d97e9924c4d243f704e0865f8389c4d35a83b71807071b669dcb6e1f10119500cb79538fb5040d0685852e5487fa731ed5135e0bff0ade064e9036235f9958eba7091126a81972c7e90a71022e49d3120564b956e7291e06cfdc305ee82ef1cb35aefc72b29f9341514b37daa971e27d9434c11426340c0ffb9e2e23b51584b783faf4ab7de43d4ce0e44e24f4baea8fef9e27ec95a0274eee6f6f9d63b02f514b2747ce76f3e83fcff6160878c5a7065955a67092675c07392e05655ad62dbde1784e05a60df74a927493b4a77e7441fb61cbbb862763e3d7f541d52bbb8be1ee983d5b7c1aad507811a64491942e5cbc9269ca1a9a08c9b43801177654057072219f8cfb22c128e936abfd6f540af81290055a9392f8f41312e2f551df6772da7d47bbc844d2bfbb83a9c39703f0fe9ceee6c2d3a5ce62fec437177d45d60964af03d4fac1b5fdbfe45a0a1233bb181bc35b1e0692f1301b296a4b99886122a5d72245fbfd56b82b15a11b24807984755e5b842237c3b99eefa29b5e700b4326d9f7c6d96eeb4c3aa9ccaaf8d810b99eef44a85fb198b29b3d815ac19b02bde7e81d2c073ad717fb57b4ddd60e2f14fc51a8c3fc9de80683329fe56bc4fcc625b8afbb034ed265e2f85eb9e84ca8a4b3c33cbe5fa506baa06deef35e424a84997e2a164a4910e37e578e0669acc64edbca7a8ba7e7a8ce8dbd429071970687eb85b2a812b6ca3a2a1657465802d23714def4ff6e896e1121ef906bde023891c3427f3f974402705b5ece832b616f545246b9e00afeaea22ec86c3418728ecd1c339de2f275f6f763f9e625246bdd4771168984a6770130961c5d5eeb8e9590e4602c1dbf17356ffe962d27ce27a034ea45ff17657f0ff523aec2591ff8cc44d10173314df14cd03d5a4e913490f409be0c5bc35a1252d290b2209eec5fc461840d6f070ca09a73688d949cc20d331b6acbe791cf3e9422e06f018888352e3f58784227962192457dd815371640e9d12a8ddc1674e3c5d51d4ba64b19830fbd03a439dbff77be653885012c1933b686b53c3a24e8eaedea7eb309d114c65dfb839fecceb6916278aced2e0394e3b1839b81b53621ec435beb0a8f5a7d102b9e54fa78abfc9917eae67333f74cca73a08d1ed093ed4809de606cb780885f88c42d29579860e9c7e7aabc3aa17c5cba698feb2703756724b1eb81404df118a8b159896306c14945cb54e2ceb5762f4c865e1ac78cd8e8a29b678e988f8a520f7797ccfc3b6ffada7d472d7175e4875c722d1be2fdc503cdd48b4ada39275334f90db409dc8c0029faf48f6b84755f80b9d338365b03690f49366d5b73187c92543bed848725b9a6dd8fcc8cca21e6c5f9ed8fc7420d4d681b7919e1e4aa151812524a32531f4878df770d0e3a857aed2cbb08b6a179dfe5be1b1c91651a7de68d7ab72b73bf1f0ef86c6aa4d9a261d6a2bea5e32de05a39608f2b9fc31a5933f2eb005415dca5a45995ab23b0007fb5555dc210ac40e09344450c6e447d912e010a331a248c3550701bf39972e527b77051a01a6a14280d562da49ec431f3f0d92f0d7f5f3318f8311ad846adde7e4f9509ef1edbf7388bc7fe814d8382c8599e73d3a19ef723cc9e6d9cf7c29f286c0b0cd72f1790f8cc3c3a3eff80dd7e9fe25efe5e98b43c9538c3e243ff326bdf14e5134468d760e564c9e5c870ad85d8d5c5e67de28f36740fa81d49dc251c81251bfeedfec396d3cce7e1d1bb7627a14e3018b2358a46239a92e947cfcad130d634a06bc7e6c3bf79cbb35ba4062863ab7a38b64e4963b66f7671e2aeeb604707e274563c4496d5403e8998f6f5aa9cb48a4ce5e5f631859c7b3daf7f63b6bc985247d0e3f8430c1733153c2236cf49edec3359eb6aaa3698c8eb978a331077527a27e50e0b7cd8dabd1eae67944634e2bd296c565fca17d96e4ab931f7bb1599416336a5519daa8d8b1ce7e3dfe0a21acefd21a633ba72d17e3be40c8c55765407a1f81858fbb340220023613ef9460f43eea40d1b099072595d2f266e1e52571788917691599ee5403e462c24ec83b0a4109295353deaaf6abb50b24f5152902922dbf611ce5552ed540a0cfa90f0e58795b30b2fb2387edcaedeed38d5a8e5d46d5afb8a80f5dc1219d0cd2ae5babcc18ae659e991a7e07e1d911af109496f3f81ef5d21af60eb7e4cfa4b19c58c43f5842d18807a34aedf4a5e88647175dd5a1826a94072a13be2e3852824cd6c17a8cae37eb3b300f8ff64d3ce6e064596bc15fa8a2c5296263359ff7c4d51d9720c1a43ae54f1f8dd7e5fed54b379b8885c4ac23e1c9a66242b418f31510a408b3b4d6a5a1eefe53f753733b97e67320fd839c1aec8ae799906b9c4b716aae39e0922e46d1df25be7932cc2b9e075de1fa98194afb35241ecdc967ef8eb41b96789f7f139edea714016185a95ca6620422d50a1b8b6c03c0b38ead106b42645df922b57162d20edef17bdd2ff53f0b351843ccf1dd4826826bf06fe3031716457caa0f5eca4307186a051151ce7c3d79122da5642019a26876614436faaa0595943d0ac877e874a7bc80e1f8c3f13b1611b2cb1de5812fbfce80c4b431457ed54b4c2e9f944d5d3f57709ebac079bb6209829bb070ec9ab10abd717b1023995bfb17cfbaf8e71112edecec127894edbb7174a3afff152332cbac778b0b09f964a21176490c98002c4b32b20ef8b8031a74f56e25a603f3b5986693ae063ce6e4d8a901b460b19c663e6add78e13f301238546c302d3b5bfe82fa397ec42da2a312b99c83200fc591be4ff3ffe862ffed77acd8462c94c36052f4cbfbc77e8339019d209918e3e0b18a941efa389d86cbc15fb2fb9046dcf1b8d8b7529686ea0c87480965cae1ab763d8d5e85eeb62ed1910ace10300800b8bc8bcae689b8664ec6d7c46dd14588f49cc43a4c19e49cc28b338bc6640de2b497f7d49a9fb9d4eec5449b88077a4f71d08ba5a942b69104de480d4415333020801f7642bb0d4c2570747827056c2d3a34763848fa8632b9061bf9de4198d9b8ca5d90b271407a35fc7a2f1ad82d48ed246f5d7e2f9776d857908d109b64222620bb5f2e0834d3b2c52b6e4f5634cd3312b05aee9a9d1eb98cd1426039b80159b6aaa2dc1e093e30341769349b8be95566f060f1a237b2bc82e47af616adff99315e27c3caafae502101a015c5f88048f86b00a988e3289aff15b48dc2d41ec708be7fb4e88e9775898eddd0efc348fbb5263e57aa92d24e8e1132f9b7028effca0a2c21b4f96e95606a690831cf68ee075336364d01c1c2b0208c18ff228752dda20a3d7376232cdfd15ebddb5d908e0ae6119e89ee31f31ba0de1f81f35da7e3cc89310984d63dae6765fd133749ca8a5639eb7cb6304f10edade54e0d4ef131fe8e7b8c7a0b80fadaec7a1267d787613bac46343b3c741e4fb7faf6c7c2ad1786f03c7d8a7a60ed87069bc9f33c2944d2111d61f5a52c51b9770fa3383671e4c02c2733a9858934f3709eb93982d11dff7ac50b4273e66bbc0edd42e4c4b68f0f12a4d0044946b3fb929f8f5258f424721e803a81e335618da373e30c690007aa7c3686c003697448f227a6fed5e1ca3090a6eea9bbdbc45e200b4fd7e3af0019d5828d3b5fa96cc77eeb3525e2f39faadb478213e762a24356d48af237b795980b7a01cddbaa62f56840a7d473d0875a3b39ed2df03a137b97c5a20e8740991d07ec1bfc18c8b5cd3e0e3de1ed9d4b00b6707816b8bebcf938e0e9ff84133f6864f239fa4e942bd4a98b199736994110a283a74c0e40041fde528867f2d81e28b147eea4b002dfa9207aaa2294c3759b94e9f1b251a075032b2413eca290d422bc8d7360a3247a00f37dcad54caa2c6cb8e92a7216fe061ce42869d2a058808dafa1620037c728c01371d6e36340d1c522ebaf226ef51ba78082a8000bebc366271fa8d2954819fcc2529afe7b8f97e2a87366578030f2f5e923f6b1019a9e0c7d223e8c7e1cf6f1171fc428ecc5bdfe818e831dbb4710799e2b1b4d958969f1c01500e9c1f10f83a16ca7edb093b26e8bfee5b06797ac0e7515971eaf35aa618efc27e83462600f4d6aa736c346ef67be42a09588bceac5b749e8ac9514e02b30ebaea44623536dcec22b882ae3962cf4a08c704d3bba72de601cf1ef44ada7b8df31210dedbf42831c657914263b7fdcec1fd7a97feb7a51a1da9d28e0f7057dbec114669fa9e1afeb7c0297eb734c4a1cc037312a6a230d01239117140cde95b443fe1db10d6ec9eb2ed369e2f779f8ddde36fe2e3c5a7904752edf55be48d00862064c1989abe63c6a433d79a5eaba2f5e4c56cd7817521a1e0397af1969c78657c7beef17546ef5e9edadaacc07bcb37641a11c7275f5361c61eed4b2e958e18726103d85e27b7032d674aaa98ef886e85d641c78e4316682fc1196b96f46c5ddef001937623d830bbc0cf8ba60ce0e2c946e4d3a9be2018e878fba8ece24ba03c88387fa3ac2e795a335648ea23013ec937e9e9102a509a0e51bfeb5d3e3be36092d296e84dcd066aedc316bf90007e310f7a4a9cb69696892431a22b003c95379b832601a0b7f20b05831e3ae18901f109b3853cdbd2baad80986d7fe69a439e394be2edf88012ada5b9ac36fcd296ee7fe32b31ee450e717a9fc625279abc8ee2a2aac282f7cab6d1d4065d0e76795a60984939104bcb26ccb8ab274fe518c8865dcd2cf35c4c6c48d757c345fb7f6f9f007b56eb7165ea737d5b6fa7d86f08bf791be12","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
