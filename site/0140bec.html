<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cf78f5df077ef6786757e2b3523fc38e131346db83c218de6ec28022a81ddad848ccebc60db450cffe19e92e885bb7c4693fc05ff256263404a8a57faa2fce9eb77df8a5913115e9fec4d087dec72b020b8c9ba494ebf581c536aa8c8b58000890661b75b5469059b3ca3ba207db84392ac072f31571e1ec8cf685fc524f9731d0f3f1485efb01a23f369f407a0784ca391deddf654bb33e48bdd630ac916a0fb7c4e32bc91afda24a3fab07203b1ce889ee85ed31768255adb3e3cd82607eeab93693680da7d66441cb35cee514714f77aed8d271438174797ea218fc0464e9f814e209e946ca3d5258e499b3b5a571dcc253efdbf2158380efe283ee651a04507c5f90d93a5438eab351b181d20275def22a39355765c59a5c2f907666af1f3c486c56cfad8aa60a50b0e7fca0ce56b692538fe4fe773a5a49432af5187f0b30434d2df595bf460bc4e43edf93580eeee2c516f1dfbbafd0ea33f73c8bd07335f8b9a59f6d89fcb5150094db74fa88b1c8eed3d44105b03cdbdeb10a924be5ea77ef10e1fcf093c250f4e5059ceecb8941924820b9e64e302036768faa911ec7d902b2b5f823d18e9708fb93eb649e6cabf2ef2e72bc01cc5acad552a6bced0e49cfa68d7604fdfc77bbc5c91f5c59c7de2fc5df8c7071a8c5a0424b5ef72b0dd657c7792a9d67a1cdfbad97e34f8acf07d62834d5499a723f6ed7d4af8f0651169cb9356fbe048a19f04702d6349bd3281ed6d86fa25309dfaa4677a7267e1835b398056b4364be059223282246aa1867ade74dfb0ae415de64e6818a961be037da6e30086fc3e25e707bf205ea0e4a919891e781bee72a018f0e54766192806a86c8a9d0043676a6435067523b9e82c9272858f8e53d02a5a6aeee80a8f4b1f6a6d8fc3ee52434b1b62724629731b82c6245c05f0032cf51fcd420e6025e31be310a7f08d911ce514be8b61bed673835b7f94a2c626f2ad73ca8540804e41b55fcf969bb718f281fffb309ce1199083e3d2ce034cb72fabb98470b08401915de33726bbd1d125b1a40d39048184aaf8200fde102abbc9a989caf23c9b80d3f175afd9969a93f61ea8b66c864f4fc1089b80d556772fe85bb350f7c9b172f98e79f4bf2dcb71918c2876c3af97207c65ea31a8ff3ba275e358945d2315c0f7235e750a5d4e86b0d110df4f845f8f37bbfd61dac0a03244c204965592de9dcb57b271208384b2354e066c8a17a5179a11bc1a18d827dbf9f8b97b7b459c94a9539eb521edbcc8019cb4b945d600668dcb1f82fa492f8c544d178526fe9b9348009c15f7f0cd9e8e3be5744ffe69c50036cd186d542895ec7e4545f65121e136235fad5af9cc7d0fcebb0988fa5cfc3292451805474e8d04c6302dec3c577d533c73b7dbdc760c7f224b2f201798a47007e59993c338e03e5749d01f2b329a2f925606013ee7701d630d9a4f682ee07cf7a77d1ee1a8be7da6937c912025525beacb6f881d5a88c55f7eea9875d37ddc7d9ca74bf2e3d1a5e5d6c79677078a84f468757d88b88e22f33e699aa7706bf12ddb880dec3e2d7ad78917bc863301546d8216cb2c9eb45d6cfecdc1511ec0ce04e7b7d1459ea7253132c26c28f773ba51ea56a5e7fea944e927e7f9b80923c4771ae822c4696ac8b1587ea2b5adfb142f3c278dd2677f6fdb4308a0c68c61a56e8435e2a69b66985f969fb5ced780eab254953fbe3d1a2f0b908a9f9c22d8fd88149b544dc6af31a50d81924321d1274605fb458dc18f284cc822e5310516ea4504c8a94dc86b738f4df7643b2598c27cbad8ed313fd479a4f40e86bec72ba05233b8db5953c8bb6b2a262effb9e68b53dda47bff057ff6dfb35e44ea4893d0d6a0665bcee07308d7f93523ac7ddeb596ab0f389473bd9c9289688435a210026b56c7ec429adbf935ff40cf36f703b2ad4c093b5ca23b9367fbb0fb25121e228c7b9ad6c6c20bbb6dd9b6d3ce8ce496da15230e9f820db988a945fa45949978817af517720317134aaff7bb8f2c90d5d5fdeef01443e0575272710215a532454709410004d9a4149ff5bb662dfba2a1cc8c1c95920766871e6d2874d2b4eb528ad8313b151ab16f13fd1ffc82ea90e2e9e51b45388bd7aed8ecb299db84c0f4500f0cfca3d3049fc4b60fe212cbb15691f4fc5485e272a98e1bfa92f00903340bef5ceb30b26af61597631a209dd190c19df7a8237623dfee28ffea520fd22a515c7ece97f4e22612619ccf0b0fa3b13e37a85811d3e9250ddb499fca7d4fce0c97dd64cd0ce4fb47aefd0bc741d44968388d7b4cb6035c9a3a2783ee409655ac48bbaff1b7d724d22cc2cb7019e09d7773576b13b3ffb21d26886a03ffa08e731d7c1b43a1e0846ba2976dacb88b895edbbfddf96f0489f709560cd0da6288e3bc86906c40c0a4715acacf2f89d6a63087a20fdece5bf5adfa6dea4f462a9c3bce58e4723c5205c2123b67b80834cbc047a7137f2296df5118f07cac470db790d3e3841402ae4960c3c5abea226a5f0ecc1585b27523d18e1cbf00cdb3571a04b91f88b16f4114fe9187165a2f0e7c25868ff24e41d9f702a8fd890558a31ad7c7f7cc1a780b025f6900b246561115292332caf4937a25271826e7450fe0fff1df5349afa4eb17b70436c8c292ea0534b6264af9c1bd5b4d058328766c4d4bfc0bbf8ae34ef6c2b7b51132076312e4cd577cc22f7a5bbed0c4c0d7b982272a9bc17f4eb01fd1990abd20c20b2a19eab2eb04eb781ea7a7e4bc2b8cad44485f10fe0fcc524452b48636d493fa3888dda17a71b8197831163c74b59a3d6abec227e1ebc2dd55d0fab6a750d93aa0bcb142457a90a2c577cc2f71ce39c19433f509f369414d55f015ff1766d7be61ddceba43fde74ca93aaaf0cbb3789dc535b7591c3df32b1f6e009e928fc2a2340b02d530502cfe240a8b8379e5cfb2222af99a1cfd8142671b8945c5ca2d155104da3494f4dc6d33efe6b61e2a6a286df09e0e0c78e3b4482db4c2481b957dae70f1b23b1001729694966d996c67aef6a691e08cd689be37feaf24ea53c7b3b53d82d278060ac1155a59ee0f54c93612a8a6008f8b2650b43c172709ec049a216754cf7a25704526cff8b0b927695603153ee08f9ffc8efc734d832d8104858e9d393d4a99e65c8e91be28b0f47d86b8eacd8825dc8d9bf26337eaff524e64e6f1f98ef2ed5932248a88e507136413479e2a8d7e283efe3b930b412a629c8f223e9f1f25a7693fc10983a862844d680553db30ff5c0c4684c2b9ad6e9445e837bec2191e95f766136d63c45606313f681c37bd473feae8f4a6678bd9788f2282eccec8fe032808a3209d229b67622bbf1fa9196a3b572486d6b8e5abb8de820d18818185bbf9ace10c9e6ae790f4cb7dbf0410f9ebc2effb52ee6fd6a9cb7833091271f8a81aac7180177f2bdc29e2a32da90490b53d5af88f9c81d0d69cd4d1b06309bf089c3e07f3d36fe0e0d6d66936c17e83551aad9cb9ab4e4bec2c7ea93b2c9435c10dabd271373897a65872934966f49c29b6f0d3d4f35b7e60904dcde1eaa105c5dffb68589c717803661d7486b80fa013d2b9fdd375ee7c4bce2efae8514d55a19f1ca037e383ba8fa1b7acbf6cb2d9ad4885c5a67a0612342877bcc5ea8f86db3e91891b20905ece3a01786e1142de8d0a11d04bffb57b135a7e7b29dd564839f27205c68a5fd462946953c0f8cb11383ab2f5c42f7c47513836fe860fa5294d843b393fd546129585327f7f7e5c34b9445bf1aed3a09f285a5002ec68492c4d57cecbca98bb33e761bf7382e933cf6e7c6b9f414232fc45e1ab5ded32a59f8704069a690c165c5ff337626b5a25d13513a896a52adf969beca53af3e626bca6db471be0cce5ebe44708b5293a21646e4e813fc837b7123156397403cc66d25e1c9f663b3e25f852b57f9c7df6d75d0440213456c938e6ea3fa696ab5572fe6517531d7c0c4313c0f28b4db86d4dc3542b3adec7fd0c848384f201ac2b6fb263c96b57929cdc680fb32ec45fbcabc9d3972fb3cfa815566c7e1d9e614f7ed616967e904aa28cd282abee0f33b72c6a81409c0e9161323f8fa35a45789a96e4ccb0a8c5c131b07b4d2d42857cdb6de4ed03c8cd33f6c366b19ca0ecfc7091e8783731f1368310cc9b0fc9676e68aeaf401e47f635a55d1a97546a9f93cfa7c0c9caaeeb164c5cef917a83c76d20aa441d6172dfd9922d65e86b02b74eb1db5bacc1f21c5432be6f845503c83b79c52303e9536ff79867ae2ea5d98d31c3fdb90b08ea0b483d569d6fe815233250095fdb04c2c784c1fcbbc3d5c56f457a661cdfdbf5aeb588c2a462e9aa4492ded912565f432119160bd224baf37dc705492a49d46e2cd6236549e04bdab3aa624ce4cef413ee15beb7c16f127074e01397951b037089388230398fe615cc9b7de18121b17e568dc8e438fbfaff2275f9ed283e30747e69300c0b1951e16b5efb4f2340f139faf00ee07ff66dc9a2333f0ca20b3595ba32ec65350c902e7e68728137cd0d5cbd1e4fb898ba3349e8152157f8c0aa29c63b2b907b6142564345bd1bbf6c18793182ca9594c60d111373ad67b51b2d5436e8bfb5dde91e136b8829ee517169154399575de200b73a27355cf67c1b017f42cf2e22d315a5560ca16592d5f3f1e65e28716c6a8c3007aeb39394d57d96d3b5a3244fed8634dcdb37dac7adbe341238136a240e539050cd5c072e81392ee301d81b1fdd6e58ef0bf1d79a607acec4593cbb0eb99517ec1d323202c402bef8027896d7c723bc7fe3e375b54f4a27bea0528ecb884f878b437c25e84fad79428b1d4327c7ec58b38b611669e258226d3696767909d757f955155d67701ddf3c8aca116593893a710ff12e8c6002153ba0e840fc892c0117c539a2148efe4bf560ced0a8f56238fe0fcbd9be32759a559fb76cd79b2c1d5e698f78b8a656e919861b8bd2d9979d06218a42e56e6a5d046a39092f153fe69b85c46547c5325c622375430d00f94b980939e88f77108f7d039a772d15df548d0b28f1a542ec73b20f6fbfadd2310fd54fe448b7ef9cdc678cb6f7e4cea76f9ef22e4109f0722167d3a61ededf5144f593b33f7c8e2cb49011c355dbcb2437c2f14f3314efbcabea2c6856bc9830d1dcd3d771294d76007fb29bf231436b5f64fd7b84e1f719bad40eb5ef8b2e78a0218a04577fc28f5c5a2144533735feb627d8ff66836982215e882de50946200411b9b76c7668c9c990b835ae59bdc90394652367c1d151ad519ee747b526bef6f12728132ef53eebd11369b21e5b6eb9b8f3c6a1f46ff1b7dcc76aa85ac019580636a1fd53b1bdb6552232e7a89ab83de17e69af977ecc307b5478daaea8c749ddf0666e2474dfbdfd8bfb6a853bc8f99a65fb4556d4532aef5c50d65c05f6ef8457fe323d5bb37c3adcddc2907bd9ffde493322e8e56015b2a0e49a10789062a0d8e083a173319e86805b8f6b4bfa0295f7e828276a087a7142adbd94893efebbffd865fa30984d0949b13c43b6db6f89878335731dbf9c1646990bbbe94a493b02f5e4471120c859fd94a71669d38feed060b4e8870e8f74353626df6fdcdcd7a9a1677bd3299afc6a46bac856513ec9f16be332a3dcd3a606a2bd78993c19ec530e186a40e421d3fd9bf57d60a09c58635c49066869de48a8eebb95b8f6a55dc4e3aac1df20dff221cfb6001abba6088f0c1dbf76371c3ee1f1b75aa7c203fb2f5662e014ce8e80bc0a541e4a42ee429e161fcbaa49f0ccda4eab6c48e8661b9e15b5abea1c7fe459d6c5474aece3d47dbea52938d2189266f40397131db342bfe8bb3829f0f3a5d5ab68bedde83dd94c91f6eece43893035c05a8f6f4b9ce04364b286664561f0a23016a0ac5aeef88640759327c2f618b4533e1821d7c4fddee799cf45be45e598e993be20dabaaecc9d5f0347f0780247f8ad26573a9ee352d9a601b30343305b6819c2271c0e52e9d901bd5f1805e43ac1e4195f38072611b3ce57623fafb80cc5acf25064f973106d7e3a57cf1c196bf3e096c4622c9d30dbcf662f8f5b48e8ba811a7dfc87b465e964ecd7b615c4f4c4ce20431c273d37df5b25498892085ba104affcb191be01a988d00de5a79c7bd3e9d9eede0536e1aca759110c9f239ca28ec07350f3b5811c895a6edd24f9495d0a0657ad175993f5249e4aae4e39053c43977e895c21e60eadaba3b84ef42b874583228db239ff6040c95caa9b0edbfb4cae6759473a33ea21c0a0c238bac4a75d75fc743ffeb0871e758c3618329ea6fb8bb497d28c713c78ff21eaf8cebfab7cb997cebfbbca428cd52307090ebfe2d2f461f89f7dbda365d63ac7cf2fee8e0e2c67654664cbff337ad33e474a3ea72b59d1087b30fef71370b230f1d466385468a12639b520263f72c849bf2bddac94804af4375f150f21d23c4d6a7acb7c008444632948203e93f3e958696df967cac49c3cc38a1553e431c9b70052529323997f7567d2968aa69a0a8d925c466255094e5a515fa519b5d138041056c8e46d8b0286dc5a984cf5f8f0aa4a3545abed11215a472b696594a42bb3dd1b32b730eea030fedb344b61104bdaed0840ec193de58d6fae7d7e8ad102d75879fc5306be0a685875c604ab048edb3c082dc9376a5a825c907d7542eb3e4f9794098a9392ee6fff569c3554e84659b19cd645ce96610bb37ff0dca080be6d269d376d0f6ca10b1ba5f2e34751cc2a23d54809397e56af9538d2d505e0651ed6939eb8369164329a36b08b7ee51fe5b5df853077933909f72bb5143f8ceb4e33e274b3851339e24ffc452c370cc236761ed638ed4790fdb3babac665f8e681a3dc7052dc7bf24b715d83db547309bead32e9496976037ccf05ea93b875b3ee1d3761f1b70cbf442ad473b01d71cf7312917ab0757056113ae8bbe1d26aede052088ff1d6f6264114fb2884d2bbfda58a072f4b1bb57b758ca4a609c698ba94f28065d873d8c351010fd76a6d128de51e79a3fd0b47d6e395d87d75d426790af5c3c810cca2028bb7c81974f9724fbf84b087eb7d0184b4bc400f976be76519fa86d01866bc854af769d4c7bf4c8f2569e5e759466e3a078ce5920ecb1e24c2bc20db984223c1ef2939384ebb7b75ee322a579b51a688de436c9a43504369a20f8b5b8af115ef6a5be61963a23a93b623b32682a5f5f8a4a56ae9b3480863da55acfe1554d732e0d61f339ace5411c8cb0cd637158c45f0311e137072f5ab7fcb47abf1fc0a0a21334ff33f96eb8babe27a769f30700db0867439a81b3f641ae6ee246f4f1977c8c91a090b60d62e1b880723c271b89f3a3ade5ec684c067143ce25f94af7b34cece676c3418cf9109685e64c6956bfd18f4e2afd9d297f7231583d434a5fa3b5e9b87ab64c9b1bd0f32a46b073fcef15a7d2870ca97f61d213223c742a8fe85c42e4e61d2c98739627e2b4aacf620c2ae49303a9f113f0a9a3ad86d381675a71f160591eeb5a60871fb4c045ad2ffd70061bf73c89b85dec57ddc5700a07477efadc2474ea5fb00b00d6e1967755952de8836ac69f22566d7b1d2e8af93d63603d2bd9166a4790ef6f294e1318d37f08b55617345c06fceebd83825595ec7093b3d5eca4f332e03d90d443c0f24007ef5a4102f762bdd92645f32c0485ef77e2a7e05aeb84736adc877d3ad2ed08ece5db596d7e60e55be0aa8c59834016ca0c48833a8857d75aceadc50e3fbb4ca4d59a16e559fcee267d385c1e99b1a0e23ce9d360a9a32571d27af91d6948d8f7d48e2440114d8495c5f99e3aa64d5d7a89ab83959607a2774ef4baa83ce242c5a7f048d97586994fed144f3be78cc84b2c0a10b7f715aedd8f1f35460de5661f90d0afe0a3b1637d06dc3d802293829487fcded0f2a86396d6936c9412b5fd08d2d1c87a0a590cd749fee4afeeea95ecd995e93eb5477291537aa016d5383c7d8685e36d44a50f8eac3153800674cdd7b4866f484b5c3f4ee7b19830aa92f3d6eba3cbb9a3fb6bc728bb6e2783f2ad59d31c6bf44e1aadf6f1d64ed314799ac499fc1022ab6393ab0bc0a77c640f9529be6d177f91028d1d0671a0b931727c93cf550a709576339ed9fbb7d7f956dd967daa703ce0cef0d873e834b89da985301d6c93d7d086924a92bbadf12ae57dd1658b91c15e0a2cb6f8c3028b316b6076520ee61a4e452d00f3ed12dc91d5dfb5aa74a81b14e0ff56d8ae7066c3a46e2e52ed5ba22206e3f8601312741017e1d846926e95dde93df749d1eb06290606f4d7205bb9ba2b0f4c891d422a06144bcad83c5030b53a030755b5ab0672c90f1707016fb3607777f039f49affcba206710fb889a1442e4fe6954162f3d5f1f98c9763f2936c20a3df1e018de3a5e36d47d8fd579703e2cdf379225c854e5895f216eb00fcfc14744a84dc13d7769f437ff170ddbb065b8eeb4c3d7781d018346f6fcafd082a195c1a4598b41a9c16cd5dea41451f7ecc5bff3df22f18608a3935bc424cf9b95eebccf433b6a1ad57777dbbf3e6ca3dfa8dcf094e40262774bf6ccc96473b1d2663fd28b97324ddaedf5ae150a6ce736ed56212e80446cd6f39c198343ac4bca770f45da6cb20c6784c8b709cb89d68d3ab097e5d1d21298ec10326d6fb75a3bb86f8a718fd02fb0de0ec7bdd19b63ae1102b733f6679adc67949b828e81bd18b993804754f0a729a576affe6d4169199817c45ce90148fee932fb7a0424f9189490ce6c0b8235a9a849fc3bca6188a76adcb5c0687ab9afafef495b252982a93973c9bed91e4a86cf17151a94f5e56dbb19b5187eaaf72f907c9e4bae3836917e9a6d9a24a9b93284e973dda912bb41cae6a3463a7b4106b6720d614f528d2397cb7bd86a88ff5e2a0d2d797159319d9ae5e63442769200e34a71e3eb14c595ad98127dab8647012d9d991a27d0021df2f289f2f438b1672af6eeae07df6b2466b2c469ad2f8f3c3b27a028e7c85a895fe8fdeb43911a24f7a63072fa400e0614a7bf3b5cfc6f4beab4cf6bb24f04d33aa00d16d3a089c09f54ebf233c13f522e0d87778d4ce9718bec3069360cb040132a89be80a3bafa2717e1c98b7728714338785300b88e63c30d817e5b4e783080e067b447fc26a57d4f67d0f456ff5d44a466a50c3cb97f5820885e53ea31f84e834580044793e152ec76b9bf2e77db67f34183433ec8f69a433237c655789ba9b96988cea4f47e89e1bab5e90bff62dc4293fe347b7433ccd387e07a2d4e5a5cd83f1a5d64928d1854bb8f50a1448e0b1f5616309bfa2b4c8b249652f266914246d512bcbd883a0deec1953f346bc8330e6c1e591a7f6132afbe73baa451e6665bf8810fc4641cc5692cd2990edde0ff47b3e2aa7b63beeabc87b985e4ca9852e726cb238d3859e34641c6dc8ca7796edc50c5ab067ce63dd62820198909c2a5d49ffbc4104e2feddb07b0fa05a8a41c86801276ab29cfc0d96e6070766399a2c84573af415959b336b9688b7fa6b9e606041c250d81dcd2ecb896a4307b4f2b58137026457c1edebfb8c62d9c402aa467e4cb8a4041a587e9b01f8895352d3d5aee1a1cd70f10c6d438ace163421d271dc6c8b8af265a62a2e89ea936f5558a21ffefc2c07d7820a785ef58401c00d38b0c08e630d1780da1a83d06ccf166691765da0ec85ab139519f1ee7b0bf46e96f1c67a5bdc98fb0e4b71b396bf513c178e4fb7e3c0e8a3cefc9038e0c4591c11a18d667590dc0fb5c398351ad02c64769daf88bdefa6df36f719b4387a1960cf4281ccf8d55bded4dcbbe98f7a5d76812dfe39bf7257fbeb306636f9324e5156571026897448ec0776680ba6e11c5782ca65449072c5275a1040a27b30bed376407a14b704cf0c9491ccae57d413783a3e9b96fa8da7ff7113df2f719781c393ef8d907b04974f30970eded36d52283522c14d97f897f172d6fceab012f425bffb86e52c9e1013434d318293729142523347b821fff6759bb59504d265edcfeade4b8095a6dad5caff9f9d5779719f4cd2ef57a72cf28e1a98387e6ef8b9ff7fb5f4a2df3b75bf0b857ae0f11e77f6cd81732fb18a5f8e86730a8e59d5b3b4fa99ec5d10e185369691124fd8d85376c5869a70a6ef5405b9e6c5339349dfb8ea37ac07bee248e144c0b30764bcb013b3830f37cb2c00cfc936cefa207ab7b288541013f0b3639ea8205439f524519e6c0bd815927fb310d684d561b7a908134c62e4609a2a31b21a7b2510fe6222bd1dddb7928fc28d174bc50e03826d2cce7b72f6a9ac2332d0f355d989ef8c75f81291fa3b798b3015893a3a81c76d987d75b72c763bc8d0b8704f36f0830afea5fd2d625eb7f196301e357364ada1e3ada74eef67ab4a73c6757183213246f892ef96d47c0ca9628eaf51ef9cd6b4bdcaf10c220761e83477c3833efb230405c4d8b11d4e751a544b6cc71cd968a2b532d0ae5731c2a455a8721ebc0b29ed628bdf71361349b67746026c98d81e4e679a53576568eb0ffe20760c3f76ca570408e6ba64d6d45c3b7c2ab4ae946f29482c0a7d2825c16196072ba654364c5bb5dcbaef8bfdcd20ffda0c37b3284233bd3614f30d714efbdab1dc0ff27b10040ee4cd98366773b1162e0e407e3b2bb3579209119d8f7ddb10cc239a735a22ac58e14d53dfcb01943e1dc23c26a66423bffb52e99ff3d833e1d023e381cd9384a990b5c9de646cbffc062f116779b73849c277f3fca97a39e3835592295515a8f61461005b3df2a6c0086ffec1fcb659e31c785b921dbe6b533a387496bdfa334965adc4a95c1c4c8c2aeb74bc0c27628975611e401aeca906c9ff1d835bd979402cc4df9d4bc10225fd115fa37b72a9b653bcec9bf0092de7960b625f5fc3518211f9047c80c4182dffb9f0f826a9340509cdecb83224eef684f50bf784875dc6f9a3060d2c4749d63c7f2b89566277ba057b8842527b017cc0e9ffcc3fa4293c11c7a12930f123d35e9c346995c06f0e155fc41e984e678a25a9f113ed15e6f54c65e85ded978f4dfbdde4baf7e55ed9f1f900ff1ccc7a56f73dcfef2c411305fd547babb7cb1b8aa24dafba7195fb9ce6a1642d80f493f88164dd1d440c813122f30eb8c3b500f6111d0b9e18e2614ed3e9c03e3f52c431eddfec1d0d4ea84d90b3b62ab07609d869ea3d75891da36cba66a24f0c09d81a1b29c5cdf72b499a8ad283dcc24f7407e3adbdb92b243d43c571b02f765eecfe388d923f7f60e9b227891b85355b60ad780f31dee94aff63b2e54ee450646ecfd2be6e3d8d55b4bba90dbae42e7ed90cb814ad0ceea7a8f4f41fd225bc46ff6673904c9cfe99c947bf78bb5ca8a3f6f8a5426af8866092da6b0081ca4b207bf6bef96930c3a7385dccdf170a31c3e16ece35859faa0690a073352846ded7abc2f89d2945b18f903018bb06ee2d046f0646b6e1da1fdb45d8eee213a354a1c4fce78ed4be82ef0696e0a915da6b8bb8dd3bbd05fddecab0980641cd4fbe53e5153f92010eed04a416fd2a1188fd11733249bdbbdc4fb74497a31df1c12a8e0a6c70f92cca73d9ff83dada085fc0183831e03d1c567491ada57b9346ddc5423701156a3ab159cdc80c37dfefdbee4c4b7ab994ef971282a1dad7a1ec53c787f41d27b64927b41c6a3359b1e303cd73ee8f3561771102a45d56eb38be21d55ab3c996e2075478c587f4e09815286987e3fcebfee97ee0696500e6f5a84d0498b0780f2505c58a0b9f50e7d928ca955b06584442763cb3cc7903e4aacb4cc8574e41872ccd7f5dc6e1959a445326ac21905f36ba70ef7526b6b1d4aeb8c908203f7f0d82ac1be58f9f8931f0568199b5bec8a332c6921c5228a0ae2a466d31576a888d0c2422c416719064e57f00ae19c9bdea7b44dc060079d1eb98e7280f7b3b6c29efed960c11fb8fba25a6d53675a004853a4558035e718e3b0ec6c8f6b9aec2010d2338332c3547e8b44d8edaf9bba1d8b04f5e675c95f2a725af6c6ca1dab7efe9f0909334b371c3202760b94b013e08f8016e3564cb152b38ffdb91b73701c21ea2a4e07c0c7a33bda6e05052f9b009ca321fcb00c144222e835cca3afd2e1f9b3195f87b00d2e312bd26b90364fadfb764b4c4f39ad4317942c3741dba1750e47c6abf220e998f5a6885d9d63b85c2557022639ac854564170dccb97cb2c5f27c56d2d4064112b78c9a116200064ef3c5ca3734d619ba7305e4a0411afa3a2d0aeceffb44a642879d465d101bc6661d0859dc33d30026f812efd59af00c874e8af97c92450f57127f1d4127e578a02afb3d0dafeaa219f37940858f3b89d2fe2a4b2a9b81d7be2318654b398278b0863b3a134dd2d7f54a1cd510a83ebc07b57ce6190515ea59d90c97f72aa05945ccd23094025c0db2bd6e0596fd8f7c8ede465651f81fc82a8c656dc31076b5b19194ce58fce6bc52119c8e02e96dd4784bf3862f593ad8f8c6ca827f89243c26ffa4f30ebeb3fc146a872d883f24d36eae394c051ac61723e1b64c898424813e86086a829ddeda0fec5ddb98e65f603d963ae0b017ac1eb2061b8c4b607d48f922d320367274806efa19896dc85eeb23f0889cf42cd046c19a383a97bf6d7f1eba2fa09df0c2940e48566b0a7b5e9085df58126b1b25b3a4a05cc85abe08b5c53089ceafa3b86cfb1ae7f492e8d1ffbabf8a749e25a80269afe2ea8c8f08c4fdbbe141b42a9a358bbfaba282dca2aa5d31ae7e3ca5cff4fc7aa79fb505e1a2d6b92aef1f3d6504ba4721f545ea4b33c48c3e8425495d2319959af29584445ad0b69a73eca753520d433c5bb16a8575460be2c905068622703f0006ad2e79230bd33049718cd6c6949fe38de66aecda1d0bf25148748c4ef68c231f26ba9c7c6398725251da90e302ec74a8a46d3b51e6f1b0395b2c4c7ffc5","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
