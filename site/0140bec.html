<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4b5d58063473d7959b06d689914b4ca9fafa0e94fd93ab5b121d76e0f609cadaf66359b6cb05bde7af704e35cc4649aea4fcf3f12ac59057c18c97f2c67f481589b8ec78a7c63ed10ad20b8f86704635c28247494c21199084f04cdd57b5e9f52984e9475079fa5425227449b141d87edece761ca35d37a7eb4a3065fbacb540575a39fbbcd01c0177a54d22cff3e73bcd8e7cf3c564db255ebe208a691d378cc7862c85c315cda7a67ca5c81b4ba811fc07719304a8f7b9ab8162fd05fe26b870e726082add76d652fb242f615d7debda526537a3ed2124c3675353b2ce8f9aaf91e4dc1a7c472ff65be0044971fc99d6838c6969ad215af2fe57f2ab6e5127b27a1a3f3ddb53f6bff4023b624e88bedca84dd87d2326c3403c386160e99f06ca45d897629dd4885d002ee15a53ece4a4a88fe0755560781792024d24d52da179f7a9922de67b71e068b1269b4591dd18d82d9a6fb9464340886811199d8c6edd5d724abd9001266834d442fbb87951efd822de43943ae9b6344ff38c8948697529853966962fa7929a9d3d424b8503fd17477bfd78b7ac14ad04f50a5492ba904a85d24726726aedfc59d38dbe7a0f58c072dcddc5f55b8ef6c31f0d61c286da5cc6b25748f3e834d012dd598675c38cb8cc239fcd3f345724917bdd93f8bf5e037d8ce78adbb943c5d26ab39c56ecd27cc1768dea6024ee1a218675cb4c4f219773ab46df8806a280120e58ceaacbbfd7c7b55ac9e31251414fc98fea80655ff233cd17fe2c2a8ff9eb5955b53b618d335fd7d0c9e656c975ce9c0c62105d6fbb7a655d58efbc049059701db2616ac41ce1e63c31f3c8f450a126ecca4f64c19ba1e03318415605f77162e2fa825882cfbe83175c2eee3b0e1253159b902660b2921d5b5a408952516ba491a8c4473931dfb0faac4ed9ce21383fe961cf1f6a07a48ba4ac7724724239dc0cef0d0e359ff31eb3035e65afb443e56f9f18ccb10ad32f08863215b00fc333a1a81edc0b8b44715b0369edb1fb1a849048b2ae4252cdb91158533e96985780dd82792ee520092e590ba306d4b57a109845813ff49db9c2cd647fb2a72e486ed7798dfdb77dca49b9f7ae4daae43141de842a2f4a69846a3ce6ff321aab0b1ba1af5c63b89807aa73643015b1ef2f0632cb7905da62222dde36b0679d6d70684c7a726dee0e641830cbd3ea98ae537b4736e421d0b9ac685d9272bad200ceb8ce8b31600e7e6104d5b6c482a201c8ec2b34f3181da88e7d5a6f99a9c2cb8ddde815cca0278febb1a304f053c0e59163672c22ea9dccbe545a82062d542fcacf249b6c7dd26349ec83d6891185eb8a761c6d556c7488e959a71cd1496d5af8767ecf09e306f432f52a490d288da224b10bdb36d20d79c14afa92733a3cf97cf11d3846390483f0a7fcbabcea76f8342f296f203fe0cd55a822da089929830cd0cfa00ae2c3e9e4e9b1dfa55ecc01c78bc59b67e27bb29a3f2605027ecfd65ea07e9b6bb76e192a8829225fb711b919aeb147bce9c74ca20a5527c22f465b7cc30e69d78c5316daa28dbac2cfc015c83a448fddb368167789d146f026b293e18bad7d2ae23d037f7df263235f6eb31ab7211781624aa192238fa593e4bd9fc3db0955b164afbbca4d6dbb3a5f6f962981cece6f026fdea4746a761fbb911db3c242856204c163e113c1514960d49375c9b8a63485b0f1dd7321fc0782aaab8f6a660c0215e23e9d9c07cb67add8b0a860d961171b7a8415df08e4e4ddbfcdc7050a50f492dd7701ff2e7c83f8f577a95cf2bc2e34334b1d02681826f65fee8eb4e72dacbe4c2db398a1f89b64c9522f40f9d775a46ec7395c0c155c924b104afbc2a9589eebaca74ea811ac996335a45cdf98d0dc0ce313ad384d5a048944e9ce6017f0a8deacc3d268bb7c1b56546daca523393d20d5418c4ec5a9a2db06b569d8601553cbd71fe0dcd1eb4d04bb82e3f7ee35b0a789872271d4d51df5ebdd7703d469cf817144ef8da1376330d509bae8f05b4d4def4e2d540e2721329ad23cc6bcf8e78d79e465e9f1847a04ac6c32728e0a8545ad25094a43a3103cbba174b51dab4f70c7a0a12f3bcacc94f95ea03a9bc69e75ff42342dbc04246ee5841aa02fc5dd03b1ddbd533c93d780571b17df6e82c05f94caa5d0da34090da26ddee6f04392200afe88bec5bd9b8c68c2b41a494b2bf236cd453fe3d5f0aaf083ba9e1b6a388305854758f94f33089b5d31c17183db19c2ae6182c05ecb52757c0a29267bda4bd3f2896f7b94efbeda9dc99e9d0afb02c6b980f1c34903c00e30393af1f03dbe7dcfb19ccbfe2f7c3fe119d03b4302cb75e4be16469c5f893a303f5e868b8275b8b31e25d591cd087dde781e0e76ce242d78345a44119743bac0ab5677e00d779f5f541feb3e753e00a9d39a919c94fbec40407c7467e4a53c96dbe72c8bfbcffd6951c8cf8a1e25aa32125cd60e3de3951cb8658714571eab4831af519687013568bfa7885e7703803f5638972bafa6794ae704352205d76676984db834241e3d9f077e83119843b9a9c538793849f1498dd9bd5d15f86441cb9fae05124bb6bcc087f3073f9d8ab179408128f4fc4302ad70fdacdabd05e77ffd2d576c5480ea3a68342593f7d37c9e37e9c056026b78bc73f8c4b8615aebef23fb26055ab36fec5926ab8fcdbab2797adef03956f40702070d435b8477be8199028b162f722295c00a0f1208788a4b56fd2cfd568cf1f94cb82b74648aea85b2aa2cee88bd2819c11a63bcffb9b6149050377ffaaf4edf8b863851aed547b47973bd81d0fe24090b65c4877d6e106ec10ae29d112f37a25fe3c39b31b6d802e2316c3ceeff5f4dadd736ec3cd11bb682a7f2b197aa49582aa61b4bc5aa68e30fe1384b13bf761bc352af663300cfb562c098ec940c3c8e60e75d6baf8e76278e7abc63d351094cfd8e1003f62b1b8ba411b2b1847e8b44b80f819d54858fea6c73eca9bf9acdbb7c5dafef4c7a5548fb49f2e1f504e257851311c6cc3f71ca70e6197b2fbc937474b418ff924da07378726fb5a010e85bce5957a1e2d7311ba0375713c4b438600d015de06e5b8b8cf4bb6b0cf408b643d6fe53359550c547a51bcd7196d0b94c22466a216ac6f8b0fc60a1ea0a85ec138e837375dbd3f8e8a1d3994926e4f2ddabd52e5011267d7b712f28fcdc0b1df2a99caf7034ac444306713479a691810bc909f53b77ca074ebfae88d05724e62a790e961eaa9dd3011d178897016d414ba875d0042b3ce3dc4b9ae66352528e3254c4cc42a73c3bf829a9ba6adf920fffc678da39c721c7dc8ec5a7404c7c0ff7c2fb5284afe493f68e3778e92b62e1143c7a5f87ce1e6dfcbee3eeee51195248f4fb8232e5f6e978f7a852716b2008b01fc2b57eda9de96f4044b1d99fce71e9669733b461cdc94ccf0d410de9fa07cdd448cac58c2f0c3ee61debbaa4cd02cb3039a763a641a1ce9493cfbfcb001a2dae132b23638fc88a269a2b0d47713e689fb937d81390742ed64b34aa53d1b15fca89187f912cc8d072d4574d8950117217598b080e6060ee9ed9edf4162c4d3861079ebc397c354926f410ce5c2afdc77258e24f4f490a84855c8dfb5105aa522e4dfc118f7b3551410cfc9f7c6fddfa3982c6a06ab3202de71f0cdfd1ad3d24f5fe7c62a13057410ca5cf8ae60723e78fa56c65e13027b7028af7d98a2bbac5b1bd9736b03c77692333c1f66c19cc60cd37f455ccc28d4919969de8cc6377781ae7f905ba6badd456a08ccb347b97bed0c2b0658dad4036e2768b642f4f7490b4ab2fe529ae0bd20c68783b0bf0c2dfdd760bc80661b942ff810395fb239d806bce93d5dffe520496f97cf7c123f79035586ec3feed5430e9d33104142b7b7d7edceeb92f924f47755f3249b3e77caedc8b886e3e36b56f9ae965914fb4e3b532eb5dce0169f5c34f333c0db5f4106c8a5ba27f10faa3724d4a5634af648e189891151c99e8c2329f94e2f2b8d4cb590770b93de01edfcf9d2cde67b1962677761bc078829b10357182fb714e01db699e348f56619e38011b5b8cba24f277c0fb56afe55651865e21a395812ed967d6c56fad465182f9c7109299f3b1f8c3ac2b36b3092eaf7f6b455c3ea050ccb9b63e2bc437595c91da230f0199f2af492e9cf17473faf623356955330ff8269d6cabc2dd8198689e6780da74e84a633b2c34e798d21b4bef1f092e47032698916c540351ead3c0d335f0470c2787df6677dafac51475392b66eac62126e1502b5c887f5ba3f57067362af9cce56f594cd09816ad34683b5fecd927a99d66fae07ba37de79c27fe489bd9788f1e0956f582917ddd59f184a6d1f066572faa1de2bf42e67a57fc00b1cbf05a985cb724ecd5f6fe29deee077d6c56bea0cd3e631929b2a8ddc28ccf161d2cf92bd0b4592ac7683e41de82316ea4d4f0f4a019e0041ec54d538d3eb9f4270ac0daa928b57635f3cb19455f23a84e4fcffee92d1afefefb0f0aa1f3261fabb0fe887266ddb627892755efef9db3c3c750b05622a89e663b6502ed3ad2b9e3e45c6cfe1d557c14644cfefe2caf5f21e29807983d2a81bee11aa24ad2306b47b1a8990f8b2a9fc2ad31e67b5966f571c9340d7cc569ede6344d1128f91d90dffaf2d1b7fc74ea84e6015e33a90c841f814dc1e98ae93afdae22cddcb8ea1cdf2843e990a8a198e4c64f1528fb51a7d2d48770dc8d68f3941d19963091244a7ffd22feeff9bd63176799b5ae7df3deaa90b9dafad636ecdd7ded2c8da2e358c54e673b626f47e476664864698ff573fe1798367189a4311e1ace4bc53420d76b612715d755c703333410ebdd5ffe10ed0cc4b3deb396af25e706df7e020aa37a9733a7cfc096a9ae37264911951848d8c3970bcba9b5b9e4f5ddd96345f52b55769cb938a6a584ba7964101393ffca7b88cd5c9f40a3866d55d06972cadbed6dda553969f9078026cc8d859dbcaf3eaae55f0f7b6065e2cea336469780fd6b26af2056dca4714f45da594f7e6df5b26ce806c552329aad8fa9b91ae346f1fdf4ada8dc6dbea738ffbb4f24b92d4fab86ba78c8cd7f850e49a2f6c94f9be033280f461f193e595b34ea7592d8647b8db771bb1ce803e90affe01481037f6257c30309c7de7992cf0d19bd132e68ffe4d38d7119fe966784b8f945bf58600c40d1ed1e6f5fbdcc61b9c5d66b1d9beb884c343c59431c345fd3819300686130cdccf6066f03b4d322f427c0b9bcd8a0ff5bb784cf6b646b55eafd2cbe20550f19161d30d85876fe3c4aabeaf5c61d5e5b6547285373b06dd7b854bf4180d1d4e3725b44fe04dcf71e1ede687903122ececfe272e08ac3fd4c96e7470c48af6785ad659f3faf04c2d9d3dfdca44faa275640fd0757ad1520dfef73c24685fe0688ec84049d858a85ad5b4717e75c77fefcbad4b0c319f3242f153e7ab23280fe28790893018872ac94b045838fe98a77ab01e955c92eff21be053effe130bdcbd262a8c6359e0696f0be3eb0297dabcccfc967f99e63d6f3a32fff6ae8f44c96cc65524a1639e71d08072031790e6a22de1265d21dd77a9bb19ab7af7d6346b24df73115734cb166978ecd7bc40bd095e6826b84cd3ad164bc5b33a2533cbac8bdad07c4af7381b54966e20250416194d6656f8d48ca2923f2c16e2cfbeef0131da63be87491895cb4d6bf225fbbd688a3a45b961ced32f541487f0c7093f7bf175e04940030a93230e143e7c8cb58084c16c4a4d1d4820bc3f826d7ad9190764f6f6819394edb656bfffc10989b4fafa98fb058593b0f06b3df9a271ac71cce0624a9a17de0b90739a36a2c3ece1ee21dff65bb246a115c63f5e509ab369c90d3120ad275f855600589b30579a0287c2456a628a32bf1a3713c16e4045fc8d568f585ae2f076cf5ae510bc0689194caa0b4d9a2166f8ece46ab9ea4784994d11c536edd833d9d5004d19276a81e8ba8e9528106993999afdc7b1b4d555c2cdbeae046fdeeac7db142be78348016c320d2c5d8184fbf68ed371e344276c2e1c5bff2dc628829ea50c0854a78534278ff3d8f8c74b9b482b675eb36cfb385715ca5a7232c8f43d9dc12f0c122e06aa51c583d72463d152464829a7b22b0a5ce8496b0e10f29116206a87d019eeddaecf95d2383e57005f6a694de54c85865b74793def56e5a4e3902eaa91eef2e42a926a14b982e80a078f7e101bfdcfe5704140dfe515507b89abf2c2952fd91368fa14effd3d1d06ae65b444eb289fb89a108ccc6975501eff3762fe661ddc3053ba9e23527c5e791260135cc186a731e69708eb40a023d97fb5b4aca79a60dd9e373c5addb2217a20b07ef0e14673ea6ff6f7d8a3da68977a24a35d218661aacc2743a787c318bee7f801b6f5a1a40af8d3479f2655a43caf5d35fa2b5aebb6f7fbc91a831bdaa35fcad6bfabfe49024e67c8dfef5454649bb66cc309fa1e82c963ee344567ad6e1cebc9a40c4f3fa44487a3f69acd69d9b361b87465d93b3c1d69198a613b24668cb3fe365ffd5ab9f7340de8c044f7d6352594f3a3cdfd842ee7dbb913ccb3a50c04f1b68dbd9308edb428d63bdf7109214cefb33b16707d693fd04cc2ed0f0b07c0a305244153452bc91f0c45bef45ff741fbecf45ff82b8ec784efb478b42d55297d6c04421728f1ab8d6e905bd57ad9b0573cc41a8757700302b525f9827e2702c7402ad08a7f3b28d86d5ef981e1b04cb5a99ede889546af18471fedf608aa9c7a29f40078b8c6565223a644113a05775b2d5501075739c9a7f3741b8130944111fdf6eda43bfd9c56a1e8892b83eab7f9443d0f930fc5872f8c55364701bf5add1ff9a750a90a6585aac6a452cd9971240f206d78eb1ee628a3554446981183bd7690856165ab2baa412d4ae32f43bef703f7c97386d26a7eb01adf1b2cac34bab33c0dd55fbc3a5947133f9c3184525b5a52bbacd303427b6af0c5cbcaebeab9f19c88f3c60a2fc908b258ec7405344e549c154935d23db097db12d263f3b8470df25ba369412d887c7371f759002f8ce0e3a9888065d8edd3d5d82d49a53a794119f271379471ac9fca3d11ace035c4d4330c4e367daf0179900533b8f6d616dce41e2d21cebb617f7418c5e6fb54f375ef3fc6fdcf63294eb277714e768a49b642b13dd641024b3fec17f01d6778fb1d22ebaf8efc70ad593f66f827e98725146efd97af82ccf82afec933a252d31ab09820c49984943a69b1d1435a5a89f610311e6067f1f96e6aa5a7bc04b2bd1fd579f801331591a6005ce291b13812caf844388dea25a4f8b47224a089e61fe08473f9a462f1c98cbee1f07e68940b7e8841227ef883a74492934e9277a1428e88d0c83361dee3a8a653970496c9fd507318557239848561298935b88c1f970da4a983b3393e2c8845f71a15decb921e07dc5b4e483cb89cfaf1bcdf8ddf7959831ddc1d0c65905ee45e698f29658d93e860defc0f4b42e8e7c75252b33c0bb36bacb6f3b965ed5322e260faa03662d956b7c20650b2a7cbd61fa97bc99dfff769c5423e142a8608c7122913f9c876c8e7ab844f7163e23c8601bb4ac8c92b539af88828c801986976e7ce94946f07f7da1a248d8ab08a914d08d82243476a7c2c5513b46447167eff0555e41dc64b1ad852a6a33ed182676e87c65c04e72e6e87488a3368f83bab6533ccefad9ccb80681b2caabcac7e7c9dbfcf4f3cda5225eb4336745bd11ca96323e614c4b1ea8b1783b5a0fa0a217855f8f093f0ce375eb2976b811ede3ad8d007d96b9e8d82023bfd1f63ce12e24184929ecf3267d5ce581f2f4ec2a364bc491c43666cf908afb110977d6bdacb5de6b8c5760ab8a8f830a7520016ed68fb05dbe937b8f6d2b7148a9bc50d5aed799b0ede0c19ff463fd726478d73b5db8ba2032b77c248a230b8184b9c5076a44f40fb678184ecea24e500d0e8f7c62b853a6acb6554bf705fc5387a4b1fdf92b87b7162aabb781bbd0484ce7a61586f1dc99836498953b79aa94078ccb474a142e1594cd2637a6e373e4f94331a05985b85dfa56307ca85a33ee0b081d66603ee222c37fb6c883f70e76e0a13e6ea641983d894c1de8b28aa5c3036b4c54e6580c10ddd67edc2df95094e7bc7ccac40f8e87273c901a6bfe02fffa8faf67f19dcb552fc195ae06810e1389bf0b3c385f296c1b3bb21f7232fd8b4ee2a3b9301bc7136bca3ffa8f3530431823dd4a33674f55d351a1c06175cfac3d578e5968ab0e9ee87dc624f21ae614a636d0b87084fc6cae6e1de026e490f1e7659e4acd539b4830ee8c7717b56f2f16b843a54cf46fbbd35b034ae3cfa4a5553f0da545fc5f1b6eea50b0edb0d25d7684abe4b6a04ea9a537745ecd38a18c6353b0567d0d654123195106cfba2e67779b49f563c8f9639463aabb165b50b85e36e6d4e0c232352242111aabf8a3aa802163e332fc49142c3781758b172602365d10e902794c20f81e4994fd586c3bf4bd5075981b59d00d10b57913be7490c481b9c3b22af052d664013704f0f88f4e6cc28b32b24f1cce1d143822db088af5665ae0852d33a5f6b85a951d99ca9b63da43213d6b88b62db0f6dad1d853201fe19db2b6145b90a69630b2dea6e31cd943c6200ac16302c76e3375c8429607f28255597a91fbe8905226c4d393329ffecb925a65cca9f2e308de24be2ceb051cf29fb1aa0cbdf9b9580873e92d9b3e7702515836dffa1df891de07d218f948f12737b0608f257b4b49d45871af767a424202d9bdc066100a7eecadf301f54057ec2ab492d58cc980047bfcf9774c85cdffd993ae9520e17fa8d0f1e06736bd355001c77e2b4927b0a7d9186d4aa36137229dd0666b993c8b18267a42490aa1083433c0806cc9186634f037180b02397e914e758c25409923caccb96cf19bc8c88537fce50a54edfbacee51b7b6c364efeaf4a2fdcdf69b34c4ca1be09ead589466a9df0f691fc46816eac846c7905c78527f0c61e6fae0fb61a3c6e07ba6dcbcebb4b502150f4d4db699179cbf22372ba04e26823bf4b82749e5560d94f03af90b526cd0497a92414ad5a80458edb891535c1dc5aa7eef000520db077f8c25c665022abc963e0a594f3a9eb8ba223cf8546256ba0c98f71bf6dd43020b654ed6da04c64f9c215035b6b461990910fbd3f1d1c4f33c0450be010044c4668e2ca2c72d9e4d80cd86b05016ee442143adfc04697de5fcd105bcd6fca88e3d051c97b6b0d26e7a75314bcc874776fa8632cb64329f3d691e76884f7882b7186348b39ac7981a284fa048320de473513123d08a0af5285e43b1dac48a3e523adc1036242391f54fa81b81d53ba96f13690052f8a3d7d797f730f254259e02d14e21e14ada78f1b7400d37487ec40ea10d168c645652e0c4aff2a872529039b0a5f34f10f043b8332ae47efe49cbdba963bb0470d3eee794c9aec419632788f3afd89f947329d1bc3a3c322368061b2882fecafe8d06ec7ba6b7120c4544d013192e58b07197064bbb9c5846b1086057abef6bd63e0c01105df85219c97c8648a2cdf5827d79ff9e0ef94759fa68e7f5c65cb4b31e79ca1af115465c4419b0658a2691ca97650bbede3f801b53eead329659cdb29baf51bf471bfe3d74dfcdbf503ea7a760a0b900338a11d8f9e3b0fad4fc8ba81406ec0405087f6ed57d870a6ebdbc8adb61d7d05912f384efe911679c8927241cbe3b14279259fc01a67469c636d137a03cddf9da7de2830324fb7277c2b0a7593df2216615a34ec57aa297d0f88cc5b7aa060c6edc867b0a684ce4ca5c45fc77aa6c235f413c701e40fc8f95f2a7056721c3567a5b31fa9eaf0ded294d18d75fc51a206012ed56cc566bb5df95cdec2a224b07cb7216fb3cdcf518f7b519beb6441f83e478fd67d9c5024af3cfded6ec682019df048befb52ae66a46dd59e771e23412eb2bfb01d26209f328a1a764533111042a76eb1e38176716df8e7cd5fb06ae14add0b9c77d16296b7f6224874b1f6168bd9cf22f012b43ffb458a49a18aaa0d8fc02566f78cae43611a157cc657b85122af1ea78f0d0e5a6f4da5e50aa92f5cb4c722a32a38c4c3224cd83d338cfaa4b137aaccc3bcdf22bbf29b20270a4e66b83295468656795900f48c47fd1343319aaa80618121736a33acb661336701a3241ffd1dcdf725836709fe6f54c5b08312adeebf959ca3b9e51d42215bd0eb5fc2a703abfd7d9456fdcd69a304683b591b508f7c9ff2ede0f5e2685b07b9c2257998435b76c671faa0e5b3950a3d94f3c699516e06d45b61ebb94095bd9947e96e031153f77943b85193fbfb18232cb6bfb24db5159f0503fdcab3ff7bf8b0e7bcab5ed46af8c0016c58808b51a50e1c4e155971ae7fd2359c914f286cb1139d0cbf4363dfa0b78785736bdaea25659b5cb6bc5f16368baf83341d3c3d959d1e94e68692e7c3eec2a87942e7cd4ef5444a04688ca6681ea533647ab230d9a2747e1d2eea89edc16144fc70e66425dd3ae32493dff3d65f9ed4b409b8fa3703a326f9f904a56964bc54f09a44128c1bca5b5a364547e60af5f79836d49419fc1fdad0a1757ccad12bcb6e0e8c775091579eacb6174f81dfbfe75846402efa99c4af09e1d0d7c8e3cfe29eea07837041eab355c0ec11b503051fc4d6b8c2ab7c13217c1c7db1e27a25324509c16a9182390c688fea0fa0aa7906802b696ec45e71381ceeda5668cf67515c33b92645e6a820764e380c4d0ede9ded232abdc9de53989dc2723593f4e90e5b0757b2f1b7d2fe40829c0a59a27b608e440c95bf96050f5362f31e8da0b4782ce54694d18605caa937d4460c10dca95d92569e67853d4b306674e400a71e19a6366e25c90f3797a8062f1e36d4351022b43010502986c44732eed763637f7fc8f4b25346242d98582a862956ff9b7f2a2ac86ca5c88119359e3d743b0edcd9d3445232f181d10f49ef460c2b4d77df58ffa552905a5f554c00067eb5a80dcfe195eb9b28f0adcd377504f476bef264aaf9513de4ec16fa31edea2aa7a6943bc3e8039996a96296bba7ad3f9ef2f7d6725e42f4d969c602617d664c50800f58cfec9049d620bacb1ffec23ee2fb4b80cc9bbbc5dd32bfa2bce44755eb2b241d73eae0ed44d16e13b79973f698f162d2f3c9b68cae90bb547cdfa3724300d5c3582f475b90404e28129db91ed0678fb587c2cd655df5cd95809a480060b5af9a60e0759138e15b9d2c6635bec5e92a9b3686c4e3479cf71d35bc86d4a79f58af044a990e2dce8a0ed53e886b0203dfb55a4c93f87fd43d3fe437e2eb7d2466d993a7d2ad5cec39547f2c83d89f33169ae6a8980dbf8d090e14261a4bcb2d3f78124f9d26237065563e0683966f36ba1f34992789e962374f35815a9f9e15af5cd4d8448ee7f9dade60a360261fa271515c1f7b0037ff70d72019dac54844402026945911455083d4bc18ea6fcd18057907006c235dd1470e42a0683ff418f82b68227d1d3577c919798e211e86dc8387d3f456cf057343481eac3827248b6d92108297250bc265e7e8507bc95b86b5bfff1953a783302215cce243757791a9328d98271862d96b11a386119591be2a156565bba54aefba4ee3a1e39cadeb4dbfe8cfc1f1d834e89d83ba2fa27a102d2c257e933b2067ca036f69923592222dd5f775aede7723fb1d5c03f64750404f52e85d2e98e8f99ee9e2ae644c32f053c007acc7d0972c04a8f9b071d60fa2487e2e2798be57303689c53edb1cb5aef3b52a78aaa581b6c876fb6df5cd173bc4f59ae18018acc32fe5f0eebc1b1cc4d592a786fcd281b96229771c4ced925f55a79499eb01ede3f4a0195f520dd1c2b0141154c2f0d869fdec6b2f3a48b717ad3a465cad9c725058ea7b5c931463e5a17f3ee0597296de80e11c8d965c9e7c32f558b500debba80d051b07f89595e0fed9142a7c0f2b6b768e72f797540a0e5dfc07cebc7f6cb1fe8b26f3a323ede77b62773e45edbbad1cbb72987a3f455e4686eebd781b8543f920ad2fa4ff24f9f4f88dd768503bb74e9e162de21465e6fc40bf603296595c4572ba7cf9ff512973ab8dba22a590d6f55b4a14b95ad422639704d63b9fb218ce28e5672d5575e368c55e1038c7507d792ce350f5bddbbb01c248077537ee10c7831babf0abfbbfd6f11f3624ae4cf03be7b2c584f2eb4e8b5e6310cd8adb1f3471ed5e8db1c8c296f7edcada28115067b3c7132558399748b188bfadf535944e03293be87f3741bf311cfddfe67998eae93a36e2c62a1fc99d3bf4e269b304a5949ab202a05e4b6f64e1e4295922f2a944a6e4294bb4ad9143fcafd55c890a80a9372b8dae8308c2b1db91d71920e6c6b182d639423606009243d82b63dd7f5973baa3eae896f61ea32d89851684bb5bfb3bb60b06be42125182e8cae4d4b3f339432667bad94230c89997206ff927d1f27c12efdd267339e3e3d6cd9c5cebe196b3ffbcd0bc23a9d7e3dd227ba6a4bfc7918dbf7b502cb8ab0109915c304b45e624235f3a55bc278aae61df2a3d9eb4972d121925508279431687ba52a6abbfabbf43c9c65703c22e36b26522c561a22f37815305a14b01ec0cbaa4f52f5bfde845de7212f3e381fec67e6467f43f8fa88403788e716bb533347d5682d2d5b4eeaa6e40e92f6729ce25be03fb35be228d30bc78ece263ea3691e6e19553b427f5535f1c88e67c893b54c8fad9cc9cd380dde11686189fbbfdba7988beac4eafeee5585d0de94f81c8b128e291392691de0ad5927f302cda5e27854e7ff8c23997381fbd814b9dab672c6062653aa4d59da93ffe5c53230ed9463d2e8ea3d1ede142883ac001502eeb094de91bcb00ef4ceb4a34e38f6253b568c1f3ff36c5ab5e59c5d162d7d071fb70343198e71cfcd18fa19a5d07fc6","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
