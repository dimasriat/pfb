<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cc56b011e5872b0c641da24fb43eff4f772ad4344ad9538306d55cc4e2e5bc7da3ce6ba375fdcf85f61a8861f4b1bb883b96def46bbac2f358da62f6f2b63a54673a068e448cf6ff0a055048b198cbad1413360f972a3ac8bb418b3b81dd5cb9ee18c6f812d442401db96d7938363e282cc58c301b906d7a9a7d8adb88b05e4b0d28f2fd2b7ae62909d6ea1aae7aa02640afa8be5d3b24cc9c879bf124ad7daf83d16369b17320ba3fb6234ccf458bf527c1472adefff5b7b70c542aa99b9c5968551161c81dbee100883e69f69ff6193e777fafef4c478dd4fce8078139d1a649546c685d5008425ec192d660628ca752cb0f4de647588d26d0e67098b11aabef864b0882d635ea2642b55c8f903148ab7fb2c35365cf91aa7c0d841c341d51afac5a38e824c7c4ee90247b4be2d31058b8dc36357c0fb053bf5b0bb427c423ce4f2fc2976791a57b62ada0310f0e13b215547dd6a02397eef8fd7b53ae7ddbbbd2bad1a64a56b41182b03bbbf255e370e89c802b4577139f88252186571195973d084c6d5761cbb62eb0928788ecf36fc96690da579d768f83921bb29e92d1e561464b5200121a6e22b92ec0b3044099671dee54b3850cd6ada1228dbf0e29563c1898fbd43f1c19a3e384e32e9f39cb446eb13cb8bb406f7634f83b3a81a3d5bee95cc54492017e958c1ead139c51172c8d779c501710c839869fdc7524f6aebc5f882b6b79fb7b0df8c475a42455c23cd1625bd95b91d629fd5bd28450aeaf46d467273be79c10eea4644caafd8d033f5d0325a24e4d5a049181b83d9ae0ecf1fd6c79ce0cf85ada00c49e711ab18d5fdd25bcf280c2783a0fb487dc99c9638c45342a9756c37d8b76417c64999e1ced74154d4907f74ead990968d9e92813b4c7cc030bd6b794debaa2b7a97d4f7d078c8e1be3aa657f10640d3de31426307ae6b98b4465f3f5a0336708be414323316b65670f3997b30e77268f2468a115aeeb673a5577c7bc5ae7989a2656469219a882b306b42c6ac6a8322cf19fbe36041b69265ce177d37dd65ad7b42a3b2b579d09c7ff33e8e03ee11c89dce481aede8c65281a93658196814d5b8de48bdb4a40fd69c81fb0698535b86a9fd851c6d4125a69f51ace077c399cc7f4c4de14d2f6a67cf41473ab579af0b9371e42bd2cd930d2254e8d600bfe139d3d102c70ab179359c89a8a4e7ecfc16c33176a302003594d366cc4da88f06b881046191a6dde318d970e55fc419b7c055c6e688b9c380723f891d444fa141f9c9f2a7d34a141be2e2f17abfac84b684b1fe0d296fa521c5a4553fedee5ffc4fe7b6f736326c28b3f0868ba1019faa8aa37d1e423cea213ba38087531e795a6c3dd4f9a1e8f506a9f37bd8a8632844af09aa5b44bdbee9311d443335c08afeb58ab2a9688a615258f42305650abc2d6956e5bbff8ff39a37394bc1a9f088bd247c484e88bce0963e25e7bea194e025fedf7569e095a8122eebb60cc78edef5603a1efb3ac8d639aba13a8e981fa3e029d67b8ab38eab8d8b5e38b297d7ca07bd94ca0516945d9125dc45dfb0495b30e242cfb50959907770ea1e9886927a161c2ac6c7f228def1e68d8c090971e6181c353934370bfb0db3779033b15d61476f09491dc2c4d6bb897f85b5e3bf0b1a6cd06e56eb8812ef6c9baa5918889185d2fb2eea15f6ba7d57005b850e15f917de47cd83bab44a02cb3744fc23c4331bfcb8cc1fa5c90cfdb9a462261ef1620bec02570e5bf11b63d0186c535570ec762d561784cf60481472e9a168fe7fb7aaa7be7b176945d96d07c3da9b2625e61d46245af4c4253e44a769c31fc406c43dfd98f575016cdc188b0d0b8e6157d825651177789be5469b46343f3245d65335c5d73cfd842bdc01689eae6693ce1b55481bda97f7bdcc85f6783a98eec828695d8c9aabeda95aeadb088c8cd13c591caeef6c0c43bc5b182b91e795e2b30ce5960bd422da08bf7163605bf4519c721eb830cafcd165853b3bc0f5c553adb63d2fb4dc5f29f888d93389ceaa6489d66662fe0a35e2f7bfde0adbb0270d3dc042360cec74ec82bc49c699f26890294ec3c158adc6d48caa949cdb90927773fbfb26647f04e4ab6c409bef24f3df3e6a7483c4ccdddc445e80a6b0743256f4242e91a9b5758a64699cdd9b5c1bc7209b519c983c32a39651ce787ba55f5a1439205fa5c7b674da3e8f12eab3049cac702f64c57ef9ae26e5d6b0f6c90be599da1b501aefc08cd29e3eff841860a4c70169c456d5bc5fb25023f12b5bf8fbe851c4ceeeea903922473919cccbe52d657210a85af9fb2c1cdc31408a522dcc6635fa925666d29114830e3e5a86aea4dc707d7b7647c07f000adf30b433a2efb714ef0d11f795e64570cdbdfeb212ad6332655e017273ce042db5bd4b7e9d39796d4f3c0373c4dbf822502d61432dddf6a12c7747dcefe171c39032976da874b2a19c99959313b14307ecc6336eb529ca4d8db44e90b0a12c5b5525b829d435148cb437ebc66b798e9e64605e44fdb6a10cbefb25ca7bcfed9877a01e80b5dabc45b4f81019fe1c21f42bd0020939cb7cdb75dccccca2442d6fc8e707e42a5cdf4c45cd54bfe42d0e7ea84d73399f1aba02035248524dca79b8b948fe83cfdf185e6da624f43abed2a8c7df8458ad1ea31d211cf02a646ff5530d904951d3b33a6a8f77a611e30ba030aa3fcf7734302356ba31298e1d6bc51fc405b3479237c7c41a45ae0fe293f4e0cd0ddb6e43c7f4ae26b1cd8450ecfdb66a9c8efd8c40050b8cb29f45aefe2ea561d4df80df55c6a223b0fe158507d2cc20fc36f3a28c84b9e8d6dc3df866effe1dc4957b7f7683ac3c4fa9490d47c109d789c60230da1c5d96ccdd1c98cb0f4f9644acdca62205275e42199ca1d74a159e9ada8c1a6042700d25f5df2326059b44dc8ddefe9f24257f5388001d667bd911b0fb5252cad3cab220b3f8a1337c3bdb6caad38bf600310bceba60a4419774abc7f76f5b656db07ccfe8f4236f165e11f8b71a45ecc61e2c56d45bc469a52410e5f111dde58af2daa6e085acb6d5210c3edcb607fe9d87b01d5d0947bebbadfacd975f8059f9444ff38c4351a493fbb1d0918d138fdf42125556d2816057fbc023dbf19b43bf4b39ba0d4a6fa2b058e92fa4f1da0c164596d8cdf06873f998f2afd82f71825a316561176d380c807aec5269bbdd908d7de19bcb33504bcd3ea02c1ac0d13116ae2234ea725f3cfa677f66e1dc73d3bd25e810cd61ff0c8a88539b98bcec91ec691c77bc86d2fb8ced66124eb530e040979196161cf049ae7c81cc09ee5595fc3556914eb374747185d131a3154de6fb1a172a1b9bb207b4a6038bd5cd3a88cb59bcef50be91e5831d7fd626d5a346b9bb9f1b5e4c154802a0577b7b8d9a2b24a754a4c591e0b025dc8e5f0497f74613238c399f341416125d9a5db7d5273b47b232809316a0d597fb141917bed52ce543e42a96cb9e5d69a5217b30cd37b7672774b6120a61f126519b06e9599e63c59aebf4ee190a886276070114894aa06d239602c613db799e76ecf7fdaf7c04ca86cef30b3afab9e2256942f1fd4636e972804424eb0ad7a8df94dc7ddc652b8fd7b8b761e6911f56b6f1e1d4b5a487186e6a5e3fa72f99480bc3fbbd3baa96423b03d2fe96367204ff1d783626474728adbb8d2fa793019b9c9b138c590a8d1b5330f5c714853cf12ea3b351372070da8d5e0e7f9e9dc41b039cff02f38caf66951770b0aeb70f2668b08afbdb2603b4c003f70e61f56dacda93289c8b44cbeefab7190c86dee7d99f083dd83fd9c9740c0fe77a0e4abbc3ff0c52ccde77462d73603108cda9da419177dfafe0fad4d497ecf00701b12afb01c7f76423ce5eb0a63560bac5bfff700a32c642e4d7a7ddde65a7b088d9eb99e8f48fac93b847ccbd846911a113b91692c1f123d3fd60d9f71fdc2ff4f88c25cc9b707e39a5e715509c9e5c5ca78e7332a36a60b8975546dadba2695685b747a6de543cee45c1fded3b242ff4ef9014098c81805a9d4ffb8367ea310d16bc057b96b041a48c5fb9a5d492d781c0ab636fd28d6fae187616cfee962fbdcbe15a264722f14b470631eb0aa66dd2a06802053da0e5b9bde698fe77f8d09818153b3828a7321c0ff7e83c3d4813147f30731950660319a6dd894ef0d9c174404e771f362b99c2c4ff2bedf0e442012a9fcc58111f3fd496acd40b8c514e567890e11fc9302ca02e25b434fddccc942babd3d1c03025b5dcd080c121688af52a78047bae89a94b4444db5d665decc49259c4a5d8362cd2d10c955623b58c3041d52181f4482e5b27ba485f7cb43acaaf33599b426f3b2a6b7bcccbc093361764fc5e95c27fb927949ba6310014433bbb822eb82d86ea5115fa3cd88841fb0b4dfab7102fcc8de6443ddafa4dc673f26c899a8df0cea1d0eabbb39634ad97764047b5ef4e7dcd918b6d0f6137099ee2613ef18fabcd3eb1069d83991352b94f9e8d252e20cfa0cc088ccb7eadecbafaf2ea2da52d95983c3f12b2df310224ef479010ba549a1ae76f815575b92a67a75d305ccc8a5eb998af70e1c591d775c433e33f35e2c8416d64f16b1daf2ee753e0f36f4c71fdc81421af2197b80526a6d7b3070d2d7a7fcf8d93e62c164e70ad9e3302984bdcd05647a21e6468ede55a97c711f7a166d6361127fe81d1cd01df470e23647eb165bda64e5ee79385b023c14e73f91a6adbff055f66bff80ed643d7cb89a5374baa38db40fc42d0abe64b5ca173b20af275319460a8e616af0d4ffa6143dcd209df3b6ae1e8ea60491638dd156f62d8c90df232a7c85e6eb50c5a3f15b1bf3ca9d4172dfc8a6fac433ba1a60f0416f342239386896779719b693aa1c0a03cedab6efb3de00dae45c17c306a70c08f3d88f9ad2e5840dc222f78db224a617544f56ce34beda3da4c9127b7eeaef08e8db0026a0d5feaba84dcf47150037f869c84e8ea9515a26b28953b929ab066e472c0e9ab190a0376238e2a59fc2f16b149e95f923cd260a805edd0d87c2017308496face5e54ec9014b4f9df905daed493f30265cff371ed945b87ec016b8c51d08f99a519ce703b1d4af441cb52dcb075a3bd33d6ece852300d0ad2fbcba5014a4b8e52dfd3a3d438ec8c7cc1f5eee216b46fecd9d14f76db6d4fbeea762fe910b52e69a99c8b8e2b1b4bb26fe9c86155603eec2fe346bc793fcfd6863c4b2b302bfc1c3efca70130f6bb8cb35d9cf0fb6708c85f5e844dff7370e5fb0e07cf93bb3180ae58ef12a81e923874a17848e6f83b901757e7fe372703c482c49304cac53e4c261e19806a6dd497b2ae48182fd2d2cbf5bfceb76c7e052e7410b24305a0f73509b786fb9d960650677d866455a07dc8244847085195ce8a8328c3918bba5d21c5690d77091cf9eaf21917a411bceb799d0e58853179ef494f699b9aaa4d1cf6e2acdd3882a7085c354a45d8391229b12ad352d1a2d9d2c16533f8f308c15c784bfbc3f9e43dc8aa539a678602b795b19ed7b155635c5dbbe6fecb618d45f525f357ec32649762e225eb4f894e22117cca8ea9ae0137e5853f9601514a0670f42a50030c85d17cad89b15fe46641822fce4ebad35b638a4fb00f182485deff14979dd0b372d2a332b67aed78bab7b6f74aece6ec21039a7453862c2be84b2710e8e79834331d2bd60d57f71743697b0bcdfe1efa4e298b327b169edcf890cb5b504121de42152a068fc2447dd27bb8779f0a01446e417d2b69d5b18327d0bf1ce978e5a7b69480cd11b644c5efdcc8df41ac4737493709900f81264e090adddd40c4b427294eeed53c587c075342c7c8b5e8ea052f370aa607a01ec2f40a3532d9b25f3e3b521bd39a080960f52993940df6a5a2527f7225a25aa277af1f8ed410156cd97ca3c90dec03f478ec6344f51ee59746e484f184f2cda5d233def55dbaf94b381b0333b2472ec86973b97cd1e7b5bcff441a45f0ce03a7cd00e5635067617de7c5ed1f91ca41bcf15ea090a59ef22c4d4c7cb35194c1f65299a2c25a9560949d90bf1b9235739c3ba01ef36b2942ec2022b0b1809b29f0834b0451c75c1606db62739d3b48b8df42c0e74e497b4b83ad71ad779bff4ee8048ae6f5a531f3ea648fb26a52b203d4e5492d5c4af34b8aaa994273e7569b46d17f2a2ff204d010b090d45a686a7cddda94122a81f98b8f432ab83e29519168f0bd02fc76352deb700b66bc68a826bdbbb607fcf109262d63fa965e0167bb0450f81ad4995fd7d2b400fb6ea21cef8accd26469c94a21c9328712d53f021e9fa777a917cf440828880e01eb43795e5ad334d00d3afdd83ed8aa8a23fbc8103a4204ae7f5fc750e51247f3d33e2495474c983ad26bd5ff23282c06cf128356189603879d7ac1537442ce06871012279771c6381b2578505750a35b0ab03c046ffcd5f67916f7a50d9c1b3dbb43384d206396d708caf2f939727471c67424cac89207f66aba6ac483770ba460ef567b060b678430e051da73db47df95213089c462ca6895f0c476e5a1b867f4153de1b0f33c45b21db2eb36aadef52489301a1882e22160800c526b1da8e775215abe045e10a22d7c2d9c7c3c28bee4a1bb4ef869cb4f4ed4946ef4a780f43fb7974b4836d8200e413b021a83e884ca061d70097d481bb953e20cc1155bba056f5c8ea36e3d1b3925b2591364c3b45b52a72ddc5ef0f3075a6f87655d72cb1f898dcf0cd4d2c040868b2cd3e7e005a71b3c7c1f4761b3fa53b0244509acaa76f964bd4641fffd51a816ddb9138117f2261ae1a1ce7290612481ec48b2459cf3d9bd074fe2dc65a6954cde5b2acc7a8fe8c62d1582bb6385bb8073de3cf5261fad3dbfae1651d760c773193857c4b31a5cfc6f70006d40f8413d1930d528b98f363e9280d0b33eaeac690f4db29fc1da985c91820adcc8719d4834095e68598f28c864f44ea5e5f2dfca6516bcd6a2d6b7fa17c2f67d8e41a8b2cafb84ad33a28d3d031fc5220377a5c4f1adcf4e78a6babe39ffcc931415b53b1c4866db95ca9ba5b97de175e86b599590a1f6c353ed6d79816b18d876704818fc85439614e23e3d2f64aa4a0e7d0d03bace0eec9efec40c45606918a2f7067ed35dfc182ab8e05bf7d1a0ccd83004164f10ced5300ff1d5764fa04d685d4ab83005cc6d584ac9fbb61f4bd170e596a3c0e7652e32de78745857e4b595950e7d28c8c13b3ec49ab88cbb5a6785e5a5a15309963445492f4c563c5041eb8757b181baacde9ff595934faba50a80cfcd24e5d0691a0521ee606e4ae3d0166d3ec0baa8af64f543b367a86636560cd901fd1b8f1ec87eb00a3a3f5c653c1693a88f211123b9379d7c52f73cb4c83a3a112c6a97505ee9b6736cae197e9ad70a65eb0aa5dd6224c6f517d23c6be4d280c18864c6ba9ab98edd614035ca8b254dc23b3b551f38e29fe449b0ed24bb1eba8a36fd4628a23cc8f0a3cf198f615cfa0876efd7100fe40011d39dab7aa2376b488d5ba145c600d23a1cb49ab27be438e36dc848217af0e0ab912b5ea1c3946ac8c6089747fb7116adcaedd0165b402fefcb351a73c7f84c0d7ef20458d86103638ecea40b6f3e2b892257cc894f5830f63ced7c360e48f8c26701257a8012635a04f8af4eedbc56dab72b7d67891f5f0e60661058a77a68d4d31d7b1a0214750c46a9759992532d48949319aa5c18409b67c6d203d62f0bde47728de47c6314fe9c012af3b7d310680ffc4d5daeefe355965630e8a688ff11e8947423e908951f1c3aaaea0ccfdcbd0fab78bd6a1551ee35f21da499cdbedc594d8825de217aeb63e93f45f0c8930a5a7c28cee126a2853f46f6d6c168ed2079f9678f25dcf939c0fd0ba487041b7e1a098a7d75e610f1d4439904fb6135850c674eddc0cd94aaf03b7809779cd256fee559ed497b94c2df5d5b7d0a2e92e3c40e923bb87365781b57a5f113adfac10dfbc5242222e63d547f8d25fe5f1a70dcdd895b29743fdbe5e7574f426a4a1463516f12039e04527e75b2487814c78d55d5b77900733d0a8b65c638a8fc7e26713a82eb3770c310ea2f8b808eeebed11f22230a8c24535771afd8220fcf4921b8f4ecafb3c0b72f25ad1e95779d7e15a865769505c7d72090f4ff28f9775cec3d12cc17a03868aade76605fb7b8425fb01813518e416e7d4e7a536640e43699d565542ca272961cea7e15ba0f60aff55437c369f3fcfde508bb4558786427f5a65f1640dd8ceb3685113b741f088f21c3c688264d03c57ad2d211f504c4af7b7aa1b0ebe50349b7fc659e729c89ec00002c56f2af5646f37e986a616f1117262f2afbdeb930b17cba520ee69003672ddf5712b7a124cead17d5d66427d01ee2ce7e6b3171bc578fbff908b61c913c43538552e797d90f057fa43345efba6dbfdd5625db4c32343e98d20b359fb33742afc6e2a3b6a7b84b63d296bf16eb5648f4143472e7a5a4b582dccffbc6369b6edd1d14dc52483ad48fed633316b2585b12770e32f7cb67c0a709a200de85753db87ca35b41a87f6523d84078bee3be2201c59aeb2a6f140ec31a0bd5be374c494a990be9e403605af7dce6a95bf5db2718f3cfc2dd4057d8e1a74b22974bbc24e7b7536bef466ced0fdfcaaa7351a12d59351d60339cb3ab20ecc8aad0c432ee8c3744d097e6ea3d4dfa2e41591a9fadb775abccd3c30ea956d1ca940f43999d13f234982c353872d507b7479228bf5cb6fa9956539ce79539784ab6f2d6536494e46ee081cdd8efcc1dbce1ed0c3f3f87a38d6476c86964aa66f13e60cbf8fe664e2eb0f0bd6eec444ffd80752e4bc7a1d379df1f7b5402753110a691e88134c6959f28d4b2ddb1985ad29ececa6c69a8c8e1cb7a38b987671a0f0e005b6b091a53367559bcf63b4e9a0d7ff513eaa59876f059a9e791830f47542d712cd28b877701f10cb72c76fa80efb49e5dc110d1130672ea866b15adedabec4a60d534f211fb7d7ed9256a25101a1f607c71c2d8965a61e57a0483ba1b60620d7f4033d732203cbd4a58973046c33e64bebede658f990f8c7b307e081fbf15bd6df8b863d5ce9182fb706be56735e73ae4dd7a2715520c6008b1a0ae6f11149888113b2e7c3d60996dec7b3376a40cecfcba3496264afa89b34452b94396c76a19bd4d0c579f7fc90a6c78d96834c5d75225ab55fa29bcc3520258d79f1a225ba9228934abc654c9f891fa7a82682be5500f20d2929449da27a243a57f7635dfd13577eff9d7c3d46ff2670600980c38800875b4241e2e08df54d2dac612716cc75bf8e501e241b18ef7d7ded741918a1516c8398204b248549f00423491a347e4c70565752441f54005f5af892c1921f02b51f91bf1954376f9ce2ea18b3ec3b79c90ac7785597c60b84f6ae63344415ad4cf22c332f0be63928749974593bce9267432486e4ce14c511ff4394b2613c8e9f60abf935e4a09dc4c1a2bd3cd39514021e3b3e4330926f8bf38ac15a7fe46e415285bf1b769eb5e306cea3fd6677b800ac72be409b67fba91fcfa2dabe1a4b7af7eaaef314b3fa1e9411692cbd4db55fd78872b2a2463d1914ab2f45ebc8dd1daf15a1a2dd774b8bc90509feb3989848634b56ff444d316c8a64220b3a8f2d1b5af242125c80eb8c9c6d37f9653be203218ce1b9e1edf5b0643f5e0ccc5b30d01d87c69b40e0b03a306d540f20144ef93988487e1bd8a45cd74a7c8f69fed1d3208c78d6ba42400e5ee2991127dc862fb70f458945ba92c2cf7719e9f0de6a42722224695b3b9491d4bb8c15938e96780fe5cad7ac983352bebe96215b9d1b90452b53a95c58c614949f8bfa9b0e257a766dbf165b08f884551b1399ce5ff97344bdb596add26edb17901ed60fba4e838b097d56670943a92715edb191e5e69cc99226ca4a4f48dfd95d43ef7c746e3430d251e4fac862da5df016310e0865428e377dc236f12f726798b20c386d09ecd981151e2e14e5e3248ff6389e3e7cf744d89bfb6e6a906f30cd9fb08d38b519536f4c563b2faa821421d0de7f80060a5c643a77ad001cab0ee233dad1dd42a23370b5fa23900a730a9f21db00301820cc42163b66307b96026e4b0318691c2213e4d9725b42405f1de8f0664d03e9b9f85673f67374024a447232ba27f2884630c7c6dcee855985f4613f985df2a337d7a56dae14b5d8dd46a5787516b6577cefa1c8eae012c3b3db83655861786e60c853f1b9a62dade4376a662f4182ac6a622f0f7e2b5aa5b572bc5005f2376cc4960c54730a0cb4f18d7fd66c5e458970357979f66354d5f08f5344ece6ec37cf2ca79cd0891e7f23c352835833fcde562583c36e5663f25ca677b917163f412b68221402f8f787e6584c05e8cc677aaa180a2f409d031beaa6dc302613dfb2bc66987fae160af9e694d1659a04b2b435b47d73740af3b3e29c438d69322f1467343f8519cb6fd9f452c45d1a1be13b007382648542f4cabf22c4541b7cf0fdd1cce689ecc8a27a48f10ada411f7f9356b387734d8fc6117c3d53ac0d63cafb96870bb4fc5dbf71f0c5dc9d38d1f01422c73269bcd5b4e23ab0b42f3c717c520f3e920e5a00ff7dc5376234004f84681ca58cfc0eb1e076c69bf901044807317afeb57318473dc9e4f6a28a31816a5a5489de6cdac6f0050dbeac88dba3e42eb20eaee71e7d5fe6d8d6c2cc66066573932fdd1dd419ab016144e1b05574ec9f063c503df3a41c159725f854dff52e899d388814f3abce6a985ecd44230b57c06de5939ae0193e6f49ea4ab6082251201f299328f119f9cb5957315f5f383d1946486247bd85aea09fd354baaca5319e5c6e97d4eebdd73518df68de16ed5783b1a147f2f2b19f253a2dfcc0956968937425889d41c0e763f097ff626aaf7ab728e65ef36aa1fe0ae62a7f2accfd028bbc8bb9bb76c27f5c8bf57b605d2d71fb31f1090f5ae5044f6329ace96bd17ba29d507a2991b9a0d757f06eda66d23212d03ef878a17b6e9ecad4b8230a22928afdb4090c4eed2d984ea414facb9a80e66c759f45bd69a8d48b801d97b47feaea051ae59f6d1942d4a91685ba4d8c85dab778dba8d340da70d549b016df76b2d762f48297f7cc0516523d74c6e73e86cb6f498f","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
