<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"87016c8209e3159cc82f27f8dcd3fa454a344527b4c75fa990a1f12f77a8e059649551af3fdf0348005d4d0c1cbe8a9a954d58cfc4f3e5bbe913197a050a6496c91ba087be6d9099144b187d0d0fe4944202951ed376e91d966cae174f2e13f5e63d6f8827652a272106c8ef569cff4e1417b5da64d0094728ae239198bea3ffcfc9a49ec36af4c48cc3a1dc12c4c9a9c5db744489a61f4a94838bb1fa4cb67bdaee217a4822c1f4785a8498a9eae3339f06fa45e479654d03401d35d86b29f656f2982c4dbf4ee08932fdc3d2a7d605994a7b67ea0bf624a81e0cc78ed5a4424c313533800148bf4140a24cf99c7c423caf28d54eda63ff6c9dc9b82a57bcc803ba5043a011e0d7ff66d7f2313ad44667c04b74295f07740e938bba212038f9aa792aae5cd3c4ba4e5b3a40bd58bb388341b3ad39f4e44a066afea58d904fc005ef6d0527c2b75cc7142b51fb54fefad8511901d9667379d7f6ee07f8338d653340a6bf104c4471563a742fb0978a55278909c310735e679034b8cf0d4aa251630b4c858be1f723ba4f828142273a6bea0342a36776412e25688801a9032b3752a9926a0a3902cee4b318ad130c2d5d5892f128c81814d243e0ed168db833e4878fa8bace4e0e66a59322b4f7809f7d9be11086ff9ce530a366dc1b8f5d74f264a377ce27431fb076549962e2b3f254bb82e1908dacd7951f2b2e26f70c8584e9571cd104d471d6968008ffdf729af0570b67f73b1417deb257f9fe452ad0765942e89e2bb50785bc105d92aa0379be7cd28610acccb20a2d3ba7198425cbf68368d4809e89bbb32ab08f96d2c4ad7d34c72fab15906fe789a0271392d6317a49992a065268f7c56d72a7bf653b136dab1d601d0eb1abd1e95b9e88ceea1f480229b8e6b435fd471af09b3d6dfddf6b0d55a937e22a47e0cd698c3c287582362cacaa53a61111cdebdd53256482b083ebe99084e3ac969cf9b4db1c5b9cd64e52225f171ef7b8c8932fc0bc0ee1e98124a04f9a0d50b67de7c6060b940a6ca723303628ff2a82d985b9f8be4d34fb1b6a3e82acbf776124bf66f012f90b0dc76fe190af12465cd2cc6b7a405e2625cda4b3f4750ff603ba8b7ef0b8745e8e731fdab1f5df4af311a9c03bf4be20066cdf9bcbbe903854d67495cae3b8a9ffc72f0509f23cbcdad147329110015e7dc44339663af212ef4ca028b88ced50dc5c5b3becaf80f5a8f76d003898f77019b14358fcba4895c9a82bb42cb0c69fb5d12e2934843c75db57b33525b91fe1d18a24c2a7190584fd281a1c2a40b8f3327cd28a8b74ac6639e023b05e4314dc18314a73ca5b0c58c9569356315eb6324a5a24633247200f3af820d327361d24b721d3ada202acaad5c2054977233a66cf51fc967044228a150ff0a275df5df4195ddce58bc99dbcd35397dd2f5184320cc43065a14459ad35be60369769ffe02b7d3285cb6be71cf4010638729f472353eb70968cfe96ff23a9040ff193116577aba67d506712790d8138a6fddaccfeab1ce1e96849259675a1561d57819c25140d4cb1bfb69b1b94b3efcf5428694e671cdf879a7b13cca98b126dc9558412d21e6a3c9ff38d782b57a8f4eb4adf79acbf77bf8589788e829029015b00e2e3702432614f3a74e9464e09387e21b859751d68a00305b6b162d8817b1d5883559f50007467eb66f72e48a63c54ba87109ce7a7ae5737af26c1f3710c65820fc4f7ae2d341096208c799ef9c54067b0558201c35b3c3d0c22bff11f3d4129c0314564938ff9fa3be93b27820553dc3163ad2c4afd50ea4a23f4553af67e800ff2f4d54d41e3138997fa530dfdd0f3a28c3b330525912f5b566bc4ea01b1ddcffc11612665b5b8ff85d2a8da079c970dec1e0e312b337a8273e0abaaf68089d60bb2e136fd006509f3b682cab2d2362130d6b9543d24e242f443fe2dc06c16522faf755146299afc2d7515f02c66e2c13a2400492195ae06d38e0034b9062575b5c7eeca44faf634ffbffd5df06a46dc6508de310eafc2e4c2a00e680b36d3f5e238e900ec34e06dc117c53587df1d1fdded580e762eb1e6913f8e0dddd8a949135c9550949c1f78cc5b985e83bd269588a90ed6e0013c358b06a4cd3470ed12e0225bc2d6a6dd721bacef3fa441fea725f14cd84244c6d86d24fcbc3e84c0b03e0ad544e654c1fc7ef5b2a1e3efd9ee6b399274122596d4708beef810c6cb5324dfd809334c83ab08af0538aebdc45e264a820ceff75c669a2625962e43049cab359198f970c73697e5845e6e2e01d3463ac978d9e250041a92ffda4df1bcabd62cc675df2a1c045f1f6525a30afe2319b2cb3354eb26a826f41d8ec954881f95c9d33d88ef064a4d23f59b9078899e73ffc8520011cae1109c44f0db438661ea7abe1ae7cb19425d255e76945370e7878d800fa28553430fef8a96c8d21523e704e2d04a770b44a8678a8bddf5cb23c2dd133079221f5cd77c3770b777904d8c9440e56632ef731bbc43e19da149668bb1adead7d0d26ccbb7fd71fd1a90d961cfeb3cb29ac93c9c27eb56cc69e0f5d96f248139fdfc50a25b6e77548207cc37f508b9d22830b830fdbeefb50c265142807f886c6385822c9011f5ff4a8e99d5366339173bf2e1e395c2a0315361c33f72f6f0c49860de5273c4a5e8937c72d0f0f69c4d23833b27254c3b12ffbebe8134610fa2820fe61954b5b49f055289aeb254a2871996a9c952fbfea5cf08e278ca10356ca92627483b18ddabe0ab5fbb4c68341f84b4dfe72e324dc800ca9da5e495ffdbd6a5888f722ded7350914b92430e473ce8c42048413fc609f2217c6802dc1f55f9c020f4a1945ae1ae4c90ef6ceb6ebed63de8512029b26fe784cab2b55787bf25902eff199b00867b606181668a957e80819ea43598702f93f49c4b1cfde321e52fa8c8bbe1939b28cf380a29dc0946640097289b122dd7c93389b10298d166fc4e36e344de8d32d2f3d2ece1eff02e9ebe7f942fd65eb47063d2b903d9f7e2f44c934b7234b6597e0a9b69cad4d2e2a7b359439c6567c07fd9978140d8595eb1afdd9d88883652eb22b23d31dac0808f72407c7dd4d994ba833f6df303618f81788fff5f58794ebbf17073b8472ee7aac2dd99397fb46d661c04426586cfad539a0a929baaed09cd2262588801acc163dac3d97ccb152d9bf9d8fd77159c6b2232af338cf296301d236e0832251ab85b71aeb94c731875455dd621ffda755f7357a4d67845e23023263f33958cd9a39dc6014e4a7f9b69a6d99f2c2728f4793d9b7ee597fddc874a04dc76a8ed71453724726d164b9c9b85de7c0474d1a96b2ae29369239d7443401bc6c04ec1f72a9a5e72b08c682328aab58c24b5af97dab85140762f01a28fcacaad576e6b4eb089dffc7f26a612819f663aa2541c4f4947903441079838386cb4ab92e04900a72e014f3cbdfddbb08ab98c953bb8e3cc12ff6253652cfb03c3d17e365d0a194662d93e884fb01e55952f7d62121b73117be72012e2b3bec1e993a1bc130f7079467b6252480671337664747b695df2596ca8294b3a56624d6bc867d0319c2c951582a4972a3f07601c51f122bd1aefe9ad310e0dcaba07fcf4752502043438b7bd39c1bd04296b6310403fb9b922372b22aecedf433683fd3836a1be97f266848118d4f2fa0d205ba10b3bb69a03c95199f38ac829495600dcd75fbca469cc9e77693368125cd1e5715938c81e53ac3b5337b1d2099f588cff75b4e69a5e738188104eb38fc6be66725051c54fdb6f29a461a8ce322326e188475b484d415805c5b652356b6c684f522a8045e95060362d813e381338a18707aa553dac2ccb6feae972fc9f69720f9e79bf86a68a2733fd778cb6a55b291a4bcec9a4e14e7d885de96ac07545622b9d743fa3977921b14bc88a6e0fa3fef19ae32b9dc7b59b20c24e9abf82cc357a8fdd8ac75b176955ddb493942d7c8f15c8e1017c6acbbd18314826d4bda40d06776392d89ea17528e693f33f40d58dd7062d78f46325a6e77ca1d046f562da14b3ae0a698073c7b92fe825ffc59f9dcb9c5c7bb6d0b2eea414fb6700b96ac2b7663bc8ddf7b66ab780156e8d8227ee5856617c2a3370479b5be9d74022298806335314fbc17be7513420d3c8cd4700c8130fc369faf6229595eae91ee9b4724eb82cbb1fa61f548cd182f356929ad98f393f03a416e2287d00674f0e2498575c118f455e0ee44c049b06f788ecb439c4389faf03de9564c02148031613a646299ed2f653cfc0b141a5b02d7ae4aab0c5b29babf89b7e54120f4600db72f6565cb940ec6fb12bf9a6ad98ffae3880baf744640c8a29a72b4eec0794ee3e6356b6c8186bbe959017392e50dee36d32111fb0d013b3241bcfc7df219e3fd73f5597b39bd134158478d4aa4215273e75aa7f04c821ef9b214b285eafaa4f5f0a0802a3ec094e0b4a98f834cc60a187e96c2a7186b5b94b263fc8a41dab712aec22cab09489851312ad57b49e16125486aaf14d885bef58cfb22204bde6c9682159713574e622f992f6438e3737cf0d3ae663905bb8fe144af3a02dfc6b9adab1cbd1a35421a78b59a1237c5badea6b863fae0b8df788cc00fa34862a3f5dab902ce59abd8a296f182918c15b4615f550728b8aa95db99269e0ba78fedbd52f1acb68a79f20bccae282c4ad95c0bf36a67bc3717b8085d3e263d15afdae1ca53570a30f3e20d240e7ce3923e797c17813b8627dce307e4fea4367607eda2b39cfc5c688cab8841ea6370f71cb3a163513fd4a8b9e7dfcc29c3b7c67e933e6746fc3fadc10f92ebc1aa41af95b6964750c31ddc15306ec9fd39297226d3592a657ac41f0ae852c274860248ddd5fad3e49a478906f1f37e6daf81c10a92dfd980c73c3b3083f905362a7de40c39ecc08b0fadf50d71d29c90f628c3fcb20ba4eeef4e08f57de0b93e8815595064b4bd628d5a3843168aad21256a3157e39c8138a1553eebdb88b78cf9669dbc9af999759514289d2bcf4371a4cd081cca0851e0a182b569c7ad00cfc7edfe4b4adec061887c89da6815c23176c8ec72a5de381e8bb8c65f2d69e40c9f22a569c62dd6b8a6d5595f3bda4648ed691cfa991219e50d134f33546ea818c4ee4540460334d43bb82ef668845b3f955456dc58ffe17d17f7b22f7156c6a60bc0ee1d4c1b30e164effe6d2fe0c79e4b32ebba44549910ad876075eea153d0c575c9934b3a3cf4e0b7458c20c478e78ce4bb23c111116cedba4a204e3e9a842494c0e9a08649b9d193224887fc941c5a75278d81e3fc868104c56bfcebc578051fdc5c05c2a06b401656c485481af0677ee6fd7d6a4558b09a240389f9be2a3e6b5b042cdeaad5de03497f15371bee6844b18a8b764b213be745eb1b7fb149652b2f4793ae5b455c8a2e71af9b00b5593f4927865cf02d51827f8c84585d638b9efc1ab2c7127676b9f75f3963100ccf4802aae9a139c5e980c4926c26cf0f858d184f50e0166182ab4e358ff94a9af1cf8cd624cc77e5bec09bb37a5ffe930a7bff41ad5dd0f4bea046f257fa7fcebe9c0e3fc59cabe1dbd097de590fa8d470a96e12b16cff807e08eac204357c5ed23810d46e16fffddd11b86f6c1bf449f573001097213492fbe0eeada355a3a77fbffca81ef597a1c45acd527facd3996c80af62b5913eefa1fd046e9bf2db1d8c59eca8a926259935277ca09d154f449958c200dbafc4a10e03c3aba7d46b846a82b4418f9f65c35359c3ad69a862f67f32c59a7db5196a2f48c0cc1a40d161d6e85aa84d8fdf8fce2234a664cb08d5bd9dbb8f67fc4c344c7c29918fdde89806f6fcfe7afb7df298b8f2239755bf5d54581abe1ca990509b1143c693a4cabebbe5d1d0c17be402aa924d823ef7c61f1b764b8a60601b8778d589c09e16a66a18d11e69e88e82a11b85101449ef236ccf18abc0c797a323549e001229fa4d4cbdc12a33287187d26ab84645ec1be79841eb7a39b8c2a83ecbb9cf8997efc83e83b1e8a3caffb28b43eed881e3d86e9a00b99d353d47201b058ae03f98f514ba73660829676b20407d19bb73f8b3a3a0403b61ab4904abd7054981aed57b33ed0a276a8f79cc94bff99fe9f432e4299d1e6e31a7f41385e5842a24bd9789d7c1dd75abd65b9c74b2e565744230b7d755eb65ace2c09c99e47780e759c6bbb224eec90bea39e24a6d50999b4773eee057993b007ddbf4a9138889ad722eb2e12164806e367417a91e42d616a0b2fa2062eae1c62b29c558b25dc11bcefd5fe76357983fbc36634f41de582f07d4e7f94247046db761279be0636116750d7ed37b8d58d53cd9f9f29bb037f3e6a3c0dff83c556924f0647d9e321574ceb455563a46358d6f1f0f229f6250d57d292f922cdd604be9098b1f5ee99dfda042f58d33c0bc425f13ee3bd1bec9f85bb41f1347f76d8c36cfecc8d20d33996e3a14328b0418448d9f2a35ad050dcb1f836402c168f74e48b2a861b66aec823f94db1828a33709257a8b560d985017db552ffa9cb0902ddcc79f40f223b94079552cac43119cc36b8bab7593c873d15193e693c621d4fd575cba11f00f74330c87f9b26edb104f8ff8e34a1a99a58cdb636571704a8be1471ddc6ddd7c6e9f5ba0451540b82ac26410f06ccd3f74ee1d82cff99759f5b48bc0932f75a42c6bdb4d999e149febcc75f2298135c19f48f93a5469ef6b174674172ead98eca9aafce07a0c465359e7302754774b02fc9cfda889fe45b01079b48d9fe2a11c567bbe0cf2b406ad60a7f55faaa2ee95ffabf3349ed62a6d3cafa06ae848d12e3063380c9cc1a364be2fca31786fcd81896612dcacfd826dec25c8f59f3e2bac2401c9cca40d803bef432093f387c36089f002175763b1b99bdbe9196518192fb8352355d7fa03d6e5a5a8ac47a4bb3143ba99ed58d389d499ab2c2a2c8f96c8f84dbc6e0aca868ac59bb64231456ce1ddba915962ac1d75dc7500c894b2d148da59ed5f76b91564b6da5df13388873667e7ea3440f3d65ac728a8f2af028d792c1d099b767a067c8b404aa3736bc6043011ad546d399d7bf0e4acd359a6772560521fc109384c3cba648ad84dcb82d68ad2f8759b2aa9fe315932d9670e8947bdf4b87ed0c5b59875d2292a34c846dd42604fd73f9a38f5632a0f0926bac2b7bb4cc977c4738ab16b6c1f6bcc49421ea50b489c26b4c11afa8c15e6beeadee0d0f0361b7cca5eefe65ce2061bfb59529390ec7441cb3228f9b34b5b9f449ee26b8d8a13343804b72760ff9e560c763b5d8e5eb863b43a62a37181f5d93ca74d9fb8c0d99029623b3e550d4d5e2f50460b7b7a4810f6ee7fe91b80c8ec8a0c650520ddd3d96018b97a71d92257d3c9c375b6e4f47960accadf9c845801bbc75f71dfe66a6193a212d3e8f4cf84ece88662f50218fa7f343b11d067491ac0a21be73a1680e3d86caf6fe502b33622552e6e1b042d29cc41b90c75003efb0587820adeb6cf03895f2e42bb0de16b05b7b473e181890d55e53874ed746468dd9cb4a2cc94fb2ccbaf05c03055cb30caf7847e8db032db4d7f0cc1156f1f6898768d52c79794fe133981c6d8d6843646dd17837e94a739fa38618571131551bb848865509377bd08d542877d40f3d02040dd80d3acd322199d2eb75e05cf2c58e81ce4e7f77f66a84b0f4c27b4f5d91116838b868dec1060e60e622ef00ce72b889a2d51d4d78a38663bad9f6ccf4d8f0eefcc90bb191d9fcdef92c2077f5360aaeb48b3e7b78828c54647405b50c1300d6f9fad8953cc22efadf8890d59d4ba670aeec9cdfc60aa3885cbf3a953cd0b338886fc4bf421a038d0f532a9e47887ce7f75c05a12b8cbd2b553b46b95b1f4fa4c6571499e51c3a3e3c20ccdc5a0fb86b3465b3f0a8a1dc17016a124aaf3bfb7016cfc4fd2e48b0a235b5c6250272edf591e193238c0f769cc615747edce1d91c4f07ec935b2678ca66c3c7b765e27d7866938de1ce16880410c01df53c5e934c27c0bb7e793520e58156aad96290335754b84dca0950d7f59b16cbb6407c7aa1e60556087d0180e32c45ad3750b9ff104c40ada6cef6ca79fbcf9e0c6933f4e18e6efadcf65d766ef243b0621c629a905941c56f69862af76d97f1523777656c2cf13f1312346d27e08dcbd8e0cb1c7e665ad47a51f1c259e44fb0b94cdc1f6d23989d5858557580f0a833ced1fc8a7f8ec3de4341d4edc64a9fc743f1c6d3c2fd41b809156535a7b7c326c4305bdb5e40dc1d56c86029eff463e8168204e3ea8ddfa6a6db2293fd87fb4a689e74fbedaaa2b66e003c7dbd1d0c53a9f60cd58631b865770eb76113903870b1ebb6917269de3686aec6387d5f1289354be3ca2715610c8dd008d74cc672feb192b26a3b734063bcfea079f8e4b45ad3ba791fdf08e17ffa76bb2cf9bf56ca98c0e15bad5e61e5efa5d5e9c4ae8a5738860ab1e2c56173069f3b76a5a5fa719da7cd664e63c745e126f1e1247e2fd3b81a28bdd02257e0c8283bab0ee3f67a1db4fb5de2ee5132943837df6bca3b7dab6fd2528d7f25abeff59788538ff67638fcf8dfaa9b0cfd56274188eef79eb0ed349be2bd7739f431b76152dc090a66c086b1d756fce979c2a51376091b04cdcbc7578f3905e584a0a2bae13a4000128638a714eb82606c6d87602b4e9ee65fb0a8f8561cf2e3bd9a202294cabaf17ffc8e76bcb8e437c4fb99aef10332bcb75f1dbd9e60cdfca28901788f17c6cb076e593875a05b2a6749633bafc64f1ebde5dcc0be70cc0d1fc91c95e81dabe4bf9d5045e617b0e226e908727df55f0894e959159b1fdae8a7174c3f20bcddf71a322bfbf08a9026947be5b5e44cb5601a34af1fff4a9cf11e1fb10a930ee745be9786810808c0e71bc59eb6e95d2592a6392f37a76a3e617e2f5a348be5dd4aa143db32cb205b3d6698d00ea7ebebca19ac6d680035ed73b4acd990df99d161d104e1ba57a7e040e358ba1d6451762aa5dd3c5d006e2d74e2886ae3766ea5f84eb962d9d0a10cad77067f5262c9ea02599094d57f1d701dd65483f5555ff44ab5715fa46978e1fea8648dff4a6a2dee62285fbf6c75105984614dcf99a4c00df1eff097e3f81a86a80404acebdc7b8cfe5bc16aadca952f1720d6a9a3eeb30b80cd74588a63d1f68d7088063990ef3d5a39339027700790282e1e54e8c9295f5ac648cbe77bed642d9115bd593cb74a2277579521bf3f28ee0ae3c2d88db86fed8208e99ba0c91e1dec513b85c0a27d3f761d62393ab3c2a91c0df8822d57358f85140d78c7da7a61674fb3d6991b41fb0a66d543c29643506d670d836ee864d933d1bc7895035d09528213bb1e0d7b82b475736c8f6e2e656eb0e58e2754feb07578f4aeadf6e60d21e09b6e245f910d6678310a0a9e4422c39d694fdee654b54a18e49d02632f1897d5dc801333f924310351aa38e1c1e524717c7b8bf7e7f41fc744f9a993154f855caa41bd1cf26e81df6a4ef7898b3e445e577967a17b56f1a1a1dc1a3441bc0a4662f9e262e98b8defda2c31e9a67c83ccfa824a1af0261fb5b453fcde2059b832842f8acef18034ad984a78ba97a040736a01f9fa8b8eedd4f3284c0fb357448c0cfbbdc13c1546f50c5487111cc9ddff2fe648325da396bd76d370882126a0d35ba95d3d42fb37407b6ef3507dd5e81031957908cdd731b3944aa0f3dbbac5637216c2c43a169824abf2cfbe36c53ca63db1a29310e4ab01b9c0891aea40eeec67ff68938b8b17ba4944942b628ad8b317448a8011e84be185b4b42d212b660a27b92e2ae3aad726732ecdc5dd6d5240554c4f798a2a0e26c8c1bd1b5681163c06053d772f9f3561a9e8444dc15df662c9dd630bed18a24ea1cb30165c9c42e4310109fd36132b30dcd9a6e073a29770891f719b596e32e94bbe809158882bd5e58fb5e87dde506f4e4db2099c888830f94f735228c0b2e5568beef46f0fc39fa88606ce71ee4f5811968f245b67681f67a2233efc6368361e7afe859af9752f08488714e000cc5225400c128fa3ec7382a5825c33be84e4b8b837f346c584c09e7a3bbe3ab6284ae97de8dc7824565cb9fc58a4fd6c310b4eb7bfb7f9eb3ce55013a726b3bb17aaac5374eb536b3605b21b09c551b79f0af62d83a833bdec3e2dc24026a262098cd05c018705016abac94a2e06f14cf915554f915ea1d747777b4e87b38310682b893d721c68487b60105e59d22b62da50941fd1dfa592addac8e0d1096cca84547dac66dee2a23a900914bb64b0c0b811d65df7bbb040b53f033bd0d00eb9b5ba5649e22ca860e8977e9faa0e0dad7e6fc9a10b4fba56d3f94a684f4f8e302c18810c281a51268b7cff36c565046369353d7045ef4c239bd2fcdb5da968bd3e3865520af8e434ecdb1b1ac521ee5dae34e20ba12e9bd70dc8a137b69eea7eb85aa9dd91ad99ceee0bf2218507305d9217687bca12c5621866c62cf24123feba8f8891ea91670c0dc1948c7b5c27ebf544d33548b247704bca45da2da895ec7e2b281c934a8c67f2dc80995cc17ba1d6438bd5a8da0260e9f8eebd390fd4c15b47bf56b84b6118742385fe637b10e389ed46f2d5d8d3b21bb1a6d06e193b5ff0234b924ba91662f7d9be463ac899fb40ba4378bfeb4f6f893253588b2291511880f67e485a2bf7c6c384a2ac2d47e7a0e856ba0bcabd934dcbda2029a18e880537deaa4402a33517f3329258ac4b4c42f22c911c134b98f46ea604e0fda8986b0d98d0843bc4fa528df73baaf978ecf1d08ad1c6be5d5d9375725e6794adf5f7d1ecea7ee3b1f6d599b79b335a7d82abdd38db1b088cd595e093eb7a6efc4e6537447f50897d240ed7eaae9ddd4a64ddaf38bd53d73dec3b709d390c99ebbf687fc3f057176f537ef566b9798ac623468ae7429451d357c62808b7ceddb523646886c0cd871c27cf2616fe229205d522c04d9970e5ed23e8fe224d8c112c975cdd533bd0d1bc8d2eb01606121cb69f4b457852896cb56fc0e02d3bcf19b98203b070fa7dd11d912c873ebdef79ca3a4b733dcd52f8a730e9f217f47743d9e7997b0cbe1e6c6ba09e1cb8dd8f4b8b12a0b810babb597bbf2d676c3105bfb646084b4c81d8dde3f7ff40dcdbcb96ccb41999b303faeef1a8d99b68aea04016659c6ea1a58a7b81b88a16c459971e83b30fe8de39b17c3f4e0ca8c29471bffa1c7b98f5181e4551e74d1e276293e6f556c019ff59ef2d5be5e21d2a25b6233fef339d8df0e5d94f6bf3290dd2d83c25eb0a02062419cb41e87bcc2791d66f235551825c7dd03f09c465eeef082a38395beb52a1f8963f68dce24e242391efcbe00443e1bce4cfa75304fb900b4b8ec0d24a097ccc3e54d3bc60018a226df1d611eb2094a68e7e7bb8b16f5004be0d39269d9d622a2a9fdb2fadf5c9e9269b8727a954b367d35d74f69eac6f569e1dc2d825dc1f0d53d4eba645e713d229eaeca775beae451423f0ef4003606c60e4f655500e8b5ca459ce5c2436dd0b946f0d6ee05973c05283a674f6355d04dbea50e88ac295cb830763168c28244665c39cdff15ae9751f7e81a2908f6e2be29a0ba1686770baddf4b50153b341a98418f9640411b146933e7861c4c394d99653f047c7196f84857df3315b8e39085cdac43882468129dd8afe6c214d1e86e7ca81ae82c590aa5506e1bf9af6e67de5ff2b223b6f90a6cc355c1757af6b30c0e07cd306c39b004571e1c19d01e8b712ee8d9d15f5df9107fe11cfe6dbe18fcbfdba02d09d8af1087dc7195236833f19f78265d17ab17dbf787f4db6e25844423ca3fee3535da1750260bdb45aa1dec58d14df25c93522ab49d10a532f0a1ce8aa64b1fc5b21fa73fd714a3632148f287ee65b201d6c90db2a7f04883af112a91281ae36f9c4af7bad88211efd29a3b97193bf4b3f5b296143f01ed32ea2e0913e6aad0dacedc049104949ced2e5ecb4b404f53d136a39acc145aa53f51e42e34530e15974f562fe3cc80f80bf4bdd85766654bc5f849c1ff14979c168989f58de744ce3ee8632f5758ad0196086bab6410bfab1ae2fe59f3d91690d6d1ad61bdf232d1e699873acf7f37dee4d519d78547b1156f8b07cc0f2ed4ddbc3dba160fefeef597f9422cbb19c81bd24682a1b5399418825db65488ca7a65466f55dcc00ec8185197cc037be9dac70320ed52138243d30ed4c7a11c4a1ae80810db9169a0dd1586d13af69aad7b227deab5d40f2b078d395a3068508eac4e9ee3895a63c9a59c09d7242e246ca679d83d73bead9fc12cd2d6beabcad203efe8ba114287bcf3c7d6793e91ed3cdf1a7b0bd90a42eef93cbf902beb150de19334a4102ff33bb50ef43999eac37ced980ced004230dddfae56a9ddc349c6af05ac5605618697a18273e4a9f4303b3957124c1656e2a2f92ddd785c413c073acbc13f42a3b8371b718e514f94f5eb06d6f16b37b9865e3e06ca5b1391e44c0ea35c181877804cd03405eec289a9af9f98bb12a54dd4865db52ee4fa1de093361016a691464496f196dab934eefa075a1382c496ccc089dda0b4e73e252c0ed0c00c9991d35b32904773450a2cce5f0285afdbd9564e374fcc2cb9421fbcb05d7467416ac428337e716ce24098381ee84b5a3477529f3ef61cc237c92b913bd0dc9fbe443f04b3946a49fa45ec3a63d1565db90eaa00836764dc4537d89e152bf88a534336df992f979b57ce201174eafb7ea3fcf0c3693504a2cafbb842be3f75739f64c2264007908beda3d87f07764961038afbfd06bb61a48b4c5dc5e2494c0b9e4ebacc3a9cec47e0c0d093f7c68581b4b54c1718f7521e45a016dcc996ba25eea43fbebd0435b832c508bb79148d7d6b2ab75bae4eb7857e3ef654383a0bea5d9dc18cb09bb408feb759eafbd4d14e137fd92b94f541856bc960b74bc0314376aea4294623bafa8b107995d91bfb7b7eac92c0bbddccaac4e827e33b40e005717ecfccaa037966bbedb95a85d0795954f05fc6ac1662a1327b650d25de8add0825b666ad6bee3ca792f31a3d82a2c5e559033b8798039f24a006cc71bcbc45ac05df8a377acc6d91ae025618cf193abf5468c897a17239edf188890a065471e06b2a5f70771a3791b48a14d1510d0ce023f33b37d1024970f7f6ca1a8c157e733d4ece4a7fe8c5637e4cc200af018bcc0a78126a548739007de8623f876672c356cce2243f774dab0ae0abf7c775821a79bddf948e5241650b7e2e3f9a873ac9bbc86c4a85dfd257dd025e985e02d187b265a8a07273325abf6e575cebd299e2c9f14f0d4db5d8969598b131eb29498a72ac968b4ba8bc9b108187e85b877737f882b85969057412bb021a2d43673a26d2bc8f6dab3e8d8c2deb56bc96ce84f395d0f6ff53b7b1c94332f4d30c37c1f5e1b65fc5732c00a7fc6d4d6157114ab0c53176eb4dd4d05228d5b74941c7eccbb57f0a1bb7dbcfb811a5998ab069aadb6adffbf16aad85700b558d3552c0459d887351d4244b56d58dd34aa11432b37d31e0cab59c136dcaeeb24d135ed4af2a7507c3fa2392df17f336654c1753336b9655be817de23f495d74524e7e5d07879cb92a60c2d5f6698828e901668d5c3ab5cf8ed5b5c07381c210684776060c41d1c9d4f47f8184be67d44681d62bc6f40c9376a3ff9c2039f0c15d5e0dee56ac1bdf75d2499832eb51447457c5553f39cd8e2e97218f7d6c370ebc327d1bf2884cba018f2431e03306cc3a26af76debafbd6688e000421e4ace77e97687564518c69688b7ef90db4bdf821f951a36f865eaee16a196cad38e1fce41e89f1a4d4a6c118c6442e3c4d9e0efd2f9ebf2171fbcad","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
