<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"48408c878dc1721ec8db908416d0e783d9a9bffe0bd4a443cc25f9721186d666e0dae305b2c3a19e5136047221f2cddbb651a03ffae1668ed6b374867028761e5abe610688c8d0b87c78da7a8d8bb28968812fbf1820acde296cd5a640fc28e9d11f39de68089c19548ee5bffe1c9f380d0a5ecd9ee3204f996f923aa33895d08e830166c3c761278ba7b03c3b58485e1f0969b1123d725430d9a37b629e8c8a43cad5c2a4f7e3b39ea7dde689e0e94d2bcf18b6dc71419913609cb400c41d6f61f4dc5fb8b3696b5cc398805560e472eeabbe3f57e76296be51b9aa5b662f14533f55e6b7903017ac250a424e95f7d71ecefa3deb1faa8c14f724e0e360d618db1ff9d59bb42adea27081039b9920ef4ed468139e8c0cd941112271244b967ba1548e54cfbf62011be4fe1e456364cde5e583b7bd2566e1477fbbe071090b8e55195c533a193daaa5f3006d9a3dcf6bb0dda569a5b947315a26c89e747697cfbd3db4c89b96abe67cdd7e6b94094770e703636f8360538f7ac794ea80032bdea51f68f2445b11d0ec77f4445a09725e1efbf045b064d113c373d8e1d0c004b2fac87e829fd7ed38617082ac81a2bc00e49b80438f4940529452536033c7c0e90b69ecd628156a14eff838107655250d2bd6113a3b7b4776e76b95e8044b040530c0cbc36bb32d28ab1e0c66ea12b95e0410c4776999fbbcfae4b23b41241b647d9be6bc53b194c4825dc247e50826d9ebd0f65560b5a6b2d81d4c313f6b5ea5bc48357f67a7d7dc06e3f9436c9da6c822652c7bf70fd35af74910b80a71c8c1164a7fec969fb548faf75c8182039afc559de1ee9ce25b9777c54fb044ab229072d193bb66fe92fd5b89ec844f8c420d3d7d4550c9a230890883147001117bf397d8e520134d084dc5790425f78448bd8e86cc3909e3cfbb04df13e1896120b5afc7b1c97cf47a62d3443acfc794185f9aef9e851050f0ba14e279eeffcde7e1e20436264ec9aa6e99e50648d14a241a37140c489a91720eeee985d25680b2026183f7ed11fcf53d90d01cc2badecb3ad7dc5a22ddb7cc1d1a204fa1a760dd821d6ac8b80c2d253ebc2de1fb3f7a521ac3a0a8a3ac4699f3468f40657f382bdd5332f8e9db6c41ec299402ed5d54f773c9b22e918659c3b6108e86dc67c942e58bc5e3ca4ef29016385470d12a24b75231dfcb9ed01bb333db5d07c2184ea8e3d286195c9a59f9805d11f2e7b235fa84a17802bde53fe597e718e9258277eabcdc7908a94f6400875226dda984d50b0b9c17b3e06dfc6853a8fa185f93934177998bf7aacbc43c81155f607f471cb6824ff9e8bddb8c7f7a1c038fe2abcd664b0dd0e8d6808160b13ede349dfbc454c731fb9c48642336fdab63de66cc4b0b25ce5cff801f5d2ed23ce1fc1dc2344b61bdc7116ab941f4594163b9b3160fc1c8ea9af792528913ff29a71fc37b8f5c6fdc619c44f16525a2d595c5cb37a684491ebe87bd2402dbb9cee6344aa3270f7963ec59945bce59dbdbc180a0d8885112abd8b3411f8d369cfd4e6f1e99f8a06d15c3fa1d44a279aadf7e988e5c9d530f321ccfe2fe8c3e19e2dee532360d174fe7d5287b10b8936bcc48b1ce0f3787d4848e548185f35611b5647466f73e7815f123eccccbb93151e8e620e0a05aaa1408669fb6edfe33d9e5d39fe48e83546a8d59b0973de3e518aa31d013c8ed3788173991d662e977d7fb63f5d52a75dc19066e56974b1d47ee756f1ba62e5624b34cd7e40a176227731157f4df9178770ce3436793e757a32b4a766524f8992fbe0e45f3ddb50eb2cd3fb66d252253f07a7dc1d266b02cca00bfcfcf020ba16e37c94043ae66e38f61dc250eb8302a205d727da40301a77e788a3ff99c6db5984dc123258133c828b9eed2681e1e83b70e843e9335bbc4135628d1a2b23f28140b1edd57b8141a1e9de9b691ae0676a642d7b0a2b98c13fea56cbcea24b95f89aaae64fcbac5eefc071534b873df6a62dbb13632e88de9b2f92f585de2c787c603276bb54924eea5201e5638471fd0158855541561388f95e13de48d540cf2bd69df9332526998eadb8f50d2bd9309cf46fc6d3bab95bde36068ae8622bd37505568fd7adc1de60909cbbd4a1e216f6924b2a2da8c6e64390bb316abb796db309aadf0d31e70be812e49cdfdc542d354466de6fe28584f47c22c0dd74b5322c05ef9b593d7011e8df8d4150917c74449a163a95c5e62b1927e0efc09c22ee43f97d185975ba552c1efd46b3931c25f2d6dbe7f431b737c5d1204d8625aa0c74174f9e4ae2cb6abbf480e5865e2672bba5a610763b33084102c27894667f06fd0bc6a4faa4525f909791f6c3c6712655e196e5879712ca51d1f8cb2167fed040b4679410a2faa82b84ed67a35057728e8f33de042201e238578ad2e80064ae75f155491d8a3a290788298fddc815cf21e54ccf0b543ee7dbb3ac610df8c08581ba789473ee18fce9a8a20517fa6c7e5b7cd0d0538812d102cbdf150ca9af6d7073d6e772111ab3fce24534436098ff6f3ae35ee5ed32a8f004f5682849df207334e0471d604e1b150710c56a9b43fc4700b05071bd4921b18f5b775024a9d1c574ee70a1b6e38c3504ca7499bc50c17142a21d4a8a26dbd5f44c5f33fd201ee1c3f90c62d5091d400b1a94490ad21ea35c791aa232313fe5e4ea619ca0866bff71ad5087652d71960b3b95cf47f1e4aad9efac28bc96e48619b8d85728f61b86d1b7fd4a0c30605e5f68b8d0d9e57b88c4b98557cdaca7141db30b4a9c4ef89ab15c5e2ba211f419fe3e3f59dd470086c8df0e819a33caad67cbf466c0fd374d40471b9636e0b83aa6cb0b1736ebc0634811af52abcd58d98b8988a236325b0d12275f402dbc28ae978df8c734e7406d469b15f401fb410412b0f5db2158500fd4269c150b0c689a67e80cbafa1d4446838c414d315c9698e4eacd31cf3a440d59a415d1e31e3af45d801f9852aefe64ac5f7bb0197dc2bd6fbee9b5572900506eef993ee7d9fa1596f96dc002e897ace58b594da13af4704b8e9d3964f65ac98990ffdf278e56c2c3a225c7befcb81729068e028c705f126cfa6266a7068885688aae91e023ebd2c82bd3e7524347bd298d1a3686bf80e77f62ffb0a252db68efbe30d0ad817db599471cd291397d5ff7ba50ef326a662029a7e352740be6cb7d85aca976b973c5270378d106b0e23b8c86d39321a85fed907533e4cf67f2fcf30642b20368d4089b0c5b814242f778ab7b12ac14a39276643cb1d66ad07d693e6d582792f31589a8fbb336d850c970435f08fb610cddbe66743c67bb09700ca494ebafb746b1d6850645177493b3ca064566152d430a3b4ff1f49970ea1cb4583c1af1b5ac8d955ac53882bb612f5fe67394b3adf67183bea593b4f91f427162b881f084a6a476b564c89703d85fce320668b9b742f6e2ff2ad26ae0df0964b3fd6f6a939c39d712f27848bcf9e70a1720485dbc0648f542cc188279255df6036a5334e03f2a0ae9eeb7cf88240ed759ebc758891d4e31eecc6e9e8748f7f3bbb6159a4686aa4f3595c7f30a3fc37dbeaadbbd0a4b74cea694650aec4483dfe048e2e8a4cbdbd67c691c36d3671047a668914fe5fd88b5d3a8885182b5322b4b61e9c26c9891f48ce9e32d7342e9bdc6e48e59d072ae00cfd40bb6a23666bfde4b332ad049ed1c04fed6464d159c4b1312cf26f1316281d9c94f7f1cdf01b9a23d23109cc99771d78a03627f0409386f0304a160ea4201b58d1c15606cd8ca124585a3cb3d57712f95733c90639f8432d1af21f234e80ab58c811c7ba9f4b25914b232d12b023e8dfa8cf99d372b99c99364ecd87aa60a067351e2656c5cf409e160fdce88b7ebfda72e9e1a1682f9cb3d6082b451f135c5e32f45fcfd6a4659b815786ce6d9587317b20663c0b77f5cd5c8b0448739428f80073452d5af3e691142656dbc01e2c5f85638665a01661385d588da94c89436ef908884b7d98c3a3d72e160d9809262b36f065873f2b6d7dd7d9820b59abad8c024a0e2973f675233f7fafe2be82cb9ebb70c6fb3560bf1519ff57c2744b3bca77dc3f405632ee0d3515bd63120535ef4435ca6e934d4a4921299fdbf36abfeb5cde88aee9cde67583ac91368b74cf5fda55ff07bd4bacb94f77afe68c521700d62c0b6fa8f81e2c32061ed630e0ac89e0898131fadb08116460785b46c53e7dd34c2aa728551f13cc8e4ffc758e58b16df0c656b3a587e001a198c117ad7d3614e5df1528fcedadcf4cd81c690f9c31e45e1fb17bb8ea6ee89bdc88083637c2ea8bc4aabdf1788d182e4564f8945eb7f81740c208b15ee3bcc837bbedaac71686760b5947ce72a299759fd88aed2dbbb17017c42806f957125a2e81e4c234dc474646c5b8458a085c55179fe9cc416ffcecbdf8c563e4e91df1efb1a24ba5c2026659e2459d400c54194d6611765e0e0c72f1dcbb0e2f3c628db813356f4793dc036c1a3bace9ee3e4b8f4efd52e6278c0375c86b8fd7dc3ce1d92d9538f025e66d074ed7336495d89500c34f1af97f86c54fbbbcfd34a92f379d45df3f4ddf6a6d441b6ae4b6cf9cc07015586f68c1a4fb4c0f4d65268896cf36356ca04c1eeea6491daa4474b0adc5e65ad471165ef2dd8215837820c3691a8f2df9e78b217e67f38c6137a8da8459b10d943036233d61f9543a2624b569cca63eb5961b84d1e931666f15b16cb44ce5afee9ee0fad02962f01844341dfd76982dced73d4501173de658746220e282fab81c1dee152aaa6da0ac16b6d86e1e39a3441e01db6210c09328e3fb0387c1b64ef39bba3a986dc93d1dae2ee9d56bb3268c98034457ae4b9fc16961aeeb0f291e254abad5f38d07bb13744575c168c4d57079b7525ba46cacd6f9ce0513ea4434e23a260857f64ce8da252cd135d923803cc2a49dcf8d467d8d2b66dc8df80e1233f9fb731427e490bc6884409ef36f9de51b746f03582f03f6144841f97eb3c14c9d919eec768e33446222a84b1a8cb16ea19c180442a6735db77e7f64f4afc8c3bd32cc5b3b36e3d9f4ebfa5a11ae5401e590afff6e7707af3ca3231f0745fcc87b04fc1302cd70076dd178387688d5ed0918d2956adf9e3e8f2e2b90d44e488fa77e39f6c674a12866db825cea6abbc126fe139d2855321601f2169fbd144324a00100d22772163667b1064f53a6dc58cb4bafe8d1181ba8ca3150683bd2743e1ecb5aec073b8468aedff00b8965f6356ddf93209afa658c2a89e427b7f91f44ba85055d0906b3904aac8f1ad04edcf82dd3b7e79389a540b95c2e7ca58e7cfa01a129e2bf35b40514dc7f2298aedb1625af9f23d40d76544d1effa2f541c9414a0299a6ade94bdd28cef58fe67d93dd63bcdf8c04423663b835fd6cee0e48d202ac86bf3d3a866f027ce02fea1c87ec1ffdaf964075bb015d16f111d04fabef7132727698dccf0016ce4da402b60d7daa5433085d11baae35091599b4cd0a662e14b91d7147198551240873699c3efb691ee7bdfa9b53ab284426fc3285e5d8d7a8e6c73e7549676123c79728937330e8a7595b189fcfae7b19c81557a3d2f33ea1ecdfb0b0116c221a1447fa3df7661b9d6d38a35a116f07363709c04677194f821734d2ef4d4870b0092eb41f06061e71d5605245216ed5542a8af28b8de796889dbf8c356081f25ce3fcdbf3de55ad3702aa2339183f0883a054c4e6126302fb3bfd44764f4654426dea6fbd810ecbdd04d95d19b19705ac71a1af776add5978a851e29160c95882fd79142c13b74ad95e2dcb3bda93381f0a88a29f37d529f3dddf22000894a9b1bbcb6a6ae250fdb9f3c437e0b70ea01f1d4981391526cc7489e3c21c9011c63bdc45d99c4579db15222d5546394db148b0508f3eb77ca6a23b11dddd0a7d9c564b9ec93a1bfec6c2f371ffd671f0f3618be79280577dcb5324074699062202095d9162844026ab5d9d165b60ae88d6a6a76e84e8130c7f550cc1cf2729dbdb38188941515b510430eb66d87ea2043c8235ea55ab466cd146bf0c548169ed2dd0a1b0e788b6a4161c658d626fa3e4907a5db0ef0f03361b70bfd9189cb54651e4227a1fab01e30a902a59f1a8962267a27811481d4704f922b2bf15bc14c1103864ecd1bc54e8a8833ffdbac5c29297047ea7fb076b7d80818c98f9b1fa9c97fcf7f91a931459e88a79260141f5cc9e9d11d04bbc7b1cb5e054b4685ffd4a0a02f14ac70899e4423dce9774498204a0596760f70396d46287840293588980f025d7bc6cb6c900f3dcb3b20016ae7013baf11b3202b3c388d78fc6c10aee37a669be9fbf71c00e69db457c7149574262ef50754071d4a9ce1a665e31d0301fff029d61f3b4f947882e139cc50567f9e7864e6d2308fa9c1f0666d0594703d6869cd24fc48b8f91d578dbaa1a622604f8eb74783825b791f78262698da2af56671844b6aa6eae6853e63588d889f706975a3514e9e9d0567b7a25ba5bea52e4e484133f2a9f9b36128628b1b6cfc00e5c28b4c26109db783f3614c8def87a418ebe0609716cc35eafba986c66fb2e35c490bf088e07122b2ef89423c20dafeb1dc98695831516083206229d085de6d4100ce5ec6645f51698383729d6e210cc8af5ba51fdbdce0f2178d8436ce519832cf22c1c05f1976b48ff988f4c4f5794f846c1cde4618b3b4dc32138e28705121469347cc140bc6199718968ac21ffae9ced257e3cc3b41d6ba8495c2417c2aaeb17a3d1793370d570bed6ec4cfd84565378257da5a855d109d35843a7beda9df86992c4a795e694c70959d777b7fddd9ffc54cc167b802d2bfb30f1b58b57b6bcaecf13421c8b8a22d8e286d367208d161012bdd37a7aa0559375737ab915db9dcff954b39131669d84ca9bcea8bd6d62953e079720fd3d2b92a01e3e65b4c88652b0f10d54993f2159bfa192f61af09f332f4f3a00652768b2673b02911daa9077153e8af9a9c96bb520f2f795d526b2a605fe672dd25b7f6b39615eaefb1f9d6e4996b1a315ce769819efab1128145bbf945a1ce9dc4b38e91b3e674d919ccfb6ebb5048511d7a739e92ce83c6fd6fe57bb5abc34702d3420fcca477cf996091e9ef0dce9050e130e9896f100f8456972715f243170720d27478c53d61e773cbfb07acff3139b61cc07dd2de62e35c563e91b638102bb99dd6cd7db4c94d85ba126aac7d0a7770694af3348bb5c47c4dbfe71ddeff711c2aa09d168e1f2845704596e2cd90caf18d4c36a1b33e255d4f1e0909aa0387f45867d65f282f781496f44fb0ba1dedeaf7fa90ddb8f5ac4307b6eb991bd2007fe8c743727b137f2461250c81db204fc997c0b2e1b35ff32c2ddbc1ba096a259b5e45569bcfdc140eedb03995db0c3efea3f2b3db4ff6fdac3777874d65938abc59afa62887a0a3c5f5da25fd7c4bd28f62b9a46c39c7b3fd257f5900c8bd1d15844c972be2ab25672599f7529f293783c62d76ec592e24593d232a3eb801a7fde000bd00fe7a8071aa323d5965cc9a4f4c64fab014fcd4a3a503b82d1aca6e4eccc09f5a92d31806b3118dd652d44451eb6fe180688a1a1ac5a2efd7db9282b3fffb66b10484492d02991aa5a138636ee29a8207c00d9307575b703be1db4f7acd76522734904bf5ac5c539a2aa6b6f1b66e4974b61dc68f881b309a38fd2470a7ec15e44d9a68d305dcbc68f975398cba3cd0a7a9ce675a13bb2ee1b13ca739866492f73883d0263d6fb81a2b13852b9884fa6b80cb2140ed083723e7bc77c4243bfd32a4a3ccd144a78a6d87ed65b711e138fbf23113f1c95e2204fa05d22fb8df6a01b3532a409ab128323c38fccc0cf312db5647ebd29419dbed5fc2775a5f7d9f84e8fbe8253f0e2cdc9c83b3c36a770ce06b6b0f79a13bb9d4f4ddb82e7c862bbd08c703a970809c8aa9c1e80db2c65a2fce56884efcb027106c9193f295a7a9de3d3d27227363c769c3f04f05e3db6865a17256e7f87d05bf22b140bcb456278d6e0587a4e0799c5f7530f276c4ad13a0d243229cd90f6f820746b648d20208176163a0ff3a8f6cb7ed0b5bab1c2413a3bd2aed94a971424d4591666419432c126a6a2345727da8fd2f290ac5378484c9b1c01b67bce8579be0ddac6da441ea8c84f37f11f009cac4ff88ea2dbc60a1c8b14177eeec03334f562efa7ddd58c3a8ebcf84524ff32bae4fdbdf4b8d3ea9d2cbb70670c32a330afbcfe846117504532f9eaadc8e3f8a14e7c7fd9ca18bf91d133d3660ebba144b68beb5b9bd131b42f2ee99f81aaa1ae1d45e13ff0682c059ff7e3cace0691ce4191a040732543200869c7144494d55ed48a87521d61217e62ef8f484d6ce5299e5f8efa8b06b582db072f0bddd389685318f05810d0ab74fe338782a55637b602af8facd9cbc8ee8cccc86b22cc47b908302c9a965fa711c2a78bade697cdde7c4572c4fe27b10cfbc03d11907b8d72be7d6123cf9e55e27ec61cc29fc83d912a9b59ec537cd5cd784a011aebda4861a8fd8e0a77f84f3cc74be4e043c844bdaa79ec15f150cb0bc981d512107bf8fb4167aa7643f25c632440b9bf7bd242112ba65e6236d8170ad93071363a3e3a5ea086b7f01bb52a1df494a387ee63ece22c591e93bcc2e8c9ecd07d2664f9ba83cb5d9961c3d17db37d29d16faab3e71b800713a6d13900d2aa3148709dd1bd7ac273e89465a0bd73e1e3d5b84f2e5621a4df9afc1b8f62d6b9d9623b95d36f1d3a4e1a997a099579a26265284b90e22043c32264dcd3d6a97679b20b9e6a697dfc01abd1ed0356f2738956b0cbe5355ff2b63b3003344e6711f84bb953dffb80086dffc3dc0083a41f5fbfd002c98624dd83255adedcb8d8571bfdca3e6a0ee404fe833ee3c3f0b7c5b1a95e296d67b54a7f40ef0c735b5717d19c9e4c059ce716ea5fd4d40f0160b2c149e9717df65021c4f565220b57f524241ee5171d966775b6bcbed355d0a1bf89a6793250df972773464a5e2a27b3ef0b5c3b22f889381cea4acc1eb1b0676949a94a74c66624067ccc6f801d5f311a1e4afe7aebbf54476b5dd6e35f391f38695f1ae5b693a80a72c99c0ec4f33ae418e2d4f9930432ad854de51dab70625ab736781b56bfe7385ecbcb912bb2b215f410e93600d1dec9a4dcd23786ad3494fe78086067416bbd0ff1dd2b8ff62bc6b16bd5f89a16ff3a097ce0b1744d4fe23bcfc54f466fbfc5cb1e939639f21bea7c7d78e7dfcfdbde81236149aa8afc9d585720dd09e3daefc518add9a2227940c6b359c95395a31911e2828fd62e4e4bf081cc030df531698f8db6a1f00465ad0e83be8744800909d59a1fbbce78260898b3e02a7ba71fd2debd9339fea9469c97fd10c44f60893c571f51190c348331642ad9dede18e772742d746131a5b0de01c63090e6613994fc99616325daf8ce0c2e2d322f8bd92369362dbc108616f8a321fda27374e27d8717bc5828d088e8acbfc22b36d8c64515eb78e207f6289259c1a5338d3c7af4440d6845290d844afa1391a786f556951c925a87e6a3f9eaeb03b78ee7cfa4720a544b9d2afbce11427bb1709e57e5cf99603da8a49439585149829a3e779d74da1ed931251a5abb87a0ee03f734061d9909af723d223d1d8a1be14e6c107c31191c631f67aebf3ae9061718b242d77d3f042d80fd24e666c7dc1b8821bc5836699776e7f8ec86dd4690e3200863b0ecf66778285801ef025d05de66c7f160cec3722d3ef828e14ce8c0579fe1ff1406c6f70566924af299b84720f20ca5d5f92820fbd121faf9a591dc8625bbb25378a5ef0459a9a8b5af4c0ee79e7594523fb6e2c2779778ce9cf4a7aebf83c4a0f807499263681da118dee4c22a00bac424d40a40b0cc12bd08b306ed30bb34d869c6a0b080356357f92242056bf2901de2736386092c089f13d002ae5c304e42e6368b411c7768d9028e2ed6dc84a270d2b2875ce1c3840f4ef07272324977f6a032cfc09cbe7d101a17b51fa4acaabbcf6e04c68ae76cdeca9fd1ef8fab9354cecc1d55ea766f8b21e0337b6f17e144969f941891e23aaead1f1994dd03193d7bebbcbc29ecbf526557b051150ea96afc9f075376af5a239e57e53c57ecb4286130b47d69f5b92ca9e13d9f7703682a47f57901d482625a6465c5406611de87bc1eca469f94f5c26972c2e759612ec1b37698a3cff2f3e927947935db99f0278758b33dd4ac5f8a7e50a280cacbe7ff9ef56c80a54cc3b5c12a309c0cd395aa9238dd56949f613447ccafb2fefd86a3d8835dc00b4055d41ffa0a88e72ff4da25bfc9df8d7ab2ccea7e48cbe6b745d325e6a1f7e46bcd3dd09976b212d2b1205665340463cdef8db7cbf00901d6d554129c9a392a5e65807f51d7cd59f3d4e2f4a502aca59c1378fff75515904252713b190796b38698e34fc9944e504525aabf66647659d19c9d01d16cd2e7d3aa4946da407201baeff5d192f93f75bc77708b0f4bf16839431625472ac9b967857bd03c6df4bf5640b739f745da1652154f7e2407fbd7fb72af67a6e60ba517c09f645fff8122942075392fb6c97abb6458f6723a4dd20e7e2ef0450232609b63f88df62f8a3dbc16004c9eed99e7f569dfc3b62a1ddfd95d9d20ddd9be987b9e86cb0812f66d89fade53113d03d60ad59e650077365a81a9cd59eb33997f762b949a598c10abc7e8fdb9c1979394cffda28417ab5c8dac5f1d0682e42cc6a7fcd77a4491731a896dc02d9795f2a745bd29d812199e00bb7b8edabeb9e24df1a0583ac25bd06b469615ade298bdbcee2456708fa5f74a93bbf4e6ba1a4919148f53ce1875f752b54e2fd1ff8fc853862ba3f45f08a12dfe5e853c5f6888d8d7c722a230a14a2f751e5a38e211db082a1791eab9018de14323e4393358f04af3e547478a0cd032ddd6c3cc74f15869ab08992f92bf227ca067c951f8ba59f616986422cd73538cf97c1e1fa4387bb674b07f96a17e8d76e24c3c42eb7feba1ba482e28ddd0a0f1281a3917a783b3cc4552650d340b9e03ecaaea1c50266cdc3f9c48da8d6708b16454019f2051bc43343509a195e067b9ef3b3c78def7136cbc790bfe8348aecf9811e0087a4020d1b806889d02e77174c3bbc231c5963f625de8fc38d85e573d950587c0f895e29f66c1adfb461070bf29f0673e1cb0ea2e13eb690ff8c0d236a9f99c825e4b742d11fc068e3c956608d39e99451e53654759ab430498409cacfc18da403473e4f3f6a7d54f2235e38b575efa61f6ef360300502a2540734b0e3f4d27869b936665c070fd6551511c66893678e7b22463f64619ab743fb9703a79298c753e949ab673655af753795bab0ecd158f5e0a6b255be61fda9504d9e01b95594b511c46cbab2dabe994b5dd680e8f48c79bc3893b5cbc3c86113a1d8355eed279639248434bbe1038a9a95783e0a80217b6a6e75f93d0d0d0390361b21dfd3eca820140b7a56fbf299187aae69238406d709cb4db013848a541d160eb9631d68bcf9c4d04d6daf5f23b326556bd110c415e9ac41477d367479c47e328d270dd12ad818e26f921429a9b78590dace0d209e991661fb8ca9486eb15464c986607fc3a0c4d24f659b7ab1556904be7903854cdd7aa94500e325efc1ad3d32d025be573abf0fd166493273ba7710b9d2c319cd472bd3748b2b4707f248d8e61e4694623031e9c304561c5abbca5240a2b5206eae3080c8f730afda08f7b990244a4dcfd452713d54b15b7ce58e53a51292eede89f0d0884a5d6aa4e2a8857f4b0c5c628e757c250b4fb2586216624a4ada70879eef7e2bd2639a9b6dd982363c525cf34e669675af4f59f2c790bef5895812f53fd8c245e9c4414e754a775bc536e6208c2ba70f3f5a7dbd9463bb95d11cd92d0170849941d70496ff03a533d88335e018e30afcd5a5a685784bc079c1e0e9710f21040f0105264fa8ce2561bf059309f5cf1124fa0664d62d5d7fe102805e62b7f6b9e1174fd874e7127bda583b41021fb52513ae6729fb094d0f0318ff830bc993d4da5d4b607f81983fd4e7683cee8ec01e6df1e4ec5b740bdbb39c9d3778e715b416a6e3b20c3cc0961cf01e794026e0a70dd91e0a3b6c149e134faec66065b664f1115809585c17d528b2f6b1a63af1f668aaa5c1417f1d78625ed0fc13ff9bebf33bd9c6ed46cd0ad62c3cc2979636d498c4c1869e3121dc4b6d8051159974b405a760e50d1fe570388a1c4953b6a57c79f8fe3e1a78fde4f1af1cb9719df7ab58a38c385b823236b52a2726d1e6f3e8c30112e80a4ed11aca0b1d31f094e499c9f6e6a02836e35596f6c41a8d0dc71c5d88aaea3321413e27babf996bf7a6059df876896a9f1f6a71ef4e9dcb266b238a8c3e7b4b5601386eff5f7939ab661c724d8817a74c61f0e3e76653864110cdddc22ec3ae22fde9a2cee34f959d0cc6748777467abec30722eeb8d60865a2d51ac852d526ac05ba15973bfe1301c2b6321ffcb10a13df31c4beb89dade5f4ab9fc8a7f420120d9de485aee600b4453b4cc88bc69bc56bdec52e806df5b868bc8918509bc644fb9ef5fdb873b1c5c87f323d6b58e481894800451971d1bfb50e8dbc455614ea3f654a36608cfb0587e8a9858fae84b22e00903405a7d7b3b8692b9ae0e6fb6a12ca6edfd2b31a511da4fe47484256603e244d0e8b9fb466e51ab4bbd3a8626a15be0a7bf7dcbb9e726a9f61bd9bbd40fb17bddebbe5d8723db97084c15f03bf792097b7726d94322c197aa5f1aa0ff0bff43d7017afcdbc13289aa19f709e40db0b8051ca7cded4def523c47509bcda0963bb173238a83054de530663c4216e8c78a82b47f62d05f5334d54223455288d3b1b518d311e041b37dd1aeeb6b060f8ca50c1ba71632198451c704353c39515d3f9f535392f811d6feacf53d5299da63b47c67675687aefb9d212e06751a6e626bcac0ddf7b180fd1191120858e7b371d7436493b509c0cdbecc08a9be17556ddb7aca9e3e3d0bc83cb3cdde5f6dfca9f02452851b402878c4b93714d49b99b171f53ddd9daeae5da7e9b1814d5ad5029b4bbe2563cda99ca0d716098775c0d0d2cd672f7efc4fdb6b48df0106d7d61dd7dba01127599cc898443d905701cea4a014610084370c7536a68c0affec2d78ebd84c583714163f6ceb2cedca88480c5841a9da09b4cb9b191649f2493992b425b691d3aeb319861aaa7419dcf6e46825984055837edd96460d2b379858010ab0b35cfca82e615dec10dbcc3813baab092d5e820ee3c3f4e09fce44f100a6b55707a1e2414875b4214caa841a3583a374e6adb1ffb0c2b063c9178602baa1ab6e8a19d3ea3e61573bc2b694262717ef5a12ea20b6583f94fd09bcea4f858e9958bc9a97d93e0c13c07f74bab21c1977275f44bedf067645b3e8762c7edf1d024d63efe220081fe05c234402efdf8e8fa1a4447f5f75f55e720e1568307b07ac9a3964bb4e81bd0024b5dcb355f2ebe3f1c9d86b6c56cb8f1b96a73d5552d36cab6b3519995b3978d4b89fd4b7265c6af321e883508047618d53c6b53c94d3c173ef73e2b8c1c16e91097cef6362d211e2e6ba028bd4905d4f8bbbb79616aa8720e389ac2f0c7a2433aa172e4094b295fe359b5a1aeab68f5da0e6ed3725020809738b75753b39fd152b7f9ef434b34da41e3c8e0d9d0785cbc49312e02840fbf5372781b49b3bb5e96d4be6f2474b6dc68fd07a388884a1f1877184bf7b6321c80a26ac729c1cae06c599cee96b6c6576acd11b68c5b78c0b6f1d1c70ff9eac20a3b13e653ce6d4065a533581fd817f454acd23970cf9cdb649ffafa1a652ce639984403081dc4f93590cc8c99c6bb0c2a159dcdefa7dad7229fa","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
