<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"77e5d39f9cab6edadfe17fd906e1756a2b4a39681ff8a0f48603ec1a300aac480515180219c674b42ca7aa2ca6ec56d281097e9e897adfaa8928852bb3961aefd5006463d3ac1613a089b57c8860d012ced3513356158390ab04732d038072903bc714fe84132715b42dfabe596cd532d9f430bea11a397b86db62713714eb9c1d4d7074a32158292a0a9f6ba0a61b4f9114f048ca2da8aa48e9067c3fd759f4deff48e51116c44d1988cbd18b7a1f54e2f37b43f6f69cc3ad756ada8b6088e4dd8799eb7508a734e6fc0d2a9a75afbb123decda028e53e4ccb1024979e977cd5b72e251264e7a070280c1eec82fa61c8b92aabdeeeb3bb76b74a6b579c2cfad68af764b1786698d59cb54f65e795263f491b6a7ca6be97cb789fe3b3535673c06cfda08754d2babeb554c4ad0496b08e19763dbb153d480d295a297ef81df6e4a451bad5cd2649e7a55c946ee852dda9eeab5e421c82403998d63c8846c95b2db04837dbed357d0d60197af5a1d280ce9810d1011da441da81d5660d19e4256392439321aec45f309ae42ae645d0ce60edd9795a7ac684c85cf28f8a37147e313218b9e152f6ecca2d86a4a42b95e8ab8388ac57d189591ad152279e3d86190f9231385590f0a77fbf185c85fedc6269be91f769975c34e6bd1a6194dbebe1024ee356a1295efdf5871e8723c56c8221051f11c8738d8a7903cfb5587e96001d1fa9695e71fb3e80b0905f9195411c85ba4faec9a8b48ccfb7d1b35573220d55da43a2aaf4ab9f8f48f59c3e2c839e57c8363b4cc64fa3f84277641c2c66e7bceaa473425d2b7892004d8ebe9ed9adfd23968a3f4dde18afec1889791ddb4a2e059d26483a7bbe09c4670288ab8c16cf141df0c25823d01988ee318b6d3dd8094ef6cffbddf97da795e84633dea52da0209ae9686020591781b8f7f4f29f4a96df7e52a553cb32ef02a982f18887a626765a4f38b27a421f04dbdb90bfe21d2f2b15745d0e24143323a131bbb05dc5981e8a7f11947ba0af2d0ef190787ac15ded32e5b467c34f141aef30531a7986d759aa722ecf2fd41c32843520ca038f9b6db0b06f46aec8c0f59d50b7ef3c7df46e114f9a792e6609817249db8e35b2c0ee4de2f218e8331596c216270c6fd4aaa5deaf07a9aa36f10faf6aca79dd6394b53430f66b9de1de3c9c24677c26a6120ff1c99ac836dbab7009b779ede821261848d3d89fb898f745ff44f64ee70707cbd2187b36c476d470b1b239ec1e893f30316510f49f2831d94493d31a10c2b3b5d6297f4ec0e5e79bfde1d575f694fd0f1b568f12edd969d7d863a2ac42d76555b62ed578cb6eac9b3e64b3e552047ba5bbb18f6506e0b5321f2d098923d689cd7e5b19abed231a2f1f4ff441937168a34d1a47bf2a9c6966b79da642ed97f851b440d96ff105a15f1dea3c99a1c6e220ce9843bf4fb26a5255346e40c2dd4c2094a6bff8aaba4b1613ba0474472a8d51fec85a53ae1a78c0df834f331abf7e03cfa3a509b87f6c545e62a422daea358ee0ae42d0dee40fc1024074a583f6b232bca92553b9a85ac5f378ea047c3de180c7ea9aa32342abbd1c3cf00528e4491cd7ae7e19622e7a5325c72d9ae57bd504a6475723186ee490a24271ba2cbe07252388c4cb26cd519ea93498847b2d897aef0f6ef5eea60a89da0b1cb0dc99a50c6a21f9e81b4864a69f7291f0205e4c2704be7a05c8a0651ef1ac1a77f1b0cc3d168cb077f075b58940779b71fc10913e2c575d9e501ca6887b0522e00d315a3a5ed42bced17d94499f983679155ec3a293fa74ca91267bc562953ea1a765d1ccdd99c380fcab4c6b333dcd7c170ec24973e83192d6f310a9af26e3a2e64b086dd64339af2e2b72d12cf7190b4aff5a8953ec526736bc90340c6477829828b94f766985f7a9543cc3ad8e1bd445cce49c9eba7c19ea156e48b9d62f29b3f88965c3b7032d99d9587b19b3380e24254c89477c20b86bc31c8e29b92a81a35c8c0c04f9c2999eca99c543970aa1886a2f525acd3846d752b06b2c95c6508977412d639a12d581b8fccaa9f83824db7575d55966d8e0253f81e89e4702021287655535b4ee8e4ad2fd1d82cee5028a9292b4ebdee9df7ad18801e69bd3dd605250cedb7914b9e421f22721002800905bfd868db3dcb55290cb8016f67cdc15bfe90647b0653bf2b3412724c8ff1ac343b97c36a654311a2b06580f355dab964bffb8afaa1c77e679b5ee76882a2f6648610dcbc9a018b432644a86ef4578689ed0ccbe2d57b5a382fd35d2f998f37837ce9bd899a962a4670be5244c4c85040d7eac2920707bfbe93d7bfe21235775d8f170baa605822cc821d1f679096f30275900dcbef433af38f51422061be3ff5ff5ac7a7901c324091ed2b9cfd115f1f5dbe51773d97e5a7e133a3b9fa300bdfe576b97d8b2055cc3306722c1deba5ab80430b1a95f26cf2f3c735d8bf029ad86a6f5b3e33e6c7cd631e37f3347a831142cacd3700de015ae67f5a513c25775f87d9aa62dc8cc8bdab766739f6da8d2c4009d4cd3a0d981cbd6e78991526f0249cf7614cf69e04e2dbf276e9d99e84abe61b538a13b1630956d69bedde27b037f7314bb3d4a55f5c36f706ad65344333bfa9b18d87c619b4cfe351443228a182afa59a27d5b7a339f572dce8f4ad0c300f457e36c5fee23c7499c66c642eef5def6f8d993966014baaa2488601624ce8b5c7901284bef15132680f188f16a486ab07eb61f663cfd70ddf81b008884192acd48ed53079c7ebe8e64409b1d78ffb4b0e165e42da56f6b1478d4a0d624e71aa72521b2162f0f3977da520829b728353e24dec7d4f6d809cc2b7c9c3c56e6d67f740fa83f0f3200961271d538259f5fa4dedefd15e9e685bc8d2c924aa2ac5496aa8e24a0edff04f27c9bb4603bfb3679d450a52461dc93dfa3c318ba8cdaefdbda4a1f19c65eac823ff6c2f2ef5f9cb2e4adf38bb3a8651a92b30331555121d698d596cd13b6d1e0b7f7b1c191bfd38ef08ac3ba49de1fdd3b6b7af5e6227a020895f8af550e255edac5cc734403897296dd30ac6c1fcd0c14a1e6fe3917f8363b47683dc3189f40b81f0baeba7d6fb7467fe61c0cc757b1e5c2857545fd96749a57a495b6906303493652dedf9b9e61f5dd9932c85a911546a65db6653a33536f2c62487703f9449d24d9b63874159f7dfa495b94e9121f256340e6673bff17480cbc87a91a6c0ee0f40cdbf492296f035daae2f9718338d0437405a95ea66da88cbd5625887323ff9eb5f3b388c02fa77fdf1b9bafd15ad6dbe5054ca720e5178ff5195d9db712ad2eb156814f88efddf3c7ce0673349d709fcb70f3501b4f52043b5da9c0c338224872b109219157b8eb2cc6270f0fb1468b7f52f20425c0d25149a30b3f84516a27da0409521a6e62f1ac27f24cfbc5340abd1562a14b1c3b517443b6c5a2c912d83d87bac678930ad9b0a6d10d19c5fc438f2943fd3ef53aa6843d5b754cdbc375ecd0bc9a0b8a1f7641e4ff97c48ee9fa2548a7939c3e8f33b7445879fb6b9317d1e85a51ca863961188aa2271f8da24b62a7986904ff3936ed9420e8c6efc471d4464e1e5d9e71d4becac18000320c246dd15ec3e26b488743662f895609b304ae03e4543271d7a4a8f14ab46e07223fff16a628d4e7e50f056985ed0e9cc223ef1d71bcebc6eb5037d5b4ec79e7928c6db4f5790e2c8e4dd79488b05e02a7794b03c0c784a097e76bf462319c2fe52f2c1f7a57d34e2b8795aed67a2099dc19c3daafcb9db1a11fd25f90857aca010748016a2ca32ea8d6ad89297b83cc2fc6ef97f3e73df4b27459d7e1b17049ea22025699fabdc6d6115e868ff5894a422f8d3e1fd4eba30621137fc4af73d356a0da1581af4b21ee67892646cfd6281562734c0d046669a81a79e4fc243ca6c1016fd1fe8f0f43ecfebb3f6f1b9c0b4ce12c28d2812363fd0394d16ab6e6c54554ff49be01eb87aa16665caf2cf83b1ee89f2825c9405b77e39d733d95478f7afb5bb2c00e4c93d7b1a07f60940a20677707f9e4d5f279565cf5b569628f1c34d68a8c0f93bd41221b447ca050bcfd168103cf54fa1090a2c465a7956f7b20c227facf8cef648827114577587226b52d548affdd20f04b7ba69b9af6f6d4e4be20fa029cb54e5f7744dfaf131802173d27d66b2c54d8983e116b380939dc62001ab822ef2e4d90844b227fba4454d19a5dd701be4af22010226ac732feeedd62a06c25bc498469003eaaa5f88da9fea3fce16a5e1bcc71f1d330de569478a7ee5ded0c6ce9422b8e91c44f007f16b92daeb6d82ac7c3b2b20c2d820de594b3d66f5d2a7138e5165745a95d2a907bcf2bb087b2e2df201d050dabd640e4905f696a155f30c17fe2eaba34fa7a820192fb54fd1ab36b0f7228d610096ad93319c8028375b5ab2bf1a1553d659bd29b6887c85eeebb38685901c26dfdd1ee4a7ef3314ffe98cec927e26018a32521858c8db7232d4146fc846e21abf32aba04dd9acba6aeddb4616bf4101c2b6cded2208218581ed762557ce65968a1630d1b647b5bc58f8a5452b2494d43706cd069c9ec67aacffa2db89278d72b088d5cd822f3ffda4862d5e4aa919efc17b63ea7a387f057f94298ebf81052499b55a7ae09410a2b17399503f3aee30f3a3ed6154fd5d5a136ebf496b047443ec93e8e6ee8ff746f1753203a4c747db2bb2aaba7e46f1bb579b816049d3dd59f8dc97d33deb450517b5b9aeda90c921456811e7de4fbdeb0622131bd188c73060c65b6b4d56fc5d4324dbb3ba404192699a0331940b596a8ab4d3810db49371bb276d3a028fee53eb2a8b22eb95b375808e79a04745ee3f65435c83b9241348c3cb24ea863630d4e68758d5eb154b52b1479936b790749a737120b47259cbdc99175ad1ac78a4a36473a40bf008d2a235e043379ef1dc29c44041f1552cd342c9a8e54dc4d61e53977dfd123abade09b2f4268ab0d49e0891b3de93ebedc405c6d3214ccb1aa5007b298eb5c95dfafc935c9be30893ce9b544c9ec12744bd55ce15eac6cfa4ba5192fb259135019895aaa09fafe95917935ab05810907631038310ae8016845b8cb4f35e3ff3a0b440d93c56d9f0255459ab0cad71279315b6bd573e098ee1e3e6861e22b09715079a79628aff299b6d243a47190587f52e61bbd3b7f00609397eb4117428e4b846a77e180fecdb98e47a3fe3913e4929559b4c1d7880aa617b5dd6e269287f358f04b01e7ab41eddcf1525c0cfc4720d82a294ba6d90c59c2adc4f4a7e38a044b3d132d1f2506eef74fe6e4cdbcb996d9aec0e3637bbaa85c9853fa2e9740dc34e011b077846f0f0d1185ec19a6c74c8fad351cbdd95f551d59a21ce56ac27744689a769a7073eb0fb709773a32c61b22787ba5f741bbe84100f58642a4af9bd82ae9120026d50de8c7baa6ea5e9b77660100611d485af9d2be8741542b5a0d9afa65ddc0fc4cef022b19a8f46eaab023e096bee21e9235b06b44cdd0127ce9827b20a7d52ab2ae5a64945063e60a53526b9d556714eedcef1c4acc9d4153499fdfcddd3ca027d61f3dd497f980aa64fcfb1f3a6de250dab7e08d472a71b1959d0f6cc1ebec75af4f4d0dfbef1cd71b34ada0d121260732527f25db7eb8f5b96c07f2997286955c4ba9b792c5b53c1457f3be0a89e7f1ad762b416472656aa04bf4026adc79491b1a1c6409c3437aece9030b0d0fd88a812cf5a3ef7a7696d411ce2e745af22bc4246ffdeb25fcb3824a0314fddf81167691b7dc2ee2e9bd9bfe8cf7f99187477f61d9f38e3383e38de94a208f3a4f943bc90f97139359d72a492626066fe05c9649f63d5baa37f53e0c61e4883c3e0a411dbc9caf11d7dea55c1be5ccafc1efa13c4229588326695dee7c24549da46fbc28de624f53a74fe2a0cdebc097a6c8288b8a9ffc8e58f32483b6e71e342c197d7b340a283de3c3cee231888133121931eb3782663e45835532ae4fa45d6cb296dddd5c14f2def01cf80a92dd447ff98189ace3d106a6a651ec9caca5efe715e8b84fb95b93a456f66896242238f02da9d196c57a32c17a03d27097300dd1be456b8804bd216fa2932af8f35286f7e005db5dd5e4116dd4e113896f6af3c0787a5ea64c633a0ae272e18520b6e8c65b318f91dc1e7868b35179ca1e20d3698ce8a4b6322ec73185449b3260df98863645e7e261c5468bdf8c4ed91b1edad8351a986eb2b72b871b220423d43e4c0668af8ca05ddd04475e4e4c531fc2a6dbca10ab40a11779fd04bacfa7ef2e6298c5be89ce82826fb06b91f81c882ff8156521fba845e2775a178915054e4daf6bd55d4868616ef6c24a5b06d7de6c0f7e10108452425bb86d3559a8a8fe51b703a527989382f37022fe1ffc0208dcabca30c0ba417f36593d079bc9e84617316a71716ea7eb5d3bd8ba9090ad988560c293a1314740018907833ec12850a394246858ab8ce8ce5fceb9d49b209c9015ba55188e42d7d3c406e59ac57fee16d99ae66f620afebc44fdc64bcd18a10d74d9180098b4050bea1acdd221047d66f2eb5027037f5c3de24da2ee2e8816e0ef6da4c24125d84fc160478f277730345fe9f92cfc9ef021542df7b089cbb894d9ba3a9a18d92ebe5bec7063775db1849ad946c6578b0cf5e743042cfee0e802e34156b5cdcee1af13a87813fa617b8a5b7f289631e1067080b75bce8f663fb95956650cfcfdf5a1fb781ad06fad587ac2377cd1f454b4481a372c00819e0d1ed5723b6545f3c48d309097732f8c3ac7e0130642b6edb5335d31f5de7de8b8b5c372fce095331916d497ff06534625a58c8f8add0984d7511c2c9d5e18d76590f819f9101a1d552512e43f5e4ce7bf931805237f93c89605a2ff7b801d035744c221a29cc04c6c09714a68d6e2429f3ddbc72ede084723d7bde56c5b3026f2ab9cba8068293f223ffa2059e3898ada5f27fdced69d95643d9a0980261e01083396f0df2777bf83c6344325607c6b124dafe082fef3263f2c273bd66c2917cd95b2e803a05dff92492c5d66546a164c434b651ae0a6f014a62bd18c20196d16da29a666dd4e8bf95ac461cca4c9bd018533bc6fc68fc33da3aa822c78db0db5659303951527d9391cc9963526db23c85dcb4a1f6328a00772f3e5ba3cf387a4bfaba3b55a2d835aac552c088fd6c55c8d0bb082ebf74afc3f158ec9067d669828fc86251e02efcd7944d89010875cf92dda3c1a1567daa4635f5204bf54b1bf6edc2338a12e2c2b55d8ceffe74eaaf070d63f2946b6029687eeb7900e29b004aa39800c184f83102ab0e8dee668d71365b83825d2a071dda9c91e99cb5e737f0d2f90bd8bcf7b18c1eb2eb60e0d2f6db091f590de6c6a8315f3180dab4ceb2c9dc2c7eda4eae86381855f97054abc761ec1c779dad55750a065c144bbc1e20ec88cb61c258aeacd5c89bd5122feac5328f13f634fb1fff77d0dde8b72ad748a56c91d40dfb7caa0212775e2ee2a21c3fa1d50c7f34ca2f96415546b1a5a99619c6a038edbb7fe88c11f6e310f9da2eff6df920f4b156c6c779fc34ec0ae2ccc19c3caf77531bd2f9d6036061880f619fab094c4ab4217c088092cb186e14277ad49278abaa61527d9703736ad22046f299be8aa8a64838304f723f737e1ab260a9ee0e8480ce1be52143954c431674023dda9495b0a8d4969cd7a6d7ec72f9154a0e6a36838ad861b850e4943480d5acf19bcccba56ca0d9e873362a6ca36194803f04b2b8fd4a52aa63c6fe3b1cae221d0a73974988c8d801ebc4d258ad3dd6f3fe1eda654c0699f735f0742bc255b841f5f4fef797c29d5574b85bf2c45da5697ce2b068eb7167d1e3b990490bd2d50f8eac336ec0e45ca1907bc82ab603788c1d43c3de40de47c44418633c1c2934310a466d047634cb5682fee43ad8e59f98afe474c03acff35866c0c20499111b3769964968b423aeaf46cee04c8cdc3a2ddc9c359b81d42af2777c2ac23629a57ca8713243a1f0d87e2dd8427eba61daf72fb9bda9137d250f19a21fcb072a750b0f3d5ce19ee23023a9e5ce0f9587e6dc4ada71c2f714c89a1da2b23c843d3607c9bca19498c38143da893bb569953cca28a945d0b05b9eb2d8eedc4df87cb0de9f4ce9f9c4138ddf17ac3ad7f6db064ee33fd6ea5ed02b3f0f1a012a820405bc89d31de7b16679a02b80ac91bbba1b5f8c4050364b987a4b1c8918fa588558bfea1515a5f468b1205303c1057d37a7168eec84f7cfc785550470a31e3131b0db65dd4ea5d65e50b93ccd7fc9c46dc0f401cb5b633247fcc15437290bdaef5114416ecb99361c498e8f62e3cec948f379b354df721db328a21b912220f97a0f3fd089168ffe8c76b816ec1d13865d244336a9da0762bfb0e6577ec8f1ff973d099cfdeefe11247c303ca70598e0c0e04ae11d8876791da1195b7a39ba75ef544ae8960d909297f2cb51aade4da50fd65eed846aa59c02938cd00bf7e8ce608bba2cc4e3bc3776ea86450ba95ac3d0842044ddfb1bd1cd97fa0a4289bd6e864e40e21e0c8e12a169a46c920447d8bc1ce3c3deb35a452a4385c9d5dfbb5d6dc7fdbc6048c89f86e25a465487f69aea41c5b4f490fbd2601b37309576c129f273793b350c9e20e73eeff7fb68c9e2b35cc0d340b219e122fb1763ae31e6f22a80406d0e819921d14ee922f1d3a2234d630b1e4d8ee2dc1af23aafcb24fc5a46ba89f1b3a238ff6744f36347131f051e8612d7e7ffd697ce3f8d188ead56590365e2547519b123d05a40093495f6e66fe28d6f9848d212134e8373428f3416c480be1e3a2ffcc96cf361a0d29023f9a1a2ecaa1172df5127513b474e6a0581f96132090135b3147a57e2297234e071c5f2e7e3c8c47e8fdad89a22f3801e71642c25961b0ed67b60d32c44f162eac748e45d9d811ac97fd8e665a4e7cb6d6ad6521155e8e66f5fd96b621a42d3d36ceaa2109fdb8761b98cd23224ecc0e5b0882cffd7be64694ff883361d6053d675c9c118b80d45576b93937a04bc9ed7502bf46354033c4843f96949854995ce43e6d0e49c2f0cdab997f38ac2417b5491b43d46cc639052d07da9d755b59a87b0f4917439c9107786f1949d3409107bd44d4099a602ca941f5b4cc37ceb002adefb7f5ee28d747fd6617a519494d32b95ed4f4cf84f17ef5b51f88ceed0fbd8021bb163c1121cc7c380c83930ab6acfa4c610ba3f9bcbcccec9a1fea0c23a5d0e76f8b48cbf7603ef494ac5ae3b0f7e2cf02fc2c37268f765f7bbd5ad82eb6d421234a796d6bb8d2b280e56dba17fce9bd28de4a9fb6b340f0b2e6b1857ab4f2d3c955168d79ee2b746c25f8ae9464a8d361c6334a806b49a882e12dcfb91d1a50206ee4b3c21a962dccf2b2d3ea25ae8884caa0775920cfdf33e75e4aa8655f72bf05374cdea87d4ee5649d807ba76eec58c6500324f80d75d0a909a7c75893f1a3a273a25ebbd06cda804b6e986f71beec63212807e1d3260a1ed140667a5b71a1e7d6d4b9642a764c8d4741bb5ef772ed50c0a8eb7b528700e046550460cd1c115eb4009472acd1643e3969dcac05fb7da5e37405f5dec71d1162c213c8e2d21736033adf9dd630cf45cabdf2d57e264fdfc98534ef0a5a5b863dd76aa8fbcf46b76eb340b287601957ac674248422594283d217570c61c5d99635b9adb746e2923889b9b100932a60aeafa42788be46ca4050f01de0a3146384aa40eecf1a4b34faaa3b980fdb15975a83da01a89536273ba92f1b61608bc6acde164fd0a2295b98a00b1a764dd4a463bb295e453b5407ebc28414dad26808a9f21e545b4c3e9f51280e2ca13c62500a3662e252f97b6c125412bd8434b8629f049e3680cf3846a2f561556b87ed89bded3db362259904967ddd60424ba73a81c2d7ba523ff32a34c9152e55fcc89598636620cd4a03f0a02e3372dd81e46a41b7f7b54900ac794c8989d7080fdae263255f11ff3c651fe18645ae6643e0d53eb79b41c1e9b62fa699e17fffda71a287d008a46883f4314161a43967f56b62107d8404e4a360bacff8b7dba0577fcccf00df7a9b1f27db296cfa96266ec995dbcf9f979ed48f63d878f4a5514f470525bab95183078ba09fbe6051f2f93c59c8ec9e402319206741b3ce975c162b6cd8d478260077ad605b8478c0d5ab68e4dd8681512caa931e347e598fe648c1bf2af1738e262f9df6e2ea87cafce1d684654dda7521954ffd94330217635275ef317a44f67bcef05d2ccf55e08ad53e960ab9c09b5cdf46604357129b767151675c675bea095fa53464d543de9da06fde930e6090e936fdc43dd14cc65d7c5a22c468eebb3d23db72e7014614c5a70765708020d6e2e6ecddfc32381cafde79ebc93468efaac4a790148bc673ff26392e0cfc99fec9346379861a92e3470ae437659a85800eea2fdf092478f4cf75e4af416a78a890a4ffeb2020780468171069a534acf0c004b16235d6c6131be3c8b5ff76402fa63b296f635179ed248de5ba108cb92b87edbf8615466bf20dc59cdf675ca048bd45852e6d7a5f87d4ec1cdf2880d4a6d42fe6f0f28d86057b69472d07dd40ddd2baaf60174825f4abb3db50e047e1f979121a78f2daaed1c041783f6879b33b8718b4a59e71aa91f78599bd10b18a07b1311081b04903a279beb12422af7dd1ccb57403fb2570edad8bb95b0f05943181caa1dd7c4f2cc21b8c1db1558313b9505f8e83b92257f45f88f0396f92652a9770ace02398fc94753aa8d33408be2c60947c429b2212c2a44d1c6f7c5d69763a0ebc918ef531ca1b0b014d33eb03f7eb47aa302ff8ec237d69decb35fdf4d3a89b5c8d79c1746b729cabf949e9d5efc858bfefde0c811cf989c67be90e2e70b46ec63bb07c7d5713b36e8666f9d6e3f4bb09d24cd9cd47dfe65ef4b722ccc3bda616d1c1361b9fd1b77285455975b0886583b149bdaa65f7cd4f99c63e8b50e915b619960734ec45ade990b717b11707fba803955567017430d83336044a80201067300c1ca1d282a05a137fc8832481216a150c921c3317cb37c1687cf64393d66f87da46ab316c9e97e139d49b2b5ea306ce72d077298865c2dbc0f53c6d0eebb8df6fd898142b82de23a85eb01c8589988bcbacf36ce013802b145928e52e04682c9589813ff17efaabbae85b7c797603c3775e318feb2b32489ac8fc22b2d6065f41fab05049f161b2f5a8ff3477b80548c27b80e10e9f2fe6276e16d2382f1ebec136db3571457020728c6120e49393190bf111f2b93ad4ce38e6d1fefb3e14fc29619062502d4db0def7b03feca0ecbb5f01df0f0cb68a37731ab5a74f78643bddcd47485c512af4422b524418e3f81490958c694f7eea483a5a2ed50b1bbfd52ffc80a4151dc6adba50873fda49e394ceb17f7c8d058af1c8c2b477500d98fe352122d2bef82c5655105798546cabe62648ec0905bff11e110e13b857fffb6547c7a1e39365430e398f6769c369b49cd9230ce17e00aa1a36cfd6b20225390f4ec44c187090aa71f6aa0f891913fed5521a589b18c1aae6bc4a926106a3b36fad6aa6f723667cc582c73b02fdab77dccf6aeaf86eae283c82bcef04c7eebdae9c66508c31badf44e655925c45d70e6e08aceaa7a38e2e950f5cad94614459b5730e549b6b09ccb117e1834639200154939ae58208e4a37929fbf0f7e8ac3e28978d064c26ec6054189218aa2fa511d9dd9587f6eb40f7ac11c1888af0743ab5011046f426e07cc7f2fe327446afc8827c790ac25154b3368a46813a15491f2f11c616b4f8b26126017ed352146ef5ce866ad921001db1beafb164b51bc3b966598cf95e1608433ddba6f8a90a867a5c85d22fa2e9119892eaacb59ede375e2edb316a8e444cdeba40b9e7609571f6e4f02c64af45e0c7479a8574b1de2f5e876fe28734a0bc3a72844fe0c520392cda69d60d1b795c96eb29f546051c33001141306a217d07d7e0a3bf2750714d718b472852e5df21050385ffe33e837b94d64117fceab702c53dc5c9976c4ad32c3b30b17ef68547603365050fb1a440ac2e17d8b0aedbcf460fe45dbc840dc9797a3450abcd578bc1fab7fc0c059b35b3f389435ebd44a0e317cff691977a872e8cc0d215d45cfc80307df6ee0935c997f5f55cb91aa2e3ecc6ebecba018c5b9787e1a0ab4a78e6f7ce94808d6167f10fe2c662106d9d6923daeb92c169c8c15bc53776fd31f563c9823b1f7f311374fb635534de54370d15517fc0e22e291a2d78b6374fbea4a76146b1d006c3109fe039c188a161a044911f8199e40a5a8c647219e3a9033f43ce40cb00d03d84a751a560cb08c4e043194dae7f09065fff7ff6b078b36e12ce6d6d80d6818fc3588bee3a55f4f1e70bbd16aa77b69b41042380c0e44a22dd8b17ecb11ce4e38848c937b6c0ef7d5635bd9ffd7648452b18d6c0623ceedf3ce7bf6ac7492d0f75cf75a5105b7fe299af4854cfbd3037188ca04ea637cab267205d0e771d855671fa13f626f09ceaecd437092215cb4513624f426b2bd1d37291ba330d09e96e44f6b736bd313820bb0811d55b29bc30fcb7e32c7cd323d54238e0aa98b9dc4d7cb935f4bd3d51b737255970f4c08d53c1f1831855fd53133a47f70eb5c44393b4e24e001f137e6d8c0314aee94d5481","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
