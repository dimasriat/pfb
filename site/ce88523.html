<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"34df70b85b6c5014ad5b5dd073d2c4663e0734d8e161499802f6d99fa140196e658033a64616bbd95dd677363d4929c886c0b382cf07f5d66e5b70cca28a22f571b910cb03b1c6c03ea402072c48f63546cfa194fb2951429da5a097614e5d08b15efb4d60705e19796e864286186e800cc27792549173bfe22a3a014d882d1ef15ccf6c5b124b276ef44251ffd401ac6a0e613114c4b4b101f2f192a6727d47935839b942cbedb5fd631e9ba48f9c801f461be8cf59ab9f10cecc0a6dcc63b5a3ad02a8d2fab0643ea8ca9331afcfb180a0e51264dacded5664bb4256bda77861ffbb73702e68b6179b97747fbc876f646113bc384ad471f3b0c850001fb375e017a5d3ddecc5aa60704b6eb1a62b9dab3b09069a1d48be48bbeb109e89f064566dadfafe9f7d226deb55be817fa17aeb0d49f3baafa06088dde346878eba07d6fa5db2b570e044f7109a0c3e068afc9e13cb15d7f17a13bc4737095e906c8e0dfd59a88b347283ed87a7ba6b293b3abf45585fbfd17deb5bc7da09b94e5b98133a9d6dd5e22f66c5028967588a0d233b35d0d1bd67c0ba8106045376014b817c7aeb602f19489508d78d79c71993724457f5f6fb3e5d78e0cd6240d3ffb6d6384e4a5e417c120ecf7189aa355889e7a9f6c9677ffb85661b5652e58cb5bc60d558860a897a0ce18b9063c20d6ecd118cdc4867d975038db3571ca0f5269494fb64772347ca701b12063890290fcc3fb57cb6a46ae94d2dfd0e1f427e203c62deb4f962ea95b5196ca8c70651d27c215857ff9330dea567fd91af0cb712acc12ab76519eec6e50fe8bc5bc7457566c776a24db713e5e6ff6ca09ae27d84f25b1fb27cbee19b7e0d9e1969b1c6b412c8f3a2946a7f68e8592aaf96836c29d4e5ecc7e52330fa51d9e839b85ff764a6409ef5453997f728cb3abed8011175c4d2df04ecdaf6b56cd8386af67cd14a25aa8b3a3fef3555e227484456021c2ed8d15e5785a8e6f1ddddca57dab30abb2a8e060c7b6a7b9c3abd64f4392a4289fa416ade840aed9414ea09b9dfba182c26ddc92424dbd85b430cf931c205096e945dce81ae1b770328cdcd3b215a9bba5c65d71ffb54265bda21af147c1175be84931a6aa541eeca035363ae52fc0b3324d7f8d08e603870a0d9fb2bec90c820b8b78eae9b93da04463197f3eb621949e101ec9de76c9f9c0f7976f7ae5bacd24c2da16a33f47177f65e44f4754c22b49be38d2888822db98ea66efc176445c3b62e1d4a94c22e8f6eb58999986ef932838c4a1b7afdcc83f53fec58758c8c59004086dd03ea5a71bdf4624afb950136200ba4da826388754b72a424fb2dd4004252aa757ab085f265cf66104cb175a5ed6c1479360e593d81cd5a16c31f3a43d1c262e7a8e3912790b3327ecc2ae1f18b1fe35a658e6bf159aed473fb5cc1b3c090cb3fc1f72dac82e3dc0f988a83cd456d831fd7c7ed0d2f2bf791ce8093c3573f4df06c447cf5762c94dd767b959e639956738ce565223f26d3df96effcfe38185d1e65b2ca03faf2958f5c4ca35dd30806a68cfc06d798d6ea2113370d31405d9c4f232c571e89b22d5bde8201a1f52eb220f1040621c75240b132489b46ef286c282ed8e99bb2efe173b951e3ac38526a0f9f9a27c9b01830a50af58ce4ad3c3c672c9b825afb7a32e88b43f21fd93207908dfae61e975254b18eb06994888a0641e78f6cc7a3fca7f885292ef14322e19a846cc3bec6d9a4a0ae5678133635da2311f8f0a96835617819b844dca880ee82d38348e58fa12ac0b139cc150133eae1dd456043ebdd502f2269899f71986c2751dc2b9a9a4e9964ae44eb6fdfcafd6019e7729faed86b120e2e9c16ddb196890fdb13b27602aa3977e7126578f09c4e00c7c9af768e467a9131914fe350757c1ac3681d41a77e1d2bcaf8caeac0c140c6539a8d139ea6fb2d0e736fa34918aa9c070654143a3661718ec5c0b311cd031f91d1ed61fa04fa80e7c3bbc426fcf7cbe3593053226425f9fcc1fb62fa4b785013040408eccf1b219c99f9a1b9252b0cd596fb81c26b56d12b8f30a8c3c6a55d33b05392c25cbb56aecf3b96e077622552fc49852fa36d56579ad637e1804e7d61ec7d2bc25e61a0f78ad518b797c29eeeafec1dcfee2335b0906adafb54e9db538ac378d14bb0909f9de9006f0ce44044969d2e473a1efa2a2121aff05618661acddd2becc08dd4901cd0722ff2b583ea5ad26bb79dcd1c58b2b3b115793f7ccde718e43438ca5f8606eea3f0a05c8f55f97b23e743e774661859f6b4a4a08aaaad7e31f4e9651c059e4a550df5053fe94bfee46af4afef4ce28c4827ec1f669920796ce3fc3fcba37e84e7fc67f1682afc8aa27dddcc86deca2e14c9e47028340de692ecf6e9a6f09171a14b7b52447197ba679402fad4be7b45b6c818c5d8ef38fd5972f3ad0e334a27f5a2a04e48cb89421b878362103da48cdb318d9fbfbfe145c6b5c2081ee99f0534739672a108f9443c309d077d5f4c6a858aeedaa54fdec3583caf4caf2a8829ce6546ea6118ef0847f9799185785dad84d8c47fc3f86f56873bf1443c29ab40aabe7a7f00c8f0eb9b95ff7ad80850c01145dcdc353ef58dcb23a467144ab6ac31f11ba541a1ef320a8c2d6f77f324f94f39c1643ff3d149452f6abb2bcae6b7791c28de361a9e455f130a1a5de2be6bf294ba148b29febac3f1688aab3e97caa07ce76419e691a9addcbf92fec20b8b19e44d9dbddb96445ee2a7912250d242d1e6a73272706ce39b97c0194074143c5e89bf219c266d34974e96e6c53231778210efaf2b9e4c2df278b72ea4e571bd5ee436a5061a3db033429df3367e8bc703ba0abb7c6425dec27ffc8ed05b08ca733c022ad36ab1e117fdd94524ba6778f29b25b0a94351e03bca08b4a3f836b21c3de587449858867bd5adf61d3a7b0d022fe714e4c88eb1290603383fafe8d4ccca8962b78a9bb4f50b07f8759e15ca8b68fe283aeb1b6b6dc2fc839f604d23172082f459bda241e6c8ed963adcec99ca399bd521c54c594b1eecd93a54c09fceff2de743e0bb7fb85fb870ea9227c137974ba8736b26169c2764f2dd60ab27371f5ee79afade6897fc6dc37a5fe5c73ee9e100bc0736244595b676345f560be44018a506b02df4d277d9b051cbba759f9fa1b80b85858b1b126aa3f7b0ff91a923515a773d8efb16d643fd8698e57a54de8660ec5a5849229caa725a6ed769eb7d5ed0dc2370cb868ad5a78ed28b1e25c8e2328c569ec4ee2e6416396dbd337abcf43bd8cb64960cab59641072e21f8980bbfa42672050ee6c8bef0de91009d306bab49a13950cd5350593320db1e24200b044d0b9478e4368317cad8c2460de68a4effb1030777be3befa4d7c08ab2b7f4409407d801468b80e961374731cf23a6efb0a7686aedf7d38f2c961e9d91ceded207faeba22160914cec50a9de27cb2e4e429e03216d878f65b9f32898d6d8113343cff7b81d93f17bf48e7102165ecdc051f5197e13befd5b0e49fa1834e6880fc181b217c977d63bb49a467c6087c9ecc0dd610337f128a41916462816e9b3c54ec0949862701349ae8fd5200cfef4fc248a50389bb7708a18e6333266f74f98d04a9b7749dc60a84fcd89ab261038c7cf3874eb4c8385153d50d5dde056b82c3e6e74f4f52c4fc8165d522b0f6e01748320adea39c229d1605db58db4a4226c3aa18a026949641624e0ddc340b58805da6c1ac799defea2b91c1e58610c9b2f22e5e5e5b47e9ffc3cca55eb419eca0c4f828f349d11f4b4da2a3594b44d9d51345dc5b35519b79d4fb965c0eea4a8314c9d55e9c4b0371046cad23347829725c1b711bf353e14d1851a185edd8f1ad720a3717ae868708eb8c708f4d2f4da0778f1e29bb1f2993165e82cf3c59c8fb79b51e95d3dc28aa29291a62074c060f0ef76aa700ada3f506c6774d9b88788da74240e5c9a6bb38c13dd8c75b50b6c71b7172e33751494cb2e31fb5a96644b8c978098ef157614797733f972b8b71f1d0f6de00032d1477a2842d9db8cbb3f2d428768cf8f320c0c348dca66b984d418cc4e7c984513ce8f18b4e7c69a1172862519eb56dc374096f8911cbb151d9d28895d8bc69f551fd64efeedce9d80b0dd47306e057831e380f704cc050c2dda974db0af39d7817b63ca97ca0c117f630b38665315325eb9745b8bd124023e3534e037b1d08949f1f07e072998610b4111dc69c39b743112f23f4a8131cebe128b5b020b79b1cb96e42ebb18850b37ab66aa282cb186e85a31e72ecd4a388a566accedea887325b63d400dd712e9b2b8f349b0c16d8489990c753d64a266aed40a679557a45391497a9cfa3e09bf1f3437f08898cbf1364e1730700ca96061a8d729ec3e1fe3b4ad906f596c48a9e53cf72af137c4a6e64ae49a720eb0fc47a26243e95c223a4740122df3330684f599f4375054d115dea7224526dbeb87c792e9338e56398be345ae2205f0224a4226b5261602389a7e1fd91c9809d5e09456bc73f11b3fd3c55b74cbe98755fb94375dd21f141e0bcb315df2d59f90c5ac94e5200658a1bb842784abd476cacab4afafd690dcc51a36ddde2ba94c6ee20e5a493b5d267daf56582734f2961309219b48df3610c3e0f7eb4ed134a09a0b16b156958c0a30903d4e82cb4b956f3b300b465285ea23c90fbc30c5025084b60af2f2880a95c7d8fae6d2c130887b8e537c6c5598301a88aaba2287d222369cd711938590c1ec796ce903a1044057b2bd4722258e72ceee8a679b778f7df7bb57cec8e3654654c6366dec526070205475b0b6a085a9b982152bb09d3370428e8fe57ff8af150dfbc7a7a85c6de842d3fa489bea3310bf2acd9fac46048687a8483727dfdd18c5fbea1b99ab6f23f53713251ca885ca23540a88809bd9873a040786b1f42015fa351c21fbcba085eda3c54e89ac9b03c20d97fd53025d347559cec3f844a114e4d328cbb09c19cee2e7bf1b236a4a4228dedceb3a5723a1bcde396e2714d62bc12a8ed4f0109c0aa46cd708ccc9c70deffc4b6b328d6fd4510748e6d5b82ae687ca635d930fe3801de95f26bfca109b23043aebdeae34675370fb710df26a9392f62985b3c3c8ee81d3a2b99702bae52f9d7a6e570fc7b9e1a4ae3658419bfbfefa301b1ef635bf78aad94dd34ea6395b3a3e5c86c237729450d09a444103ef44ee785357eabf6570fa618b906879824494116ee988307897a3615646b39a2d7b15aaf863f135d92c5f184ecd067f7b8d6155b04d332686ab5f4a7b8a109ce8dbea94532e26dd302c94fd49657ddb0945794b70e4142ad3765a7bf1ca5c4bb8ee2b31b73ea5d713f689604ac7bf0004381e8eb96d1737c0b6782d4c4db16ff515422d38dce9e317559cb806298d68ecf3076128f8f8567a5c578b75c385c6adc3145619777d67d5a947716950281435c79684c4f351649e7bb960f86d20c062fda99180f8be470f9919472b62e8df71c3057cbe9cd224f3f915c93ffdc07d7afb36bca727f80c3c3f7656549ca38290fc7a97d0585f762dc569f9f79e43c55ece538b3a9efc971d29a39597209713f1cc88c41160daeca7390ce0ce5879952ca704119f5f4e0c753e9ecd6e5a970f657b993f42aaef27db50db2da575826452115c07a25027d5514d5c6a942a776123186b740e0809adb12175f66452543175ff33db43ba4feefba44bc23777a54680d49f3b6af18d627e7e5516bdf59ba0cac6958ab023da69c0ceaa4ac7df623a5030a84a8bf71f2ef95017eb6e22001049808d0b98a11ca455a148cc62f6020f73dd5b983770e447dcca5f87787a712c74807997fa7ca656800cc87d6080ebb811e1976dd72a5b14f8c33bbd306f454fd22dd4a4371aeaf9710f778e8da09ee67e1a2b1eedf2dcae1d1c106ae9fec54df121d61a289b54a3baffbd2db3df6e8cf7470458b1b44608c94790f7972f87bc169a06a864301980a57fbc3a295ed24d4d2fe797611ac51075319aef77c2809b415d811a8da68553bbf7137d243406caf890ddced2cd573bc36fb14a4e4a83243c26cd161046f0bcb0aa2d9fcfdf36c9cf5e8f71a86eb1a38f89e2e1d454f9e14d6bf6b7da187c50957c7e9778487106624060518fa4510ca9f4cd6ab44005d8315ccc7f9cf03b4ae73cc072b0895e3e123973dfc2b7e51fb8852ebe473031adb773c0a35209a4ccb0359f6c8f1343aa70b58890fa08147e7b3e5a869160bd3604682a01daee4bf82c8773caefa9df05521d008507462f219b22ea3a9c52ae6081579d45f495cb7f6f521de74c7ae28c63602c954bfd346b9020fef8c3bd805a9ae105e54332368e9436c15cf31efb3f4e57493c1a10e9f33ddad0612f247351229cef7c581b16499febc0e40065d826543dfe598f57b84e3d09e336e2acd7d74e9bd5dd77f3039c9a5b50a035a101d870174f2f12df32f90171a513734fb65fb3d6b2d68d7b7b22a602b7a65358a9cf9df9fda8d3eb9c2a94f26b1c8c9c4426de32b65896a605f38c099764969511f46821843d47abe6f9120badb6d7ec50e32670201e2a2ebf5d4aa9ce90086fcefb7e7ef097ff2237562c025b66feaa3542381fc2b0c825eb9cde2c475d72d998f2a84234cc99042cfab1dccb4e08e46b44434f7832a48c59baee80aabb64022cacebf4fe6de254f14f3f1a5ab49c9dddee609071b0ed8c976f2699bb6523b6b2d9a381375f05e4bc0f7aa658e6a8c1a93b117792754c73cec87d45079599733d8adcca0c2ab28a2a945fa53ec9e56952ad3da5280619a8c1238b1a6f74f2cdd159d73f081e745d040207fd183fa9ab4ed800785965f75995bc877b85dc32652f351598ddb1f91fef4353234492764ab0d7209bc8edd021c2244cc1c4e93db9926f58214f7e036c033cf55097e05c760512516281a391c4cb6da2e9d99c7298f62602c95a75765f4050849861c888f5e9ac5d793fb509e9bc2653afae5a623363871db46f49330a79c42442f1b0dd9274316f9324629c59d106e9845978a56021a86b3543693ca138645d3c1f9c4d110489631d1abccbda90f2e69fce5a83145fc6f5db3b109cf3d64b39d4ba2f2cf60722f9d3beb03e1a56515bbf93c2d23b092a014f133b86225f4a1e3cd2e45396076e642985a5dd38405375fae50419c16f6d22b8576f07ca14412ce44cd8b46ac49c43c30b8c272b9ebd06a369fde7e9fa34f6d82ead230b8e8d2812fb2d55004325fff036c1e9e2fe910858f7eff38fcb5844b690e829fa69149a71f843adf1b97eb1f67accd7594a7c0e37f70915cdbe543bfbf7cdd1d1d3eed6dc804ad7025a5832120b2c57f8877207698688588f6c69df2ad60b038e13e7bc61679a7804c6b50f1dca787d622a4447de44245c70a123b18174625da47abf54858b3cf76a2b49d00327023392e5b740ef33c02429266c15227fbc0ee69e976dcb00ba2325f2d6e899053da5fd42d4d9d4f5a81f25469e8b12f98c4142ce67e88b3187dfbdd1bfa1fafd09d08ef9aa345f77b2db1bd98848e202fcf33bb09c3aa03ec378fa4decbb16e95e4646373cedd5fa80bd9fb911c24c54f1c0ffd9a667b78be26710b268f053c8a359a9e9e563573b75dfd71396a80697d66184a95a2bad2dca1b7911b4262acf23dc95a34c4e511db59e82449cc32607c02c7954f79b6902ca50bd7092a8739a9135ed6f423f7523fb56eb60c3955a3db52ba2412381e562c609f55dc76157b33513375febf8aef4688cffffc93aa320f3098861fae0dd43879ca088c3ed496255b1246e8e57134c378480079092c31b796e5232fbc1b1ff333111f1e5455cd7d12eca18d94958320a471a2a1ea74d6aba9de2dd147d090c01d2c71ad16a2641bd405798a51259d7d4b3286d16578a87f18130406d97b7e32a46b42e0914ec93e4c7b10df1736ade97205297a6ca25488848e8f83a91900c155baaf751e6d821c8db504711dec7e1fa6527def6ef446a836e121594ed21dc5f5d1bc682aaa5ded90c8e265cdc1da421ddbcd6eb7d8544608ed3107549dc6f95a9a6ff4a966fdd2c7659d331b9738aafe7a7fd6958d218876889e0df6d9f7e09b20fe650fc175547d2bd624db20802d0c384bc6f8c4d280971a0d517b9e583b50802311183f81a71d092a181f2742e5a6931eacbdffa65714b0ea7c4df7d019fbbcb7a9852c977c7781b9db37303e0812d0b42652a11a035adb4c288a11da4c9003915b20eac66a96c82abf523b8dbe7369a504d3ffe4b80cc0bc1213be9c4dc5a2951ffd31cbe7f736fce4e3026213771e74560f1e86ea50794d247dcf175a20f5ae16dbe46e0db8eefb04f160642accf03d7aa8be0685df8bf8b66be39b5534a61c9e4651f40f87cc1e41f70385f0a18a335b734fccfcdcd0cd39f0c5528c4d06b975bd628ff03f20f7796355f07adb4ddab5c8d2d9c65caa7295876cb30ad40938aa255dc475bd38ccf2a19dbee97ff5ca643b0da25136910c563edf36809290af3f5f1d0897b93a861c2f6773065af5a5fbb4382ae0226d0936ddb7891e6de0f03224e5efaee5704db02487943a47d1a4520a29746e74a45b87335ffdbb5e0cf1b5de7cda4c90ab93a8901ef966c04d6672bf498f413d7d5d5a15fe474cfd9831b08c82102c12c06ff0e2d0f4c8aadd9d7e8f04bbdfbc3239c0413bf492b98fd2284c4d50789758b3c13a9c034a8426eb0d56a0b9e0ad599e2f2467aae2b9506b723a2f5d86983ea8435e6dbe3f1bb29aa7d7c800316430fe9243f57e7557c49c53488ee70133279e4723faba01aef87771a3650f74a6ed1daa65a895eddf566d5d7ef8e6b1f55b00d4da23540fbfd31062648713d598ef1317e3d925eaddb02880cc167abba4442ae5294f878a7f64834c3b421ccb092b2c142f826562232c355c6b0b572d0ee0ea60fb95a3b90f3bf9ff4c0ce6273b38d7d9786acf511f0154757950d8fbab467f1b99a56632c2acfdc0bef9932a8bd088f6db4bec3c9ff49b3db6dffa17f2f4042547b0c8f894bc9be00bf9017b76ae75df41dd5e6626d78e2a1b6a2b7c17c63753bb6abaff06ab72ba432f321872551dc4051969d918c2934cc65abb753c33ef859f69c602e6315ad77b41604759076eed3c64e574bf4628275985ce326ade58bb6398bf6870a581fbe6fba15be3b861ea1fe78467655416e86d322541a9bf250d1405a5648c5ffa801c39894ab6b56a96ec35c40c2b8af6c4492afef8f79d871bb6a1c451a4ef98265ccc8e73fca5638af718c07dae9d231a18abd3155fbb01aa238906a0a84bb6d739771977ddab797dbec2730f99fc1a77b01a8ea32893122a667521a3cf510cb6a03c884087c44dd335a04394be054bb756f2730ec41cdf7e5eda09ff15fd3dbb0c682a8c8bb00fb035decada1ffb37268133e68a78519466a53b48866f4b8e63eaef0d2fe41d5410a036f134cc2ef88a582fb80f99d870358cc1ec8e9cc0c41fcc26d7523dd6ed642f5671940f04a88d30a178e0094b3c0be362724cf596e3a9485c47d3f1fe7c81f687659f2aef9a99ef0efa4b9d23573cf718cb93c37ace5eb652e30d6a2615d0133943a26003da2248c5a4210c937acf11560fe571ba4ca7bf5f91a8ee86a0773c5787ad6935f5d576d7bfa770856382509e8d40406a6495e0beab94695cf63a9331e9c46c3b2b35f44467c632685c36be556593e802cbca312c72aa5d2bbdc43a74dee7a064130669fc3bbeb7719f0f27d884c83a24fe559955d09016d093739cf11bc55fcea8a687060ea0ab63bff25298270f0916d04376bce639900901fca9795ddc5369862a60cd05abafc81af706779b7e7b25c8ee862f7e8043c52161e13903af13c835fd42ab8a2c23dc7b3373916d1cd686d4a586efc27c182fbe9f9239ffaae697d41a79af107fcd2966c9f1ae38b776b0fc1baffc2b46c35a5bbdc8d6935b642715f3a4468cb07cfd161bb3cc97c1506613c6f3030da0b8760e34a4fe2e52f78e764a4eab2d1a28aa87b32b675bb90d494377ce4f2b24b61402270ef340b700a8c545a842cf4cb27f1a3c1a03ab757155f265e022ae9d88cd81ada1b54a9699c5a582e1f9e14c5918be3ea3ea87d3795a3057e575cc890d44c50177237d0f9290463fb6f688eac7869f65a376fadd834ac8fa720696882637b9e9fc76c77698a5ad2198b0f72b9d78390d5748f7e02c075d15f716db07e3d86495a0c3933c3e90373d6b84a1b490f56c5d07f673309da5bc6a36f377aaaafc23fa4f9cda483f6efcd831320fbc97791940c65947b2251842e43d576782f16f200b1ec8a06568f62a1802aba85171e4cec90443aefe7679701f3b53c12b5e490ff851df7a06a825eda65bdf1a5f330d7224fff17fe694c0769976030ad11f3f54939203bacbfd6d658ce33408b787032ce303db2ecd46362c6d6a330a61f1642d2041eb51fee59fcee2cd86b5565ee2d25b042a729927573ec9d758d65e41776644440d801db9c638e6d5da55b5f09cfde7258eb5800e366f60e70eb2d94fd3e8025e8c9b4c8e39d4429065dcc6ec5db4e0ccd0c725e8b1baf9a308f507b2494dba4e41c3c76b42449dcbdea554eb976d61c79d9bfe2464485c332f6cf9968274aec19e926ecb096aca96228646ca27e4383e67491e23616c0e69e470c6aa54b84a3ed3584bd2468d850a11f75acb51dafcc92f42c645de689982cb715f50bfe8922ea6392c8c24b3ce33b96ac519f3148537cfd2e91b7296afd070641cd1c60a395b90678a0d3ced0b9dfa95a8f0e5582188e8ad9676644eb321fe724f6e8acc61df863d328c99ff047c4e0406e13b4e19e79d9b7b010fc1a63ee217c9a96ba5224295f5abf262ecfd32ba1f2f7776496a3390f1e0188fd8b8bd7fd2964cba9d6a76b42df55ce99cf356c802bcdecec6a13db96d186352acf2a44ff454ea5d6a44c3170326bb7938ddc244aebe1f7f2eb9e0d46996a26e8b39b6cf9c8937170520de8d0073696574874f364b1692242292c908029df8922e0d00861d5028a3347341bc44a3aaf08465ffb03ddee030c8c1e64f98ccdb9ab4463bfd3c05fe6979001c97348a371f6856a256b31bebd46915e94781b1f97de6d2a679ac9f1e0231231072b2b4d1006a2bb1ae82762f2884167f02f91948c2df93a5f3457123062785a272a4433ef54f8ad17fd6dc873f7dff89ab8e9a53b5f7a6c364894a530af1f1e43cf84308825d5cec3306641cb27e5a8246f7e6486581b2ae594da9a0d53b80549cf2e6c929c4964a73318c30fe9c8cdb0cfb295ee53a427f6e7d438d6069b53c3b4930dc8977efa6254401b7cf93aca4cbfb528b9bd271b1f68b49c263f0e41b94ef778ebfbcbe7b0bf62c6c2f4c18acc297fb249897506064ffdc43d295199ca292f309f2b02a6be9f4e6996d88faba3f5f74d58f00ee89bb5261af5c10223d4df2399f3c817b4344fcba7c37b9ed8a25dd9a224cf4c72c276ba753ff620e4c1fce66f9d3bab78eb91be892260f1e0e7fb31017237843e0780c1d6fe68d47efe0341a8f099fe3fc61babf8fd3a297d420ca8863810e1c7fb2bbc85ae52835054d323b64f8900aa1650e4abff61a83ba06961e7c85fa8da963628766acf4cb565bf5182e02ef18fcfe36769be0973af83f75ae2fc717d51ac049b59e0b5455f1906649ba4af8091fb81b07f79a994b8bd39c55197e25393e8d61e0b6f54d22aed29125bb004acfa399357b0d97014f65ed4c9b5fedc6b85aebf4551333914b2b4e765267dfee7336a1efd14825cb2749d0ddf8f1462f236c524731a21c111c2e94e509fd55eaae5421c384014a060b42f8fdc038c36fd99dc2a2263d9d8d81d1df68772c0cc1ed37edfe0889f4c071e842d37c338a3981242d168107b2b5005a6beb2553838147f7445e93298a4200aa73c90aeda22de3bd5e23439046face137bcc9200c6c24cb84bc9bc374b4e7e58d668c2feaa1fdfccb9cec04b8b78716d6789f0c97e7b0f085767204939ade64c3a899edd86891867c0704966f750b0066b91823cfa260a950b356374c3f922183ee88b51463a94c5fa713eb1d00fea3c891485d100cd945e21462993159ae293a75fbebdf8643ab0f16c4a5cb579ecce950e9bc5b4d396ca0da8d80e00da64cb871d1f8a6ab3ba96622b34b41f8f16c95ceb1fd671e738223a1efb0f859f2d76ce1355bb4b2f2597d03632babf4dc1c160980714b1fbe35b49fbb4aa8813e675eee39e4d2ca2c2fe006e9c02d0e8ee696294451b09db0631a80d28eecd9dcea814ca05524c7fb0207889bae2b418c617023f3f856af076885b26510111db1f45508a71d172460a303358ec72da481cdd8c583cea83e19f5959934dfdf8d867ed018cda02657489e12fc241021d04a8d96d7b151207107732acc6aacd252d571c0ee12869aaf591ff0ac03bdc3f8d6b8d5b1a2a3ce36a8877bb3365c58bb8ff9df10917bebd3c21c870149f4a71e188c56ac06d943fc91537d05c51a75f5c2089704053d262cb708d54c33fb0cd84b6f79fe2ad5c67aa729d9d51b3f75a8ef4f5ac62a6964e356b2af3a74812c8e48be158349d57713f36b25167be3a8fd24c749f9f406af6f6dc0aff1720b470373623ab40c335c58deff0082e32083db5dc9d5512e2d6811047f8908f09f1a002e9966d3ea1c242cc82bc5aafe5b6d7630df1b9727278666bfe4a89c70f353790a06a95c871e361083e3b73f9d49ef93b1ededef8d51916989dafe3979ef4734942ecb92425b0abcd407e6a8f248b3246a39a66ceb17bd46f9a3982d334c74729d8770fa09991e6955afa63d488fde60c0d99de18f5eb7c23ad7338b81facf99ebbff2a461fdee2feef08c645435fa033a251a54e230d2ea2a4719136282afec44f5b41003a47da5c6b87aeb78c85a7d833b2478594218a6ba26ef86e9ba230910776c4a3fac7553e508451fc4d5cd02903bd6098cd844a227565fc964282aed72bca5d362e21b4871616354aa50e5275bd06cd4e3f8ba8b4972188b639c330cf6d76aec0a4c70e123e589ebe043e29c756684421cfce4bdf8c4bf6ca9d51b6e747bd464553051fdf7f659c260ca540ae7e637779eb98f60e3f104d2bbc663f53e36bffe638e9f9341151d3ffa1e81c5172feb5b11cad221fd5f4767ef79dcace773f5627d497873213ad2009cf92dc35321ad33eb4a2d713df4c692c78455cc2bb3235f458bd7a36c64965d05ab394d53685911ddf84efa9a46638e166737184bda9eb675b5e7f8051d32021c93f0c5db40bd07117922bb7266be69485ea4b976a216d5ea4dc80bf34bee2d56bbbebfdf3a12f5dae7679d449e8ac21e72fe75121ecdf612b6ed615c437916e2b47e85c169787baa958b48fc25ac89dbe50655099625a6f532420201ba90715453a1511992e98cc4d478da7e3930bd5687b014890e602dac4680e66393b9738036bab3e2ec25271e4f20e999a6edf262e44d61680710ca1481037c49794bbcc3708f271c186d2adfb874ee18b0e5f65408b151e227155df91e71c3701929cc8d75bac302789c0285963e3bdc176ba216afd9a1658caea008588ab5fc8a0f00112cd9d2d0f29238b3208606cfa56b1d22e5f333c63052e2f2f88b4fde3ba62ec2a85a1753e6a7000e7c04bc66edd9ea00592277fcee702b196527bbe50078bc986644f42d6ff267654752c844b934160bb7a76311be7541ef294dceaaf87338b9b0ceec94fbcebb2bab22933cb5cb4114dc62fc9938b777045f8032bee8b9b1e9e17ef077f66c1e7669ae691ff87899f89c024cd71d955ed6daa4ff94134abc056f5a5db1c8190fdc136fb803ec66c401185de6d6e6715ef74b216b19e89e3b0eee9fca3bc6c79dd3fae","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
