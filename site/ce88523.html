<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a939a3f907ca0a0e94a49c7888ed4862302af8edfb89be93d294d1084eb237d735d184629664dc166bbb6344878d980146e56ca03adb3c60460c915b88f45b3af668c7f852c4b728ccff7a1fbab6769ae8d89a291e7ec25e326dd7e641be55df90490fb59f988aef23f0b5c5d856a9c621a798b0d839c0ef73c742ca4fcb43cc25bfbc190596d21f8b6db5d191957972d3f446fc9b3301eda0a87d8f261fa6e156a9d28a49ff9fc9d4deb6d9b8bacfa4fb94e5f17562a1f2a4093e6b4f118a97814f48ac3fdbf77923a0addfe8f86a7ae5bbf3c2c89010e307bc1f0964e0211bb692598d4c2ff8fb281834abb5647b5823dfb92cf8fe99bfbd1550dd5fcda80e9039d37892a71e671c1e5dca9e4a0f4f7da70a6f09fd0cd3770539b63e4c0a54ccc6a8428f30859d24145db7eb411e491bf2c7fee78c33e6df9ed4993ebff57396877181a3e9e2481c49ea5b730d81d83cf043c08ab5fc3ce5c725b32a7b746183ba721f4668c7775afb317fb3c338039596280392202aa2bbc27be866c34e1cdbc5fe22ee1c95eff9d7b8e4cf0ae45fa51f617a8cfd69df08e9dabd49d418d5a0e13d524db136befbead5fcaa42ff3db5dbf18b35031fda382f068a9a04fb60e8a84a70f4eaa3a59079e15d658a2230feded8812162a879fbe147c614967d76cbdafa14db18cea9d33f7278acc1a39cda0713eecaaa3321cc32b7eb300391cbc7886cfe04ce085d1cece2152dda959008344507afaa877e365b64f23a80f9b1edf07f0f2897cdd83b903a0d0259fee466182fdf0d63514b6a2ed616430bfc2245250f10d3f3ac3e429b2ecaef43005100fa3505a62c55effea43d18173156c22932923f24da8263afbfcac69ec941e87d67292692a23d7a5fa8676f04f04288b8dbd1ef8323e5d7f69b20b16fccc152a650f53447d1072e73d393f7aa610bdf38c8bb9df0bc9d797063fac5a398570881b74fc1a6266affc9c6b2db83c5bf87e013d8f0589904614dac6f92e049c2a1086a0c97a7634d116dc8cabfdfefcb46998b322058b1ff6d593b0440e88c5a9d98ceb1a97797a0f70d81d966b698ab90542fca1bf1a93c098fb41f6c33baa7a5e8baab59fd32ecd1bf29798e563490cf4dcfa282d337af34206a6184d25c427b7cb8817045b17578d547ef13de70282413d0c972830d235a8b004865088d759e79b917755040e8e2704428cc9574293985effceaa065ddf47eace206dda52eb3777bd8ada0cb0f193a8606fd12c946477a904e09266ade3241b803da12e381aa987f8c8aee9398fb47ea80c3b8bbd8aba5acc8147145ce319f1c5928e7fc2870a78d280037c26d188766a1dac19a4b889538f47764f230cd018de21570d5eebd7475b0ec77f6b9d7b1c49f551c7baecad6abf126b3f2aaef05928baf5e52807760de6d294fb3a35ad4d4864d23a318d3b5fecc04d0f72273412b1d36b915611101d1844e5b65e675e9c66f21bcc82baa7999b4673e251ad4e1b2f6cd5fb54595900168e36dfe697a8521df6a2cd6020086e9d8326001691ff78cbf55ef1a4fa7ecbe53b4de4300cc64ae84b44cb62fd280bce3ea38382a2b0074c2bdbbaa90bccfb24d8d30a2976e88f3e79138c5b554df324b6d77f2cd7489eee7578554248a0aea98d955217888bbcc20e5c8a787e1ff53836cca1c78c24aed07f4cb24bf66ea50e6fd3bdc75ca419e6f92135829ca7251b06ab52b02181e49d706878f291ed1cc5adf24e26b329c64b99ec41a440c9e69d567823b95e5782821d7eaa9aa727c5f4de0f04e8624b612bd6a9a05d6e0fe3707f0518346c631f31af07a403fe81791c5dad86f984e0f602da5afd203b4ea9cde0eb85af17e569d101efd4ee239eb7b5bd0ad54eccc2c7fe03a6d1db45aa0391679fce3fe82d8edaa77896da16e3ccab7c0aed29ba7f1bc28069ab5b38d21cf37fbf465615f4b1437f68ff0269cdd90b83ebfdb4380b3fe36dadc6483955a75e5fd5de7dfb339f0031cfda9c3c1ff4952057100282ebdc82a4d3e9e5367e133e6e64c6b1153a77e2883782756deb323384dad88b1af6f7a4b57ea967aaf168868358c997ee3f61ed459f215afade93688030adffd97df1d7ec7827cfc06864fe1fd4ae42c5bfc31d1bc31e8d925a2aba64be03af2347240e37d8123160c7ecd394c6a9a4a30f59d5cb4ad30821dcf62ff9489ecbd85993c57e97905e9c56ecb0184d85d1e243f79ac756037b4ac61a754f6c9eaea07131d3d2a9eed053474d3d903fb88467cefc3fd66921517119beca5964e9839eba15c4d29d738b652a1fed4a15f6992129927fc0389c03b4e0c9bbcb9b00e9663310a25de920f141d681913b4fb4f80a628bd60431893013ae2acbed4e4605d7ad1287b9fa28d9e37805ad0441386128a99a2f9bc5983c3e759f8f8bcae4c4592d5642130f8597364e8374ee872e20c7ab1314de4f4cbc2c6db5772e1f09d8897f1771827dbf9db72ae57c1f739b9a6f2cb668616281c41df0d96c80e28a7786a219cc013498ef740bfc85d59b7e163da08f100d05b6289b3ccf3d6e5d1051bc1289df51e9374b56833e44a4b9a7eedf80d8574c51b8effdd5ec98f60619012ef69afb62bdcac2d2bbe92dade0218bf44325ce77b14e6767e582f15d07af9a5c928607ad6386403f15d63cc542962cbb27776585f2693b32d6d39aa84068402e6fe51c7f1d6a24f728cddc3019588df4cbd3f4240b122611c12c8df894093123052a804c76adf174adad8752516639ab5942e20e95e4e2403ee413419f989a7633fe8b44faf1826eff06fe67518f625007bc0b69dab47ab1f2080a7b1db6eb0042c1cf8e4455c22c8dd6029b055dc9c1fb23d502195e72b61b60fa36b8460f61d72c906e3708aa2cbe9f931352ee5671d4895c0a03fae91e6bc75ad6b84396426e7ac952e003c65f4f4777ce63b6f59d74e1f3fed5526763e6be55e781a2245883078b81d25e1ed0cad4f5f4cf382e977cd00baf0bea6d83fa7ffb7b104f29aad44d833592b5e4a0ffc4e9aae9779a45cdd02629fdda7f98567bd3ddcd6e6c68998676b4bdd42aeea20ed3819ad99dca96831f049f620c87a7030fdafc59db78d1959f987c3a59499e9f22b7c50ec4ea5c961335f2a5ab7488f7f687c90c6a8f2dec33240ba70c9e459535c7a9f09457ca73f09f7959a244f430376d2232fc14e89b0873ede7d94b38126bf706e784f91213b341038ba796cda77517c0a3692b68ff9951b7824969e0d7e9738cc7a39409e0276bf02697263c445eec63c919e07f6f0efa3de54047859db259e4117537c7ac2cdd8f962401d51489667fb09a85ec76015930c55926fcce0a322c5129c111360e62cd3d49c1758b4c30db75927aac001f1111957962aa28c5d49003327409c2dc518f737833cd9527b4696cb1bca560b9ee2eddc1822a8f6a50af1af3ade32539ff09be2f5f8bcc6b7f4b1d5039da04e404acab27c81741f065cd290a9b6a508714f10eee4e2e402bc4371dfc92fcbcca2ddf4c8556c20a7436b999a457bd03796a764c82959ca92def66f8752b7735e39c517869dce701163df1810493cbfb869e3170de87f393efb047a3d127558a55189cc7c82775803f74aa218450ef88d72ed6f50c760cef869d7a7a4e145e9ea8eb36dfcdd0a631ddcba586fdaf657398de454a8c25d7e60074e1918c285e5e5f685bb6b58c5464a63906d57444fd3868d6204cf9e52a64c828af847a9ad7878f33401fc6a6614787013d236efc89dea0af05a75084367d03b3f35973f52a280fc57c112fbeb7cf4873b69128d3f36bc1c0e1a312454f1b268137f8e09fd68c17a0d86e69213516214b083e1ee14c8a048c95728e05b55dd31d0fc5647ad521ea1a8f5aac5f2d1722520cafe702cceaaae88328f9bbe52770d021615ccbd651f95d09f5b77d1a81c7aec7b0309d0c92c8bd1f7cd104d5de5b36929fa69e29da4aaaec5dbba60cb8d13ae75226d8aab4f925a41efda838ad8797e8040add93470d07258406d18a02018d18648b276a8d3066c1fdbec950236961698cfee08432492287d1c307eb0241409ebb08e783b1c81ef273ebb302565e3bbae25fbbea27a5ea247fe861859308e33eba3bc312058a918ae973777cd4a7f548353b07fd57395bbda692950a7d62b949169cbe63174467a42275ca6c19471dc226920f55c8ee363a449123d7ff041971c424fd2c5713345c56ae341a1bce2fd07b9b70397589c980b483a9d2a01bfe7954a02495fb43a480cb3727b68b380b8ad5b45f0cccbc5ecabc6e957f8425a1d6c6b866306228a10ad7ad9030ebc5ce685ff11444e24ef34df3f30738cbe34d75766216870c1d3f88097181897aac166e5c9c2d1c4c9e1ced96c3cd1aff102f250dcc385d6aeec77b855a4db29f71abfe212c0f331f2e56c61fc63bde5430fc8dc92db4f4ceed8cbb5d2851451d211be44179f1b70f0d9765928f5577832c93ebef65c12891d235af71ef19f2ae829ec851b7a3aa734f6557d4fd6c9d6f8b5736a041973c89d36caad9430360159738669e2edd2b9a3da5a7c1ad7ba715a0cc8e03f0732b50977e7d1bde83cc0ffdd097ebea37217be5a69a443b33489485f847b60f1b8ed6865ca773c33593db4a3e419858036d32b46570fac18a20d802da35b94905dad6b6a41bc494cad1584ffa47f9fbfc76ade3ab38f48bc6c6e08880a4e9b659513d3699529f93ba34e039f88687349a0cf6aeb35c70817eb0a11dea1c35b8b49e8e1fbb50781455001671b785ea5d345161a84b1c38a87b7a0bb06194e13ecb7e854fd178ef13256431f99ac67aa85a16030cb54738211cfb491184ec36bfa1fb61c711164c6dc7202e2ae80d6ded0eee3c5e755d97cad268981c66783c2851640ccec42e3a06f350ecae92369561ce528d3eeb80bc77ad2851161bef5fbc5a844aa0880232b66d1c975b8cff92ab91feff124b972b0f901d4ff9a1fd365ee6ecf4ccb5789c79124f9aac8b1e0ca6e43ec2214e717bbe3743f4c2cf979c125b3478bd40157ada1bf8cd3f5cb640c1a0a5c2fe68fa4a1d56c134efacd69c9d84f85cf0b01ac9a58937bb89fa5f80797ff34d7a7fbf476ed515f63530a30e18be6c93926e266506e768cdc9b1a96a5277b01653b177f309bb7689f2abb2327094e7924ac14236326ef13fffa8762cc9415016cc15f1960abe489d5d923996a71666531591a5d27dae34ac0a62cc4cfc9477089c467a86705e790d2971c92629609b7f082aa449e718047d844d30e749d644c88f288af1b8be22aec96b30767387f06b00ae9ec17d8c924ba1da40bc0cc87863dd428c97b9f1285240e677c6034d1a2faf233dec340da07bf6473dc7b41ef33158e8a90f0f26bb40bb384e2594ac5324c0651c78e56b67e81b289c68ae2997c677362ca96216a1cf0123a63e717f2c60e586da7a7b74458c77dadc4e953b18eabe093a309ebf7d0f5332f7c9e50d733bfdfba87e3d57bd840bf24533d5884c0ff3c73ee6940fb68609fc03e65639b990e92084ed34110b17894f2e6852c9062baf0807c6caf898727d47b88a46e3c6a1c2118b0a8d07b20a8786e75dcd4a8e9733e38267fcee5f402e2ba42749100a8d92cd8edc426b4b583521cc8db074101d40ce36a6ecc62745bd4dd1ff316b047231bd74737c7c78c2fa3645feac6f74e709839b33627a4d754d95d11d5db0f3487f2ff09d546d7c25f8bc9ef696664f6c59e4adec5c50e7eee1ab8d9e44d661d19e78ba14f11226bb3cae5efcdeda74f2a9d6c717a131fbfa9a04b867fdf9efa6cf566a7b1332f498aaf4dec300b016177f340310b55c3002f0826329bd7c08173c62d49ded260045e42fcb0f8270e3245537f35a03ec2fed0760b0fff3107859f6974d3668403f887fd75d7dcf02c5b7986a6ea3f1cb1fd4be8e9525eb533789fdec784c7ab5fbc07683c903e484387282d399ce33e214bbaad19c9d86531d5b11bb267d93466ddc9ae9d7aed1e7400f81ddaf34cb0aa2acebf796019221574be7303be2d25a4565949ee9fa0a7635192f02e462d37b8021d98f200ac886fded6f24def725d7e9d4b385de8ae2e1a58aa647fbfbf8fec59b7ad7000ecc55e016d90dc0ac16c94838a7154cb3571a65747b366b6d4f9fc57fb635d88b884d63733274bf3c5efbe11b29b948eb7ddd29dfa0d1939e4d80ae2696c172e97e1ea3a1e1105fe3af2699f14ae13233906f10564f82a7380c77569696cbde81fb1a7ca001bd0ab952d8a12b1c65bb2dead1642659373bd7eb35a74113760d529cac501a83fc296f9a42241bd1aafccfdcf9de12a31cb3f0bd820ed902de94ef7dd45f37faa62b043ed23718a01aaaefe5865a43303da1f1563e2da6ed9d5201afe1e99099775d45bdfea5ef78bc430651cb622cd379c1ee54a896eabc2a61fe02e9eb3084de07b467829275a21c5622d000e81fb94f63ff9619c4a85f49057a7c8dc33b23da2c5e7f40f3e3f38053a104f02e203cd591d20b530fc70606e52cb3a534b86445af3aa0f3d6267280cfea5ad9e68c7723c33bc719abbe92c647d904d7db88209a8efa021d3f9b5826e69bb9535204ad7a8aba9b27f4030d8a266fd3e8bdccb0430e465f58348e1fdc0b7082f8185406381d0d62526288a5e6375ef0b947c9ddfe39ac4ff2c57fa1b12c14ef390797ddbc65dd0749977ccf55e1ea1484f96b26309d6675dee3cb2900d858830584d1f4f5c7841cdfa80bb97b2dd32bf31945c9c56871f5de1f2d15673d1b9288847f8c4f2042f151e22dc8b13066293f192825e9f3beff6233222d3366fa61a9e47112f9ce3e5c072ba89a06d3d3de1c3248125b065aad05024a9571fce7a4b486d5470f5d250b108fbf07b014e1a07898a8703633b9a2bff518dedafad185119680e2beea9fdd04a2a900a421efe1ae2d318e4ddd7e5aabb8945a468a327712e6fb8d07e66b457d347733f4e25594b212b900bfdb18e9d8111c8684c7c7614a6a78bdb0fda8d8d312251fae8866e3302fa76f36dfcf6fd9255b7b1bca865df9a08e79a7fc40d2e2d1abab6f229aa0b51f849305b8d28dcc30558215f4c9326d062eb684324fed500ec56fa4b218849f316bf102231eccb7cdd5624e4fbddf7aad3e045d8fb3cf6af94e4407646616d8a3221a6c632046842f4c7a02e4e894b3d1aa2442565c6b59b87d5f0bb032f384ffde5ee95f343696a710f91985519ffa2ec628dd4532e60c6aac5c507945c5587ae3fc9fb453a6beb435ee1c5707ac072696a80e8ed4d4fcfdb338926e456f3cbea773c9af38467d2b9ae9229eb2dd8b67d3dc51e425d323e55e581a906d8911d6e807af225191e00c8a669a387deed3b7044dc4ca8501fbc0f86ff3290fac47f6d67773f22ecc3ab895ac227c7c2fdfd917fcc2888ca903dcb6442f0ab6cd05fc532cada6831c15d4f62acaae84bb585798b6046738c481bc45e3aefce9bdf3018d503f0d0b067ebc674ac497a80a85960aeb2c14a7bed7b0dd38ee8f6c098bef4e01df5798ba9aca522b26f62e1230ea10b3936b69a26fd395c05e9318c7f1d558e79d4110bb6ace9b003250113df0bb62d43826706c3732592c00a19378661b06def15f2cdf8e0574163e6eb35e51ff863cfbe7de7d36b22c8ec2fdd806a9fe05ef1e5d5b783d6c570a88fbb1d370a04ee432c0735f033451eb5d02e17dcce0e27c3240ef744adbda6cef719047727b1f3781b74332ea947a1842d172365ee2ab1bfce383caf8afd5297b67d2ea02da73aa0b65cdcd097d10848ada61a5695bc62fdd10074dc26224d1f6cb5f04f6ddca3942026852b33038a327679e877d21b2752c9f7037c08c1b5d1065ed0872f1e42e6651c707075e08cf88fb0c64d1f9698018bee4a4d12cc2a32b0971a7ef8aa5fdd50226a95a4ce06fe18fe24b491a7c5efcd6063ca44fccfa7c8de155b9bda80b5204d2e9757cd708a5ad168cce4b41b944239fce84161dcd6363bac9224962c5bb49108e4d8f5cafc4867136fd22ae6d3d5b96e90c9ae2f4bb3952002de81b230cfe0440d0018b16c853923c3fc62b09017ba97dfb15e14ec6edbc9b940eb03ac3ebb01f1f9deab557567e8b1b28218791bc70a0c5153bc719fba90ae45893ae7d96cfc38a70656119edc31cc6a5fc4a3f5ce632e675125b22f9603665b94c7ef2ec3e1bf8077b4ce2e1c704fe225005dbe4aad4bbc9397e4c88e6c9eb7f5f28398d24dc25396cf409fd8433e7842f8764e497790afd40a0e26193c7095b93598c0a72896f63cebff884805ffdac1d9e03d3c8d6f26483df7a47d92f91c354eae23ab8a12561898b807119eda510aa47100aa6f10054b38bbd25692619d3ef535f5e9556e9876965b84f56f7a1c7edfc96bda10c47b54e94875dd68c75c2a36f1595d62b91fd5de47d1dcefd1dd663556e15ffc51016644130944ec1a5f7eca0c9b7c52fee20cf52c29fd9397afcf81e285fa3523da9fee8b0fb709c5117f8c34d429976e0e37ceccf6f210d7b9c7991afeacf485317e2944f39bacb78d03f5683819c2ce461e91e2f5e201fc8b4d41258e6912fade7d70a815dba625103f261f6ce522507c1ae35e29e0c72a874f4654a9f64bf1e09c317626ad48f15b06bb37809b2c8f9d204d51ae81f5b0050f9b314a5f46a9d31a82037816d00901998d0c6b7bdd405956ec48aa5a279ac9b27d784e0d7237ffddb3d2dfca39f34077737d788e5a810b80e16cc31c9897204ccff11cd91525d85b1b24aa33b9b68294a47c17a31f4a28e9d24d0e10cf21d2e774d60135e563d216ea41d13220916ffe68e05cae1e3ce97635de46caf293ca2fe1807c5ebc8f4680f526ca55d08b651f644d5daf43b22319e75fb02a04820bbb6e03afb36764ae64a198f78ec1677198e3926f885fed3ef7e04854cccab3bbe31e57ebabc58931569b62f79fa7b7514c6ec7ca6c67c6e8a1472bd57320f97d548650b7794e5d77884288d5fd851d6f6f3ccc40d4fbcfdfa1bb0a351e2f9566e01a6ad1c246f9cad6966aef6a717d868d7bc405434a748e6a9b6683dd3093f3227bf7bb5b1c8964a63c8a17b3bc332463df568f3dd6e3c1facefe61277bd4b2cfdee5d3043fb5b4bc668fd4f1f0bc9e1522efa76ef62a586035763c6005a937bba42106e3a0c3e968ef4d23f21c7ab592dcc909a005c3763c0936863bd0bb20804466f782ea23e2473e891538f52762109b7bca653306d3235f5472648ef36deceaf962fe056d9a186efab1ee21d2fa4e288e6d638074dd5875e071f421e41968542e5fc1dfdd79a202a945536be972def8c2c2799d2cf60cfb53f2900643e73c007c260c319a42f83d09a65cbfb4e7abe9313489c181c3e321ac1f25e03da97e3d5ca12f9c5400cf250eb4bd2e034b4bd1c696e47c57f573f251d0b368fecb5eb770c999ed3abf266714b03c16f8072629bdcec0f2beadd061d5cd5a6f806c9f3a0c12fcfe77f7aecc98f8578395a4f9a0cc161595081e680c262c885938130c9ff284d9c7ecad9b0c7de1159feebd88f30c9424b47224a42ac3aa527af7a0ce1feae1087087e281f39db02f78d3426224e6abd8d4d99ed1c712c13dc53d0c1237724050497cd1357b6bca6bccea0d3178e1732b4799b394a322d3cac2f6dcd1dd1f713240a189c476a8e18976448a738dc33df89a55c57601db141700ed85cbfa666f64f85711ee69e16220ae3d59035782b5e4e9126bde564b11498f3f20b161840c771039f5c08a0c006f572a7846cfe587a8413409cdb2683cfc64e8e431a5a3881e43384b66e38c1c4436aace029f9c807b4b86b0193169df0650a05e3b6ca58b9fce90a5f6265e94d0f410b56bcdd825101d9fc8e05620f9ba61c970a9582299802459a05933deb462c4ac448abeed68ea15934f1de4bb7984428c11b705c94f339da94609059277ff6020e81f9f7a3555557a1c6db09c3da447ca774414667cef47fa36fd8a6a2295cb746a6dfaa5dc884a8aaadfd6a4cddea2c8a89e137e6f758e412ad07fef8a8c5f3bd538256efab9b07015d41cec400647c104d46c5f5ea5596efa594fab401706a0d1af30ea219a41d850432babc676cf2e79f6b372843ac6c6bc4f9f5645ac5063c25130b488d96c5e66197aed19298ae0a9110f35669689d785782ad7bf8bb425f0f102ecf1f1245b7f28d26d9e426bd2594f3a2a9deac707ce9441c818c8eefc0494816e3bcec6e4fd4ec5cfcc41d31149657dec33aca7a236d9a53727d177e861b3d4389dac74f2f7b451ae03e1eebc9809c903d3ef02eeb03fb273997370bc3c24549a9a7f4b8a4faa610e6eddbe6661dc22be1b260d6c4fa0ea0c24cde5e1eccd73b5f8f2d30c98030447b6f4bdfc047b485de05605a6202138524f3f87319f3a2692debb4fa7f52bdd952668ec85c63b0e9c1b41fe61521f20ae5eca567393a177e3320466fa2d93740ad3eaf6f4c5e464f40e0e9816b066191017ac02e21dbc2658711ca2ffe193c40b8f7df73d21b8b7a4047d46e5bc840c6d42d0b57ebaf47eb2c7a1ea57af2db93b97f395e84224a3263e3bfcc73464fa4a4020ee72045fae259ef87e7e3f88fe107176d9aadeb23562d1242aadfb0c955f705ac1cef1da85f448989e84196389a2106b1694c773244077068b411500f8bfe7868efd671b4838060ea5e6d3159b9b9ff1cea17717b3e92ce47e9d6bbf38d7ed211370639cb909fe9ac32e2ebd5df218fe9530a6fd9b313739ad297b6671282263631165ff93d190c8acb08494198767de77a84232890eb26f637f5b9829d292145c45fe03953ee7d0569db8bd122dbc6311aa4b244b54968aef6969a696f20c68dbfa9b5580f184ade20ea7be54aa6af6adec94b40ef5ca7df6f93277324da0692b28f64c835fb28cd5fbb9b411d5c68abfc7b00806777c91fe4ddbe5d86242c0e3f957c2cc01f02f341f4f7ecbc1eed8fc62e9e0971ac8f0bb039b93f1592e786f18b0d8d03cb660dea90e40b3047b595da18452d4f02b8cd2ac8a3434b3aaef2ee053444931f28372c13e8d7605f849c5b9c6abf350fd00ef2cd0a5dcf8aa0389d5c6a94d35ade8a552051528ef93bc5411330c4c5348c75b784f8699786317d9eb7b70c98d2056d2cbe50faa2513a7f93e56e8dd4ccdaf832fedb5330eef464c114b5e908b45fdc7c2ce4294d79cad374b11eba10de0bdcca599737cf5a9031256b2c51a996ffce49df56717af3b6caeadfbf6b49e4780d84a1467066287fb436706912a1ec3cc3f6b6cd7f3220c7dab2a21133b59a424514a94fdd370bbd2975fbfbe9c0d2a8cbd496ff5560b8a460dd4a9bb9a43780ba513c08164fa6ad0676c32ad0ca5072da50ec665c5a0007aaca289fa458f02b31ba3bfa20dfa7fae7e522695e31cf3ea405d1339a59619d5190e9a32032006b7de3e9e44229633280064e82ee4d8b358778defa961a78180e333bfa4a5521a46f76172d8a41dd3b56ec988754ebccc9a54a397b9e902cbbe23775b2ae993abcc5edb2617fa63d0b3e65b1e3f131681ebd9ab59257936d796b9150e61bce3f59be30720df461be7293b66d0c9a3ed94a1e67bc7c2b7ad9a4dcef3bc3140037c44fda0a3ddc85b89a920f4697c4fa52c8f06d5ab284c2db3cdef76c62b74fa22e76bb9671799a7c8c46d4aac9df5af2fa1bd9c2531ad9800dc075b6c6403d676a460c60226726ca63edb39a49e9b345ab8efabc275ac9c6df15ba741f22da0555d9aa4fc00b00933eb2191f505dd5924ad9f491631bb5657e2f773e106a61c8931ee8f8d7e0dd85cbe1a926debcb83e183e4e8e5de5e728c55052d704aa6ec9622692d77278c11f1c00a2f75c6d8da5db487834d230e95936384e16b7b4f53c27d9a421d1fba65a63e1c06e80658044e4a028f30a56039135ae730f9751d9a2c6ce258f1e4e718eb283ceb345e5e8c3ad612e3242db7ac19155930c487d91c9aa6b5af7e4262676a51aed97f30b66f10070e0004ba323bfb1669dc22e483accf9ffc7355ddf96aceb499eccb1af5bdda0655da4769803d274c0fee86bb7afff60d13256c7d6692554db737befc288f63cbc705309900c0a537699b820fa00f225d35177debfc7660bbd453df0951cc1410b47c05e57943afc639b2e3ce3154c4469d5d9dbe908324e9b4cbb25b045ab872d8b73fbd5ac3577aed145e938e64652bbbb474ca8b1f80b090d432ac333308bdaf3d6ea739b128cd2c76b042f604e2ae1674ceddcef7a1287cc11171372b5c1709a5f802957b1837712aa288c740fe6ef44ca3c24d73bec4fbf6e6eb829b65a1ae76449a1b8ac993e91814d700816bf7d585a88691916975456ded7de371bf061f325b567010aacd45d7c49c25e34d761ddf344d3114b14cbce638006b1038278e85d39b1f14955ce872d3856def04874065300f2ce7a48ff8e3484aa943b3553172bc9d19cd6f99265467127583f5e946eddd820974234ff8f1b966d5c69a062e3c49e955df5b095a8de3c0c82ad782977aafc97d94c5307314584c336bce969cd206039c8f1d6a45d605e5af4c369b092b7da2b9a03586b88cf2b9c6a22427c1bd1f84b3124b183721169692e0b4578855d6c0eef295654e523f053580074edee4e9e68b0137e9279dec916a30fd9423c7f01a5fae64b3efa98b3a403d3d3521efc9cd61a5dcbfeae2ccc9f22ab51768ab51ab88fa47e5002eada991ea1824a07fca089cb91c733edb0f49d5da01cbc879a9e31c7aba07786d5be6f9464d36e8f8a97f1dfef77dba4a9f2ee86ea4f9846653c27f317d281f289eab161023ab816430dc07721f423142a3bea2a738098675a9a93d5cc7d12620354003a1a03d017274ae272a69003d27b7721b1a12cbec9e8514f8029a4f1d1eedc096785fb77b94c6150759a02e5e167af2188008e8c4c7761fc92354c9d156318f0b58e1b50de174351d603757a00feed6bf437aa3657e55001473e1c2ea5483674c4ef9f3723849f7c018742f66cc3f1b93fbc71b8c626f650911ed654bd13632a9c66f41aeb05a81e37fb8e5fb5119c988077f81616f333260946f824b2f5a40217c0d2ec3557cda891b6582cb7c63cc5d9b1981d1b54c65803c965e436fda99331dba2f100aa021a1cfbb4ac60554ae51635239a60e6e37bc65a5ce2dadfe04ff0c7b9c9315c255d714b849a6208120ad87b020b7b64537bf0013bf68e82e8a7400cd3b19533d1e5e7bd1fedc46d2ca4054fc3d52180089f3c8484b5369eab57305138e9dfb2d109912dab8e01622c3079f23b29abccbe33c0cedd38c876f5d0a53abc23804cf8338edbd053b187ad278a9245d960d6fe981bbfbb4c58c964740a37d5e4ad86711c445456eb36574c667776e1e23f713a89f7a5791bbbd5c3ec2069620d88af225eb6bab8fc514e4de40156047eeb12416f0315e05fe578ac669265857f241bfbf9d6d14564a95d4677924d23310fdd851c83606d7ba92491e84884e1a5744ba1fc41ef10a916153b38fc8b4f43674df10ad7a6b520aadd32b2203193c2d11a19ce250141173db283c43f5bbe836a7f4b72d58756ed362e523c0e2ae42437b92bc35b305e9eda62c727b27f95fb4e12f286380f8bedb39865eb33322dbaa2b707b098a250290f8bfa6672e8b80f86ef78ea891af79030cb5c1fce46d58e621cfe70e063c3726ee762c8c252910524d99872a3737258b19dc785930d41abd5e368f856f7e58a7d27ec8caa9a4c42a8c342a0445d0c17cc6dc45dd70f01c46a60f79a0d9e0628af3de11bdf0906bcf1eef6daa64c4b341545561a064d0a2e73ef525663e5cdba988cb4a3f902cef773ca675bff9288bb7f9b6d8371d014a59c31a195026afbc004d7ce7d401a05c91ee30feda03bd701d0407b6f8238e7bc3ba62","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
