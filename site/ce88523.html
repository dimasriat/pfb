<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5ad335cdd1e90ea42de01edde90cc477626eb90bc150ac89594db63de5fb2a5cec2d3c8a059bcab1c162e6155f75d7ba4903d8de57cf7d015c43cdc1ff1b1983ddf0288ee6a350de8baa978df0f5677b892c6d2a723a6d7f3f9776a936b380c9a71afc58ad096742ccac0f2fe3293b36e071765a548dbf91e4cce90f5bca393d3dd0ea6868db6ad13ec0fd9b09b39428077bdd74e3bb484292dad518cb51133b0d06bd15d17538dd56bdb40067bab7b25202b900588088f08ef434cb8f9cc599e63c0ab230edd6aa2efca2fc8f060822f18ee4a5e704ffd20cc0b906ca0987cf3ad6f06760ea3f70dd6ceeded26e11bffcb21484ac1764413f8fc16cee533203b4aa096aa45158d470d83a49889fe623a22a69158c7cb07ff1650a480dadbfa5d728f2573dbcb21b66cde9eaa2dce29804f12b65af5a59a3181afc91cb95ab0a8fb904b65e6be7f243d2186d70a6021d3b7e602c0dad2815f227562b20940c947e1245daa10ec0454b27c1f1ddab8930ed063abe6473f100d63d6643376299162b9fffcd49db7e8657f9d2f6f7a162a60a4643ed8632dae8f1a89040cb1ff0d87b32d194ed46916882534a87029e351b4196a1226c33190bab21c2d05d9af8da3e9c8451e579b78ad52106c66f8b9db2134e4948f99a511f61eb035cd15e1a384c8347587ffa07b8df51437ea23dcbfeca91e163902126b4d40c29ecd4feca5be1bce78f0e9a372c0a60e603c3c6f76c2a91fdc9144d7c9b46cfa7e0c68b515054a3068ec915d1b8d4e2666703e45147873c17dfb009cc222b63f512a7379a12ffa8b16d47c64cf27b1ccb047c0142a811958e5403edaa28154edf04c20eb495a9191eb5a65e84c12c39c41b87e7a346e88dda18077c651297ea5a81020cf1102d1255b76b877a8c686ed2ceed9e09e964043ae1be59d9175fe4a7c2f9fea88ad24e11f2a9d9aa0daa2dcac27ec1fc278f6cb31ec1ba410e70b5c26e3f84f2660e4ce2c79bf9a141a1b34a148952f272449c8a677a3a78d0038188b951d89305048062e6492640472ec008a8a0a226cc9e43284942610a6bc6f643529dbdffa11683b0e0f3aaf6087bd2f951037b0e203efef85fc93c3fb3a7f70427e608be417f2a262791d917465b9905faa092b9f597ac3e633b12a406ac363c45238eee9fe5f400b065835414187cfec2547e0bae63d7f14a485060bd423efafe9247bbe59e03682bb02ac277da39a27296af2e2415a1810a26d520fe78ef2e117c94c21a60504a2d26dbcc85f1b88bcf3731205b658278e62f61dc9a05c91bcf778cb49007802764cf9256c4464a2ddeca8cf8dcf827cdafce60fd6dab02b7b37c6636c3aef49b6227945261e68e27889eaef39295a3c0f127044e28c353622950ace99d12d3c317769246d24cb760f73b2dba0642c4a6352b9796674fcc66d8ca5a5f52c11981e9f57bf412b52da0be4719e99a01e244e6d5bd351163140d366bf7031c51bc3024b34202ea5ca92077dcce772e02667516e475dae46feb248b0490fdcdc12b31a10da5714f29badb4941e0f95c76f248560ece6c5700246fa31ad763a8488d43352dca6d4ea2a06a7fb11cdca1406e86dccf289b5ddc866257ec26d08d88e56046664237bbb48c2d5f1d8aa632f7dc5e2aa702373115052bd4e014a45154aa98db9f9880eca351818d229ab12905046ac43b6df051c898f7a4c4400ca1c2af0003a8a0608a9c8840224b58a0e35f8892fa24790d2d550d6c437e35b6521f451ad2c3bd1b45f995006dd337a4df02c25c7afc729b98d805d9fde1edf2f890eedeb5eba93f1a4f6c0ec145b7375650d3ebc6b66fc7de6b0dd2a8cf62809a5a3ddce02058f9898c94164bcb768d59d86fc5429899725bb6e7875a5235065a3b5459acb61ff47e3614cf13f30955794ae594318ca24eb367fd7ecad5231363e5e1fb7ff77878886c6e53676da5627dbdc24ea200db7b664e3b757ef1c4f4bfc99ab7bc03ddcdbec66a21c6f60569ac4d36df1a71d30e77a85e19c7f84d0625b4f8fe737873a87de268acf24448b251290eaf2cd04425957ca796d9d837dc559c8188b52b1c5307efc35fd4ce351e84938333616a2b2ab10a8e4a93237a7ce2c95f715e1c14a111876655169a26b7c9261edc5b27c81889af3f052b3b03bbc4d2a196d4806f1016722cc49ebd88579d07c8bfcadc8c52d950abbdb96eca12e4d264f1fda58e3d823918c6962c82b44dd44d040884a43131e12a34b17c0ea49ba3c826b83cd43022d43c84cae60bc60141f9b9353f0632e7cd6e2a68f24a0e707f505ee7c5e020289bbae7a9b2068147ec26e72ee80c23f0547d03c3ffbe609593e7b22b8c545c0d1fe645e1b16fb89d70b32149a6207d49f8e5b9ce670ea546dfc8e9d18f3e47a18962d4ce9002aebdbb13e3a8b9b134108095d999002d7c3242509d01c6eb64bf2a0ac7c1794c07a13ca3b5fe8ab0e2298e995e84b16e12cd9877f664ef826b7cc4f535e624fbaeaa495ca2dc54e92ce1feeda633319297120128f3347c55ffdcb11590b545f04feef2d921be88e5667ba4d3741121f96787e69d614b47fed14e9d7b20625b38fe2f66c4b09a6ad2ed080c14172a406d1a8f7fc2cf6c92e57a7dcf5c1d117fc5b5b1f514f829b107a27952e33dc5bfab77755ae84ce3aa0c509a1a22e3e42ee8421c9d18a1dacd0510d64b5e5de5b3167e3d5d55059757714f6647a8eb8be11539eef85526c72209eadb379920f460c56f6cda6b0a54a3cba6d5832da269698f42067085c46963ec1ed233afbb6c4d8ced5eb2c9eb84040dd71295547262bc70e483e9bdb8474eb39f1211c94c16634016267eb539f3f797bcb83308a5c0f4ab3a1bcd326a7ff485363f7b28ec2c45898b6d7f6b58b5eb13504a5be07b5f52908451de8acfe7742a5308bfb6948646edd30a96b29d70253d40a41767ab5791a43537c2f842212fdf1c7c8cf228d3bb9d4cb5739ffc088b597b5c33e3b1f84ba9868ad7b2faff1ab2c78db503392bd6bb1c4437f909471d84e62f0a8ae6b2354afa703e8a75a3b3416795e6a4037597ab54fcd02a4c40dc39efa8a47e5fad9b76ad3d6f187e8d8b6d5b38a2b1bac8975c1e3bc626a7fe3490d9f3a9a2112a8cc28c8287ab6c5458d172037dacbd64f2bcca99294ffc1d15ed292f58145ef93ad02ee6ddc7919d52b9b2685d4ce95e0ff1313c245c05c953e5c46716faa4bd84a09000730858430ac4a9b44f19a5c1dcc04618f2e61af6a6d96eff7c4514414e49073a16015318fb7662ca67154328c3d4705d790452483c5b8ee803bc592ab23655e320d08af12b2629fee951ae94c1c5620d9af95d42d6272de0dea97c92818027179b837b59844fbb0da66a3b4ab77f0b6cd04242f7232c4cd77c067328e74afc59b99570151448dcc8898f6ff0a4282c89291687b12e5a4f3694d5f70da6dc6da8063369e679feeeac71d1e4fbb0a818f7e803c7ca2426b534966d31f756c8c6a1590bb9ff4d297e85ac0414c043e9564d992c2c761d7c5171e35258903b018d3c51fbbb7cc96fbb1a3f7e0d127033ecccb78123ddca1c694b0eac4557bdb29be19fd474652e07805e690b3c9e95797c0e72122509bca4df802ffbbb91e8da728966f11cab812b97035a0e3890da5e34a194b8afbeb0f512ec9dc5939cb65b9fb69a3c11a2a2518d6258df35dea43dfa9d77f10944bf89018fbe2a4676f0c134d37184d523397ed5aa215f7bf58703664d4310a24bb5adcb2d401818ec95375f283b92cdc26ee78b28bc594b5c4c4a9219f675a9ec6b810758fd902c5bad1ead9f2030d57611dca90337461a24a2adee633c896656554daf1dd71242492d7363148f3d6c65640ad08940289dc99031dbf9a3a8233ca2ac61920ee7c5829d46703869b241419f3f1a1a128389d152416173190fe7ba8ae18e9a1ab058eda8be8f6e2cce7ca382243fef292c19dff01c9b70ccf7e1a2417433929d19a586bfe921acb8b95769b5c5452f229accd29bbf01ea8ce52d91c45b82be46cb3e659316278688e8c68ee1a88046bfb1ef8890ebbf3eb63578142e989b80174daf4c9f3b8be0e4019edf6021a640d18caba08aea1952a3c08825bc56b78bc46ad7648f7132623ead7d80b5e1cd590ef802c444972a871ae69b5daa5240e7bdc1118eaf11a1ed3c098b84949ad74926ef35c1dc674e532fb3cfd0e1cffe28d5d9042acb0cd354073834d32b7a7bf871e2a6e79c65c5872b0846bd5c6e4365552d481c5db7db4f3cc9fafad2e7535acaee1c6ba36e46c4498a137c349b93375b36703be106d025ee568b5dcd12e4d5929bb4915ae79e8cdc18ca994b2b161d6216ee0f62dfcae2e3ea5b7e0f96a7d4765a2237a2efc7a402165b8edf9703acdfcaeaef5265de4d9ba0f3b67b7907a6fa3f9450fc0e664470d3de0270502b76ab79e1b655c74bac07f0f120497182fb3216945e55698635732d459f6f37ac320955610c47293896c7d5f123248fed7af6ebe9de90fe237f3a5ddc635cd7bb750fbe6cda0c7d9786d189c04dbbc93c358c19149ad386fb6d7f53d9c167deca8e844fa75279e3134253ea9ba5cf0378a42605817b9867b5767b5e332ee7da39d3bb0b4a23aca39ce0a6cc01dedcf39fc71195a013ef9b5758f2c242fd74e7104269c4b534e4a992ff2d7e6ad101de750f38f66988cc017028edb741186760f9c6644a7bc1601257f5337a8d4057bac4844bf6c900463e585bd06716cf3c3688976ecd22392248d755c48ce6d2a0e929e11cc2b76d238041918a670440627596654fd77d6df1331c8bb69d9f465edd192879f9cc4117e88789b2381f2938f2a8e07638c23a99bc65abdaabef79fc55e5791223601031aa59a26c6c1c6cabfb3813a5c4fddaf80b195b93905e3609de6439a6be5ee507e0a8ecb3738372185fff763f27618d6fb2bf10e4e18feffa11261ead67f2a162b4533124c4e1b2103dc580121ede8b525db813a762931925b89f3cb865fa471eb223c9b38b83bbee5308e5a72f271a69e08203cc68901e230b6662b0e4d4d67aa027e042ad6f96a3a205bafe5a10616a8a812cf213a01249e193260bfbdb05d928cccd6c54be92a1b6fc70bbcb740cf75f5962fe8cb8231f2bc8032756e43580c39c17d2496a3bd4b63b28b34be308c6f93d7028b55aa23be1082625014fb34506b42d461873ac4a66a5b55b8c4df08b7f5ab72c8460c12704fa277892d68542a5811bd82b620bb8991ac60bc4579a02acf8f0b4840940eaa34f87e97146e4902f2bf0fa082967aa94275883a454f3ba547abc851acbaa1995d6b5d0b7de3b60675a5c1f5e1fc6b576ebbb0030570d4abefbe556ca68355fb73db93ea67ecc9ab32695ad5bb55d838a3998c4381887de830d7f2ebd5c94709eb94bddcc3313ea5c4138b619070c6e4277fc96c651935a2c6d5628f588bf27e0e327c852f2b72cd73d0f4ed52be4793892455f968b6f3f3a75d2226e6c94f034db92859044f7f7135da77d8bfcf1165f5604dcfea93d043daa157d75e7655ffe3f1dd98cd9b81eb074b10e6fa18c85b0659c13d733a6953a83216fad36bb8d809201c937ea33c526619b10f12121cb22cac62b8d171b7832d6a794db94afc66e42efb8fff82fb492fc618cd4119fd28fa6a3d01e58f6b1b66319ec0b95949dc637af309699ae80a3e70732823f1b3af1202e9d88e9ba757303c3d65a1c59b4bf15590c7f22c5f7ff7192332899c9cd5e4b247fddc89f16ec6134d3ea5f04776c88421eceb20d6f7f933ff3f97f9dd5b112c1b2d30d65b02fffc61e49ef7726240b7d043bd31db9c27484d563f7567bf0d087d69ae43df1293b24da65671a8288f0684ce5808b4a6c35207f9b0dd72f77c76a6b5b2e03ceda201fb689889304b6830aa0232cbc8ec7e6801c89ec042e7c38a9018749d6b85d926038543e7c8260519ea83f3b83db327a110e1cf5900626ff4dde82ac725d69d22fc2e17dff3f63689a1585861937dd61a2448aba7244236f90fee24ccc67dbb5917ef1fb68f706786211d22a1d9706abb40a019223816bdbe06c7a733d929c0efb73046bc0164cadf75b650eb5821920eac5ee2610cb5855700ce89d562a27399197e39bf58f9f1d9994988f0060dae47ad4e53f09760ed8fd6d397ecb44e1795c4fb0ba072f91be630c765e183c730b61cc4e46895a28ef115318e3b2223308ba76e9c236f71abace3cdb121bd29331a67c9fafff2cd4c310dba6ea6e33397aa1285c2e097bdefbcf9410f7359e7b24e060ccb7308a517d6c5467d67b1960a7ff5afe734ac684a4343c944ec0e6d10595112056c2ea44fd26f2b17baaf890295913532ac757c7fffe55833437ab5b98f31b153800cca562bbcbc2ec816e0d7e06812fa0b0c320a354b23f403f841c48d94f28806c4449c777cc378aaf6f3dc1086cb388b3722fad5b9d2bb54ab7f657d06a2102ee2c285089509c6e52043687eb77b07e231e53d9c6f98385953099e57bbf8b9a67071cf962a50958f47ca2a3814ee3dc06608ce7a6e8d86a98df5271a071b56d56493b164fc40b3349c5e8368681fe74f6089f4c37f4333468dcd69cae0597de9b508af22b10086d1d3bc4d610b70c15c82d4330bb0786db3a7cea9e884f25b2e08e19eec739fd0167ba658b69f662557cd44efbadb26092362cbfba0b4c5f787eb82b82ba7d467e252d90932f88e70d39efb6930258d342429ebfb37bab06bf92b16618278602431968efa764faeaf43c6f68e3cc8d2ff13503793cf427ba4b4ede5b17a6503520b8a55b787b1aeff10dc5a7a524e4181803a8931d0c0b959023adb9556fa538217373799af517f3fab91c91236b882d9b44e0268381fe19b5ed3418487e8c580516f8f03cd4c36aadb5234c84fb21906b216a7b8a1512ddea7d5db15c3bf2ffc27dd2f310b5891df1d3074c22461ad7f7c23fbe2b9f5d8645bfa4e9be95c17a2cfa6acbcf3a4d9e519ff1ca53c01b5ba45d89076454994bb815c0a11d379545d25ffce7f169d912c176f6fe38355fc1e0eb4939588b4bd8975161224187ed13757ae994a359241a25131b0b84ae7878744ce4d51b3822d9be2b5819cfe3d03993bff5615fb7863f463a87a1acca6bc3c8a72ffa553bc70c4b0ce1e8099ec9e957c7f9d25ab3b3aff4003f9ed9e86e03609c61c6d4091b8257963c20f1db12cb3a70908791d273326aa008939ff93071fa001963451a045f4fd162b036039996194479aa49211effb5f5bd6b77f52fff3ff70f309f029c53d8edc108320650daf8a0dd096b37de690048715cebfaeab8a07daf29988cb5086d5bd0462f1526abcef8b509250e5ed418d8bc8381796ac8496f5a97bcf22a2370be713662431276526508cb6b3c3a4df1a5f2153dc1c70992bed34fd7fdf85ec66bd3b817d16545a069bf7682f4c179591096a37644ecded0770c68c99a4af10323eb60015b225d5aa21be0bb06b60880b446c4257a2555cd35908e711d1f2b19efbcfdd4e5feb18ecdac12e89c9cb84b966623f024d7ca3afcf581271d87f0f999bb803630a6ca2d5d7107187cb6956b43bea93d98e95dd4f0384c3d43a8456fef69eaa4f4880db7a9384a68731ad874122225fef52496654d1591c171793c40a573d936de9c08932e7ec4977919d1e0c88b67d3e640695384442a92574435ab05531138841dbce96efc5f2ebc77b98dd8c185e09b5a505f0ce92cec0107db09d95d8d821dfa26002ba4f51d3e6eaee0dfab8b1b13fae47e05a439fe14d4174c9e71145182fff95120684310885419a4424495b9ffa8ea88509674e3cfd514c54a29060f6b67bf9a03fc7c2a129947c9e588121f893ef10d9f058903ba2062af21589360f8f0109588b2234bf134208f0ec8729b50f4f730346419f7e97be4583b3c8db811e89f774b2a6514785f5730f526e51b7b0e002c3ae9628c88d57ca98b5dee485c27e81da8fe1c4b18f542352ce0943b68cf4c25c987020639253a0d1ef8cef75525ddd70f173ccf704c8d18404b95f35cc9cbadb70855fa9e126e7453bba3beba083353e80cf5e8a2d56e05a44e99b389c8bcc0fb4ce43ab03215f86811cb503960593802887105029c9aeb298c0e49c01f274250a9cebe09a67cfd6556e5e31fcf40fc780cf79b45d5edc2d533efaa59b0c382147f7bf4e9cd2ba224543b98b0b5522197d33aa4e4ec9ed3de4059580235b0261f730a0a481a47ea85c8c7f7934bb38802aeaf3c0d35fc9595fceb21915f542b647f8fa07cf6fb7bce9ceb8feb5f32a3357358e58eca1cd85100887d22b82602c8b22f1e2977fcf9bc7fd37ecf12cf064a6a54c8e289179b90e8fd57463ee7e40385569edfe5f32101c1facabc1633504ed8eaa9ba1aa64fc741c29d6995052b91052c1de9b2a93f615a683d852e9b75ae9bf62bf0752c4ba52981c23862bbfd92419e6db567fdc66fcbb51d45275e580ceda71c1153e06bf3dc3560f10abdd7c8e46f8f523133c45cd56c2d095e739096f0fe9d6d733de1923042a73ec700c20dfc922e987e2b6de183818c4b7869515a5d27f5a62b54a86e9b42399cf66db90cbfafe6da1d212002cf8042f723090816f12af93ecb448195dc0736ff933e698fe3fa99ea5ee450d7eef98befa198478622d4e18924e5c4daabed4703cda63d786f29a0fd8fb0029e7ec69850a898850295d13870bc6bb277035d252db4ecea082d43af5124212dadd75c83c9c99448d37d5f8deb43a294caeb539931cd32a627eea828d46e298aa3e45e286ced72e776f8333a7a68d1ab85a1d34c86c760d211ee01c609a3bc584e70d9241f52a5e02e7addc64e9c304ecfe6e9fd04fe58129f00e28855885b1f5bd20bdeec9ade3cc99a530fa208f9f4a85d35aac144b0cd7ff30721b49df3c420c4f9779ce4ac33aedabf16086c254f6606c1bd47bb2da4e3a986e6f41211799d204c3dd6463e1f521207d0c5325c419d2548db17e7c216a9a183a53bb3d2b445b1a908ff9448b088ef5d9ea55e78a3873242dddb5118cb7a2f1e4535aadfb3d42e71fe954426d0189e03bfb5884852cb7afae8e6a732eabe311371b81ad1bf229842a3d998a19ed61fd12b0aa2d8b542d7076feab4506d62c86d930ade050a803acf00f2b7776c6c75e338aebb7e6a6d4e377b2fe04da7fac1917dbc31bde2feff610e0bf06b23071bb1c631fc9524eb66f81fe4113e376e6ebda5d4ff5dc4a626c0f62c2207228cfd90ce50ebcf3ffab7a7733d165b0579d27322969c7b09f926e63c484deaf0d7e3b2ff85d9fe34d87c96fa0db2f648bf22853624819386bde22cdf171ba718f3d2983006c8dfb8235b9e3fdd3dc64f7a1ab204c3a494b3f1706b159b86639686a5daa6892e4bb8746c4a7778e36d0681f1d37bfbaf8660b0b8ef50a4fc089ccffd7e44a15bc98c857d7ceb59169ccab841d3c40c80a4e44f69c8f57e77dcbae06936583684503665bf2630af2716daf44dd2831e65fbe7ebf363184c61ebb09208cebf34cb7a3c90f7495ae495f0246f32792b0711e00c78aae3294fd0ada19548301200e3cb1dbdf329e42f4d48eb313527aff5dd8d829aea2b28018dc462ea8c5208a25e98cefc1f808e1517ff81d079a3f159c0c5a794ef22dba5ab6d8b4d7296e3d58f24f10945dc2838a5bf9ceae4e17985d2986b4c4c0d27d63ab89d36a79f0a546b805dd2b1c4f4d76aa5721dd381fe5e68d994cf2210bfb4df80dfc6622a6e689b1ab3fec4cf0909e2e26e0d3a92717c3ddf6052cc64d8e3882d09857e2c4f72b14cc28da27d718df48859c516e9e30c6da6723ba102f7fca272686aa727066e5c173467fce2031102159baa18c1882a70f7c2041051c1a333f36268951289c902e4f88976f44d72eae8c66a682340d2716f0ce4b9e8884e1fdb64842028c87541c858839b41fbafea0207d1aa88108f2ce6840c296cf77c081385a5a8aff0373329fd1a81817b3c96862369bdd01ddc2a9b82d35907c775816873a3774feb5060f59b53172ad1a2d8bb01dca57ddd0e2198ed1593f88a88ecaa9fe9be3c14290b9e712c239c79c89c948f7f71bc92b075a78b8f9e28ce9d351c2817ca8d395534dd695a391e3320ae81166f053adf46c1f67eef0230e73b98814451e3331090d65c996f2ac4c711218d2453595ad6fd747749c0a255a597d7b7cc3549d2dadb46263325fe3c47b257801fc064b5c239bd9aa0b180fd2f338864d1f166077abd55ef8f8449ca0526e99ad6455c0d8088152a7b88552e12a01b93d736b37e0c7ae8d3280cbf3fdd35045a672132837b55d7bf1b91626204c4d32e7187c5d5f7a5c1920729b222364d85c99d82fa774a9e71caae16a33e4ae644b7799ee79c4257f62784a6f6dfc7314934d398f282015dd77044a252f1de8fdca1b3f8ae94e37cc0a80d089e192736e7f602e9f1366767f7fc5f5e62b482c0457bb4c4f56b38dea9dc152127a30f0e1cae923efc8d9e4900fab6e6acb8949bc3d84facee971da100747d28302d5bee8e8506f0e03fba5e1120edbd05c83e11e6c523d1e8313733388d3513a4a72b43e350e0f70f4243e5939bd5d75176b9e58fcec0ef6cc216946d2a0e7ed081d0c64e4f3c777ebab728798cdc77b671ff386ca642c6a3ee55bb8ce456ebe0cca6a89775783a01c00cb8a351b6375533ad248a199000cea3250fc5082d20d47e66662acfbcfd593a3958863d24543c3bd113b69d007abe8f0c87a76cba79b79207b05c58b1b369013fa460c2ca4dc2f5227172ac21395f38cf85a698db674716990420fcdbcdc93a0a76bd3554b561618b99631210d5f1b77359c4f990dd09308b95135fae1c9c2b06968992ac9867fcccb6d02aeb103b0ac4f1c32953299d68ca02475bdfacc85a405f28c80a9dd6e9b80951a50f39ec31ccbc7a1e0d70a375f8bb8757803bb9f0baf87fc291d14be5650e219663f409552c92b4d92d308ad32411680c6a429bd4c31c25094e3ffc1c901c152256d42011e0e8f139c9434b5bb97c3250ec8156ce2dfc1607492eb78c9ea8211aebb536da3c1dee70418951be288c9b0b66a7cfec2cef56d2fbcf6877a5968834c55a61f1c1be8ecb4209bba75072164e370fa80460c0cc9aea3018f4364a5c9f21186dc3ff7d9536a9c623454c77fe73b251a2c2997ed7d76e978e17aa63841685377891a824afd3fafd6db50f41f2c2cb6a8b9f9c18c266651096fa8634fd7ae618e7c32e8b93716f6881dbd1eeaf9e2e9927040327ed29708cfb075f045d17b4fdd3acfd82f35e038ae83d9c788981cf29262acb798fa383ca7503eb0ed44f6b1bf8c23e7e03f5f31b75a1b9a9ecbdd1af7778840d5b86dd079fec7e022e90d5e22f24e0106b24544331bc8ce53d6e551edfe10d9f49b195e70168fa448e8fab826e09cda7abdd26dea2ec19a11222136cfe96a1e0a5b3c09f9e55870c49e3fff8669602967d60ad639ae991330784887deaced1c9413cfb9282c8e2aa93c37584e4afd7af31db29fe25d9a25b7acdd3448f01121aefb5322888c8f95ceaccd8197573ffe8cbae374083a5cddbdb1568e6b92370af4ee93f30c7643ee75e3c5c5e1b5b2b645e204a1f0744755e55677a7a4438b0de0ebdae3310bd8001ca2d02160048f2c45914ba62ac44bd318acfac75d5dc3b637f7557655ebf163978a357e7074228132194154036e9d9c621f1faa19074cb6b0495642d8bcddb2f8f7c52de45e0ddbb007452402ef39a0eaf8a091a7cf26c5e036af09404c396ea0fc0626f7e1978b31b2697c386f4933ee36ae2da54f6d486af024906b1961c272baff78b17921ad87c41225d35e0ee9b42ac54601b390d8e511a4ec0f84aba30f4445643b948476ff11dc561fc41c04880904a8133e6891b979d5fcad840b7fa624e820d76f6061ebc3c6912c99bcc90f67916ceca4402b563b2d0a3c1f81df4cd647a94898057f238ee8d2efd93f94768a5d1823909dad1be05ed07f2a48a110c720d702768a30ee484141dca959918c86d898aacf6c44f9ff447b746b7cabb91c0c19a1c0892c0a208b585c940f8ac7d633592519165582b42f6b7451252b4ebc55189fe905e3246d279e89bfd3ad7baa9c4ee857f7c568b751ca9e23b95651885d59389b1b08219412be43ff24771c989b4b1e6d3dcc551209f39ac298ba32896785bc7da65fcc66e649fb6506f928e7e838f9c87d949ccb957f171498530c8c607074303d96fd087c0e7e81c360710854d6247530b78290324321c0211c2b8b119421e81ba109f4bb1056540f9009b249bc0c14b703d6d4b7ba46c24004b5c4d081e920da0d85433faf270b5a0c32c31c8bcfe30db180b5181e844ebf88a32e37322640eb08e86259e8f24ab8c75122cdbf9d9f8dfc38ed8c6a7c2e61bdf1ef43a2710880477930b671c12b392901502a1085e05a788babfd2e2fef3ad91a0a28567b4eaae3639a3c6f8a201fa78e09c4a04e422b78a6a7490d499a4e1a70299d6ec93126615cf7a6d7758db58d126d55b8c2c129cc8813dac831dd7c4bc9a482885d8a27f1dd8f5aba21c7d7e9541837a108b7192cfd90b85d419b133e1ec2226d1c56e24732309dafcf0acf36a170bc44e27c1a2cf70326b45cc0c60a2173a02d1562849970ce5c1c25ee6a49be058b8c2f1d8d327e2595f316b0d54244e55a95283e03f6774a1e0bd3edfc962f74afd1e6a15ba8cfed99bc96ae625da375ae9b1bd1112057b47317402efcb5b02c4acabf9cbc4a28ef358948a0feaecbaf9cc220e070c1bbde92b10f44d87ffae5e163b59c7c3dd4a8d9e218b2ff3acabd48b020d8f25f51c05eb0213823bf19cdf87d718640ce438be16988566d4c1136abd4456425dbaa17e3c25c0c9d54bddd7c1f6aaa3ac33a6fd67e11c8a9f951f951d5d00413b1678e2297f0e8004847d9c923d4f5bd696ba635b0d8fa64d9d9357ccef9e14ddc27694c1518971a11eeec297edc7980a541b7e1850a6d17ebc1280c5e9ea54029fdc95e56924055d15966fbef10bf55dee9e33634fae862905bcdaa2ead1a9ac9463c8fe3d56ca2a8a56a57bbb8b68585471516eb7e2604e1dbc0701baba94e909616fe53ce0d579972a45f1b61f1473a002aa5156defec888954e3c90cc29c3ebeff7d9a2dbe7be73bb2b2b400c18485659db518a816d80165d0399950aa94e2bf12b944fc779e32feec5f6705693a0b883f0dc7405020724b19baaac819f9ce44fd5b8e6ae2757ba9f6cf4b31d4a9cf2c2c6c08c8faeb21c70f7e2af2a9bcad122c15c2e65e88de51f58905889b40f8342f4dfdc5cb9cd82255f7f176f1447471a3f58836be2cd99c06d3cd5ae1db937e498466d719122b5fa5a529a87850993c653be249ad625f0ee2e09617b151bcc0b938b68b221fe4e0849b1d058d3fc28db95274d26314b86561bc3a4827a374ed0abc9a2ff573d24b1d1242d4d1a206c6993876166c58e439678a71f4a4593387023d2a674014ab78beb61fb505925ae6ceacbfb35b57f82c9210e1147a318dd42970ddd95eca1210223abbb120266acb957c44434ff137cc7610bc45814f10581d20052d0dccc55041f64372d9dd8cd53867624f0d2430d9214b0383df4a3906990ca9d1c2cc3f343629573044d7911589a6e48ed3f1405fc1a2f40243a03f8afdea0f941f0ee6ebce302c84f09eb66fe92cff5c861d5445e78a9512591f0e9c4babeab71e79a2abd81a636ad2c22966ed1dbd014f450d1036428a1f9a22ed672faefd5e416fd1b139cae155e21e7b6d57fa8c43509e221c2b4d5a37100e9a90dac093c199b0802720d888564621b3fa0ac2f2db637f89e9b40a32f6e32fc13a75706ce0c12331fe9159d5a932baffd2f5248b56aa83894e61477dcd00cccad","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
