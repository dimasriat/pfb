<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"381a7217fef0fc8eae764730c71a356b6c6385b71f74577a0d11956304ca68f0fc2f6f159f9141cea40119f59f546f5034615c33233a633aabce8659d5b46c4ed8c25860e5df088ce8cbf58ffc37c63fa544be96d2b59ebf783df76fe2276e908537974bbd351de276f80d31c05a1cd9c6d3172b45f2df68901e7394e99c285e8b0639590065f152f6c9d8f50988158c34a92f46c0c4bcb2099bf4ab2cd1d9e1d47f8d46a7ed42bc8d53b3e03e7cd9128702de47032d19e6b81ab47a07860eacef0c10cfeb76711c0a920e83ddcbc1f5ec873cd3f8e0c28317eb737968244d596004cdc826be68e21931c85c060e3a68d304774b0497bc14b9d251ef468be91fb197d7947b786403b61b0792ce67ce295dfa759a4cc03296eebee0bb46485239d78f4616be4f0c05f2dc1233f4bc08d7449ccc7f6303e32674274c20250ef2b0134d34f755a718361acdb6ebdec0e4e23c87eed8aa5cb26a34a6887161125cf691b39be47dd616bd81af1407e4914d4c8ea445520ec86ee9105aacea1f96a3d849e62e1cadbbdc831f592b7ce8143f40e41718781c40eba42a1751cfe0d617355e8f7c9bbbb7a4b2594a9139c88ce24bcd9d6cb75c46ac59f2924272e292385e68db32ffc54922465ed5f01d072128959c2668f35c0af53208e61072473a062c5d7814b33d71b1163f25acf254fdd4fa7e34012d9c74059bf025dc38dc9bd7d3f00ffdbe80e0c36b7add29adfe3d341d6e9fa73e0707afa67d478c3207b393031c4c358e77ab2fa5db58950622ddc0e4d7b676c14550d885265f1f70b0f38f8d6e7dbbc9f80d4fe23a563115169fa7fe5f52fa805806966968b028e3d8595c4e1bca04dc2904090973b01d5c590a4ba69805096261db4ad04e73c1027eea2ebb32fb10986a8917c862047f3ad2855edda57765f394fa4873b4dca33fc8490632513e02a8aecfc56d446483f946a4735678673314ff1732b59b2b8aa5d06f40312f173594a0ea625b74d9eb4649bef3b6898f4e2be4729b088af197306b23be2c23b5609ec45db7f3fb9aa4f7eed4461b94ab872a25c697260f8e4c2e41c2766bfae6cd5f086d843697ab3e1ab6d664e7da677508a152817fe32e0dac4b58496aff01fc59e62ebd300ed9d1ed2f303714700492ec171ec45aae0cb5fecfd51a05ec50dbc6c9a595b71f927dca666250c4be868601e34cc2ec5b76e09e073a5190a03621948393cee6a896c04f89799c7ef7e6dd3f657583fcd6e755254743eb5bd3017690b0cb06099e9440b42a5edcbe7188940e9856773014ed203d69cb2ea7af06a46d99c221d5bc06897db18a56195270cb65a4b5b4c14b4aa477906603a3ec480dcb2e3d5f211244818637ab9924267ecc9e8a368f51a82136f1926dde127849615d1e2bb3268051aff462ef8878076cfa0dd3f285bd5e706373d05d13ea4dfc1ecfa4ede3c899db887dd19298b272bd96a119f2a89689b7c2f6aad46f776c2da17095625528b3e61b21dbd6442b2fb15ff459b342f87a940f8edb3756cf4cbd68d676f75b97eb5a2515f2f2cef0453a6fd4ba236c891fff41161d42ff11f84e72e1582f981b28c5ad2f3e2489b0204be5d05608f1dbcceb472b2fe925916ac62fafd0e6a48327ebdabce85453724ea98a73fc46bd458806151aa70a3b78e4cae533a0a87166f09c758e4eb64bfb57fc24576e961784ded50bda49cc4eb9ef0ccbc26202eb00dfc1f912ada47a7721f7a61371a619b5cd83c2ca3f996dd9aa032b227a4b5a3d074c6dcc2e43b3cf48f5a33b4708ad34a5a61f3d4c251700f1ee726a227bac8757b0ace9e3c585634a924009053a3dd9fd9de0e9724cd50a6980f5a7fed6c85b838a43826bc8b6d62e682f6a85f312ef076582d5e9192f638af14125ada882b838b56c0eb904cf0dca8abf162e8e728448b6caee440e6905cfd780cbcda40771bb8d36a08382dcf6d059e217ed99c08113f46ed467b799801b497ec6b9a8a549581590e0f5d140bbf0d4a6fed88490b940e8ef36ad0c1238dbbcba85c08100040591ac370eae072a9489a6f252f0e2966a089a6ac4fa5f95d1bb47711e9ed5132f07c9b017d292ce7e6aaf9b09bd56fbac01daceda670d8755b4efeda17dfc405cad9de72aad5032a1ffb126b52047da7067b3d5719c856eb57b0c6692f00bc1394a39360f4a733a5a4a8c03c1079fa89a9bc3734a22b80e3b70e5e4b98a6fe06e558142681c9ec5f06e741ad8326fe83610342a86f67dd609a15bc1ef40dc7df67869b6f7a03c17df785975b8bcaf363537ebf1ac2aa0e5268017c03dcbcd8a9eb56ddf79c62339fa0e090eb8882aa010f06bc413b1614f7658c472eb152704cb161cb6649059f738867f8203307946ac7f2060824e96c2319b00b7c694c5cbbba161084a0b521c54c4aa9a9181832836f778dc2ac48b5ea3dbbf06cb00ca1f8370ab9e36918fee5ed5f5e0348dd186724dba6e0cce70a1d796cf3472779b3f0c892db2e55ad6907a5b4bdd9e163e77683f5635dbfebde3715f55ea7d3426dcacdfb0eefdfa6f4e72e815734ca25359ba234c0863e9e28cbd85183d0347eaf6cd9dea7edbe8ab50d94dcb71908a33139e59d6c7d0ed7557a67b366c793ad1d438ce68255e040e495bd02b223b888bf5ab62751813b31d3df224323aedd5345748f1de70362fa27667c59ebe54a3882450df44253d33018bc09cedfcac7f56f6dfb7c2b182fce5ac82b74179f637f2daeec4b03f543a6ed5eca9331aca30b474183874fb8fe9216c55f3f6548e5a398b8e2ac340348647ca6a54156ad6bbce49808f12ca52f61fd37f844387d71f395cd9399ded3c09f927999b9cf26b9f41ddc6805182132ee9a539c3a1aba021dd9d91a0a99acbc9e030ebc6a57e4eda5d2278063d51cab70a5444af949a327da17c354ec38a03ac18e75ba6df52b935fe5122ece57599c1b6ad1dd6750649ff0023f1886cefdc49c86d6fd9b2409bc4b107d1dc709958dd29b34d80329e9a524a46b88836c7ec4a6da3135531ee95ea0d13017847c0b64bd793fb80b042bd2c3736e42cf71fde64023e7c6390f637cc52f25f77b8bd7187435f2d106bca44bf17060d5e82c1f7fc724a074412f930607a9f20e4e341f923c9a451b01440bae82c6127a3ffbdb64070afba53394928bf5981b3ae901cac45d4995ace55d92f2d9ec2c5332824d0e27b83eb4a6a87681948538688fc0d0c279547c0b6947683ce8f4661952409ee9eec831867b8e5207f8d16889896f0b497f97cfbf8f6ba6fd7ae2fbff7a6b4b16954d94aae2533ecafc53ed834bf39d3dca1feb4619aeaeeea7ff7126bdf3f646117410312cf582973dc66c0bdc59cc69bdef659ccd9388a57f0afa26be3b746a0549d65dc94da1490b79140db23a1d396fedb1f8d6ba022b29c6891a668749ad052ce7987b95fd883c58ace2bca0a90edbffe34960112acfcd8656a628b5077888060b4cf17888d77df77a492831c32e9075033295fb77583f7057adbb0811ff83426478c595f384135734533f893102fefdfc41c7d23fd137e110ea5fee384aabf64071aa1ec4215ea7d2e6acc2c164e6a2f7cb95cb996ada49f2becd855005fbe168b1854822bc958bc580b77b69d94d6d3190b09e82b709b3b9eb4233d165e33dc901d220fb83adb365a831af2e4540437a64bf820509917ac5f49cefc5d014c703be395df2f5a2e6df384dda73202bc66567d3c59032e5b8328c19efaa35493054d933d495f4b4b3617fd31cecc6af131f1b93033766b758879c1d78948556598b6e3cfc6a6086554a7884f121b31eaebc4e46a5f9de3db5602c965742ed4b556fce9792fa24ee7aaddd667e6c05b88b08ac04f10c01fe08aad27fd2e819595eadc8b731265ab30d11118b3ffce9b33096e1251aa82751c2a51a6db8b5c47b44a7b3d167111811ac67c3dd64302f4255f2da004ddb2680b2928733bf492e897a5df26cac9ccd7227d732632256b09c5fab617b3b8669035d03e22a5253aee84f303180d8d2b24badc454f5a8e94ea147803f5a736881faee8a7e08cb06b5616dcdc2d223ed5934bfe4f69cb49ba0ed7ecaaaf19509735b5ee55d55449268476447333745a6496687160088be8f69e6c76f038a1416eabe0a6dda289e027899c16aad6af73d2a5914d92dd47097335461f1ceba419e039ee691e8cfe54c441ca371915c845729eb05f22eb248f6a05725b74715234b61a996da24be6a7b310ad9dd9890cb445a6733be059e23049d2519c36f62c95baee27926c9b52a17fb743e133ef8392052407215ea0f96cb97400fdc0f8b67a4daabc52f0f6084838e508ab7617ef05024e320b9f5df56391d5c2648e43bee2a76353920e307b79aee09f1be1d988acd8aef1e2023f9f52db5344755f092f3082c3fe85f393ec50b52fbef985d147ba8abee734557a9430f60af11067dd3fd97fa5ee54289075593728b4546622e3c2e2cfe3dc51993cf0991ac67c3a0767c33a9f232f289f73e190aa944c95af6c190e4abf130cdcddbca27ee4cc3996d28a2a66e50ee3ab4d3d54791632a77336890e852e13a10e9ebf99190bb26af5b3b672379fc7d4c513dc09e6ae61547ad414fb66d8cbda9d3a76e412b6a815718af974bab9ba835d6cbfc3e7d790d5a2cfa7445e3ffb29d5773c8f86471d4f621312fbf82885fd54f526f664283e27b96e725975d5c73d42d70a6a37ca5424c49183b351a0915b7f11e5e5a0e9fe22943418dba5a8593ed50efa0ce6d59d6eded012c78f64faddfd10dc1fa60398a497419d8b48cbf3ac22d27c0198357e2557db1a532c43fec7570e7b785d6f973d00559097bfb4ddada198c43ed18761569b774ebcf617d10f06c1073b8698b67537bc78935f3b570bacc67d92f5ad42dbfd2d475c8e0b869e5c01b2dff8192d3c1c2ccfdb3393eff3baf847e4b01a01c831f97c5fbb859ffe03ff0d93d928c11fd1c4e18eb006e5e757037bde25a82c2ea58b71973ac5d2cdc00a60b348025c1ba1316131bc374f3211ec287410a191927e3f30ac61c20b7ee12daa90730b3e047b3a63fbcd66200d8c5307577a7b2ef0a95680b0c45563d5db1745c54d6e097e1141a2446269260a9525ee7332bc0412388261e0f2674dc6a3aaeb27850348555abac0cac5420274675c7851abe01b364bce71673e93373991828d1752fae148bfada84f5a843cee267036dc1f9e9ddb15ed1f32dfe5f619712e0ad371ea30ad52f6d0684c5ecfd0186dba1fa4a944a1d6a21f5c1b7f891bb49af386663f857928c90e9413573fa147b9b32ea5d3c7f8ec4491b154d8a554aeb2d4497ad332d42b6fda62ba0ff0b5b99204bca642d041969647e79519429b2256590b0cd4c06b75dfa2808c86c40dc5194cd951d7991b2b75cb6c5bf51b10877a9cd7c0889c88d52b722869fde57aee8bda8f9e2853d620e45ae8a0b2825dc74ee6571a5c0f4cd72629a637e92d7ff9613d4ba933d5b7cd1383e09474b3574a59edac9f51451fc590271449bdda0f6352f3ecee01e9599fb7586fde565c3c9505b1298d29fcf70909180d58d3190d6e7d2d2c387cd28466fb455354a2c540bdc6ccdfdc452941eb7d0629a8a452d4b068b5fe0c2e2284117f5cf532b96719ff424bbad3c28a7da5bc57e0befaeb1b57972fda1015cab4de9f573b97b00a926eda45d44a74c3dadddedc1fbd4c6e8d4ecafe664ab4b52d4a7cd5d16e6f3e75a92c45d010f2719440447c5b98b3139c4c3e94f80840a3533a3c9cb449fffab65abe98f4d47a2266e21e286e1e6dd58b10a598da9aaccde06f86444bb931aad37be7986ac8514bcc3cf70f11319fb6865b9f2f85876aab50c21c28a13e490ee6ee1b213433f420c11e5199f3da9018cbcff2052b9c47faf9b6c21e5b8f04e385b63495e8f12baceeed4582accc5a1e67a3c1c0f48daa26684d1800de1e4c96cc38b6b4945de8999316901ffa0736d7304c151ebfca50bd300945331533ed17ad59ba8ef018372abcb181dd79240ce9eba62d54959c365725fb1d61a2553babee746960803b325c340f9674222b7e18dc31c26a29e389465b0421e5699f959de3832f447e822bf97846f0267e252f8b39f6344050ad6d0ef41aadde284494de8d9574417a93a89b291acc925dcaa2e5f6ebd2c0f7b5e174ae460074ad3436de1e8dcf0c3e627abfe1fbbce219159069c09a0b79ff32affb80043741657c5dffb6439ae771df886578d7ff1324eb43522f44025b097661321c9993fa2ea231e685f443b2085802b1f8d838c3d4e2d4f13a80d46c467cee36c6bbe4f9a42d2713e05f9acb35cf29abc312f30c00f21e1c2dbeb10c23b8cf3b2c62579ba964852b3f963c3fbf0c54b920c20f8e7492e358421463192ff7d6f3cf5735637bdf3088805b87a8bd1bd444d8a3b72f5c0134da56dfd3c640e818ed12a3321b2a2588cf4dee4bf13c55cd0447e4d404ccdd4b48caef5704cfc1c213febc0479760bd1df31cf880057be8c80aa03660d80f59568d4efd7c70fe46dc09b06aa737c96f3df23d9357226eb26bfecc98dc95f36fc82e044b9c5cc28aa8a73ecbd6a1b584857e2b0748624f96f71410718e81ae7896b64f8ded7b07d2bf4fea7b5f354e03b58ec48094b583d0b300e4bc52cb16dde00ce2727c7cb27cf7615b92524b47178d5a16b9ab0796c23d0cf1b69d32c2ecb954069147a32a39e26a0c17b32e3477eb061ca446555c393eec8c8e47d919443db37231071fb4f66eb256de17bce2cc1798472a01a338340e091290797759ac80d91fedcdac77b30a10f740a4197ffc468a8547bc2ea27ed4c82b0cd5a736ba660645ba400f47ab0553762321d7891a637258ef25d57f40775d714c764929c287291328b9d5425c9c375feb3b7bdc45b24b3791e8c8eb77ddab966d78d5360744217942a44df7f6579c8dcdbc2fee6a62b52c4982135bd47ee255e185433f7c2702d37e28ac564f4877d3639dc4e5fc13036d213d41035646ac666cdd93fdfa19859a859d2b7922b175e2ddc4e331043ad63b3c7ff72c3d331e432d2ed4356c062381d9cda637eb6bbab73bb9780564c2c794a3e7cb9367d2525204bafd676049bf9366f7e1e9efa5ed8e2ae6354af8c1e0c369fa40ab29479ba494d341cfcfd8779ffd6652d603f4dd0204f3467cca084e528e3fea71a24d5114031370f058fd0da9ca2e64349042ff4456665ed7fe4e16e57264e91df317b6779bd06213999c07b0524a7341649a6d0452359372ee01cb758ae73568914c1af237c70b40ae24aced896a59b378c38f97dc9d59ba2033d48526b0e30d2d0346b5aa159754c6a6fba71f035f4306fb6c55fbbcf33a4f6b2c1895f8b06e68e0f7c3be98ef6f9de9acc506ef83ec115f8f1b577558ed2e48e279a333249d4d26a363b1c335b0dc3763b750d92f12f70454cb0f6a0ed300ee16d8c19f3a4d2457325927dbccc057a98e7fc9f2d1e64cd6ee282db1c33e07674ccd053d988831d8018545d4c7d1f346cd82755b068fd4ed2d896d1289a6a19ab9875642c9a2518549de2d015f6e0de6831856f56d607c255f030c9c9e0addb1cb2f38a32a1c4bb29abebe86ea34fa63a5252934cb02d9a15d4fd9ab5d6ff97a4cb3a1764a1a773da6ac7a2d4fb490d5c0f2971d7866fdcef20015e4d4f26fd5dcdc3963dabb91326d402791637d535b783caa209833cd3b879e2e5c6a8d0d0c8cf362e078d48eec10fe7e0913d5329c36125e078840417f9298d09841801c4213ea3217e1c77ef53f17d1c340cc5818dbd3783e9a3b9b92ec98266336982d21ec41b1397353460e30b25381df3723261cc56d87010b03830e2acbd82024aa21f7ec901a431ceed05803a183da52133f02b1f03f154630206adecca38bbb4ddcf48bccf2c9d551a587f667b1d2399fa0f5b8030640c542adeafe43496c3de4ab01dd2bc3d9ca124699064ace054f7d0bca6cfb0a925946737523350e44db6b84dcf9ee236e405a05464321d1ae0e5516ea96c4c32eb5858d836d1bd45d0968957de078ea99b720c8d48805f4a8122d757abec2276f4a2d76bc0ec4ca7e52db3e29cceb7a4a97c8f13cf87ae818fe97bcd352d7c8c818fc836813f71259f7fd95efae2bb93fea34dd9dfd47dae89058f10c31839bc913bd487ac6dda391d7c59fecf29b81dd52a1fde6f470dd0ce958a938652fa20154141120e4e540116d66c9e2ff959e80ce5b3a5f18ec1161edfc4d9c107283fbefe00f02a111a19a94cb1be48813275f41fb251703391f63e485ce94b62f3a093aabec8e01e236483e0f07022c8b11edb9f76560fec53ec4c6a337752eb9d15f8c405e84aaee5acb1ffc5e98beb3140fdbfe4864d2443c975b0180755fa4c051a0804fffa863015436fefc652fe209e4f4db01e9975eac55cd2dc358b5e2d94964941663b95e5b95257598607e081f5fc7bdb09e03698b88794d2c9c067f13fde199828a3ce13a4c8fb6fe92b4ef861f0d4b7ba8a24ab05a42b41acf829a4ceaaad3fa583c65969875744399698723bf33cabf7f41562ca6fa463a302f39314117a3d419b0fd1f05b4d44a478deffe2c47eefc48bdb1f34f8d0df51bdbaaa25d50b6f91acd463dc68368a8f81c68ebb8619462b416abec7363080f18d80d5a86195a7a25c4ea0b9d5a00d123ea777d4215eef6b3304005f53fddbfb3877e31d2979268e32bc63b6fdfe6c32bea4b974a6d6d1b6a062a42896b5f7afa84f16df39549167b8726ddf5456e24b5ed17c2b95ed1a7e56ae121855af8d840200337c9c98876324de83c948d8398c6d264b79d00239dcbfac127ef17013ceaa18d32f7b5e86910fb3e2ee641e4c2e5bfda47304959495d39e9aeca6469f083f768bca78970e8cd62046518556ab49b46554e69c225776516fddb7d34cb2667654f054336319fbe01644814e7024285e13999f4a00eb35f08d5d22eb0b14c2568bb87cd57ce0b5049f8104d80e0400db67392c2a0a74db9a60feb8d92ae02d9078158f77a244bf20a700443ea68ef63cb818a1b98efe1a7d35fcdabe4ac9e0236cfba5ecb57066b854a80ca0af76d47acf97b080d3a11f071ce7d5ce1d20bd147d8beac833c1abb34813fd7a0d9bc353a765cd91debe462dd033300ff785f798929adc88a5455a6491c8cfd4f06de38727a371578ea88fe3051299e36e7b212a624ddf5ff30358e57b541dbba49aa7367a1d3b6ead05fed693bac28c09b54a38c34a388a69627a13b20c3e0ae0f5c67a36d1fee1a7b31bc7df96a23d8d8ff8bb3732d69f350cc71382fa69e00011e92604c1e08f5b8f8af6d0c07b111d1d85bbcf05cfd3f097cd99e6615d09d3b5500b85bfdd49fb0f9129f0a9c4967b4be7adfe803ec746dd4c7b7479d4816e20541f942eb852a7d3fd4d76f8438a0a443a0b721221db45f971d8704513b0541d69fd26e1e364527ab650267be99b367b02e3011499e57cb17889b2a22c8ddc9210a4515ce9a0c89135ee1ece81dbab36270bce9fb56c381aa665a7e8235e3d2e48617efaff7ca9f09892cb93a4f0bc108a431a4a19fe59bcfe813e9c315e08d6892e530a98b5f9784ffd1053af2b87f904e30eec6f94a281a9a288b48a71a70ffdc4fab584b63ed124bb1384c927bc7ead25e37d6eb71c6504f07fb828d970b1e4a7bfdeecc40efede878aad72377d396939a0a41603edbb6bda4b3115125f493ab930a42c472e97ef558528564f0c716a2e164c2770ef32c5a913369267fdfd43df7a2f671fc540923d43cff8cceb1703320626a9a5d4fd74cad465a0240e8401b90a2d0613ffb68ddaaaae483a517df2a998b21e8cf79be12a73facf0355976a3447f5fdff778f47426da053fb2395030fd0283e6c86b34eb2cf064f0f334f2a7c751e0df629414adf7454185e564616f486b2d7507d26f30412c98ea95235b6063f0b148684db63af47609fdf9a58a5dce8d06fd763be2db078941ab1cb27899522e4b1cdb28d17f49a068393cae7e118983d9ce6481d3070749c9ae06975c390d9256a2460604fc2c34a3ea475a78044fe5d54e286477605a64bfa614a355515e15e41c7209874c40b6ad74f8ad4edbc44209733bdfc0c89cb671cfc1d9234281cd3f56b4f398b31abaea0ca0030bc461772de6585178895e9da0910f8ed67b24fc4af20720cc2d565249f13bbac3319ea9cacddd5e8f2037abbe90dc9cf293562e69c73318e74afe41d9c56cf498383d120f6bd4cb6bd75a398d46928f7071ef5116d0a1f98e3da62ad0c14317553c28cf9b5114d5d306c32a18be26cd96a1e7f4b47898153005c129ebe3206fad2e13adda993b9c575544fcff4496bdec043ae93cbb2360f712e9e59cdbbfa68c2d4950266f890fdb9fde327ff0e02fe44f19b157fe85480f4bdace53cde2aff380cbd6c29a4e29179acd3255b0d4d6cd25e5c597e0666c3f064c34592e22aab05f6ded0a35febb176d6782a28779f05fca1860e3ccf794161a7a0957e6a8f6923502b3863613777d7c695fbf719bd64c95814f5ad31c678304b283d062e783979606862f4adb7d8a4221523dee35dcee360f666ed71f3f100039c6649a403d46a61b5138f474868cd879969cc465303153a82a71f7bc23ff03e9c7dd27d4c11f284c9d9d230ef63f97c1b4b7186665e6a6c637027ae7056ea78ac51b23355199cd696dbdef4f9baf412a6adbd2b13f0eaf24676c7f41441d78dad23cf750c5fe05e6370184050cb554654c43bc0a254955cc2e6cf594155cda10898a085ee7437c11ae03f8e10e049c429be7da9d0722de8b1e874ae5a26c777e356e1b5cb6aba27df0803a1631a3b6aa756a8afbb8033ca70ab5ee3dffbc40e16b6da7ef280fc1319a64cb11d41d064461372889213eb768479213002dd58db4b4ee405536e613b8f0fefb96c783043efb21c36c896c8d4a049eed6d7beff4ece3f039a6c4fab83e7cd41d837ae017f6d763275744dc57585f72549c399b4797f46e10621d52dda3b2023c82ed371bd590b50c71be0adcf2f82792d8824f825e598866c1c229caeacf78d87a29cf52fedd9f151fcbd3d5d5f402fbaf36c3d0a00321766e790eff641cceeea8ae3c31a9d8a6fb4f3c490964dabb0efd3eae2fccab4ce5f4f7ac19f396077c05a8fe515eff68e48734defbb845908797e2ab7b96f691a5e96383ae500a01d59ae1feacc9efc7a43d73e3be19a5db99acad28416624d69cbfabdf899172c3bd99f490e9fc07e42ce88dd96fb437ad2a6efbd7e2e7862ba2fe54e39b8a6d089566fbf0dc026ea40f7290dc5d5c54788cf0c61e3f63d7d7f03d4bdbcbfe6dd703bbf285a5f99bedd7683b781a3306b2929e49fa2407a3f3dd22fe136010b6bb2cd9e72e1215f1232d54f51b2ff527c4419781b1a145289316cc550d667e928636b8e6000538db1b16fc8c69d6936410e88c907dce091e5c87daf21741d0e29aefa2383eb162b30441abbf25e3760be83e4a2447d1c8c9f17dc8eb8d5bce7fc7b4753d39ac6515258401de40e0e35bb1c84d0a01924f85da7d8df73d673bdf13efb2aadde53cc97fa90bdca672409e296dc260c90ef278dfc923db8498c2805e8cd81baa9a6cb72acd1f019ad63084255c783b7d2e4618cd0b7bb25f4d424900610bca51bb41d9c624ff27d9f1d0e9efcdae05baaad177401750ad0dc220c4ecb22f776a33e591d2a057443e2268b1564497e8aada48931ce65dbc084a11b59bc606cc5c39b6723c933898290c59cc73d811364fd6dfa60f290b216450d1ce47ad495e2d3d4ffa3ce140a5851ea55255ccb8a112b97e87a9b7b0187b76fa785898aea3ffbbe1e9bf18d7c61bc02964f99ae3791d1e8c8319f5d3b7932795cd7bb08e4640e7e47ba4aada3e8e1f443f8b576dfca4fa29b8b47b29022692ce4fddfde7607913c68fe4effa31673d1f6e9a2cefe636d06c3230fdc9e0245ae4da7ad535fccde345078529aa42272d737cb73f9e9824b06148a7ca8f409280115eed1b7bcb6ef5095c0983218f4632a07fbfdd7e6933ecb718ccbfd8b24379b6552f088264ad819ca6fd3f73fa845a6d673f880c61bbc8b61d93468191203120c92d6fab0d09a61d8466b648b7d87e1bf55599697cd2eb906bb68231e8f0c13647b57dd63ce866a2cb03ac9f4fd1b42b8585fd7866af29e492b9c0548fe224bdc76872c4c84f7812c0dfca6171e104fffb32362187919f0595f01daa89f59a7154d088a38248e28d8f2f36caca1580c997e938f6eab5f51e4cee18cb5e1660064087fb71183d9354a4125a2dc24232d68af1a7109922859bac635cca5c7cea55b286d78eca4fef70815d47f8629f8b39e408b8f9ee3db9a8ef2f1025c7b7df4526d3b7b02e561d7416104ea6457e64a4d38cbe625aae312edcf3e24ef87f3abe37cd329f56862c75a1d9d072ce28c6c76cb81f1c71e843afb69006d4ed6116a9d56b9611aba1598320599b6dee714208373d5d47bf8fc22fba8f297cc44e0fe837e9179a0d7d004c46d3723af6b628bb0eb7d2234464a3c27aa0e52d37bf52bd22acb0448c14bb05be20c67704c03985d59c3495d2f5624c1325b5a73d519251853addbfb7bd73caa16c198f52b36ff8c0b06a6b177bd0f4fc476650f5aa4e809000116e7ded436ae579c5479b71588ec80627bfeef09629ced74f33516b8131a3c8b2f8faa692a1d662c039bd76a56491d0a1b5cd27d7b445f543f35dea950d4e8dfd5d7316dc637c1a4abc1e551292f41c68a7778e4e2b3512d0356952b2c6d02837f798a614dd2e02c95cac171bd72742c36d5edc152f3ec9221ce393e9f0c524eb73ae6fdb28b6d08c4ef7315e155459144c4a4bb7024f015425a5d9a286a1281afb2dbd1e01535f83bca7d4943a5ccf00061859c6969f8c89f5ddb3361eb903714851d6fc7bb293d04ea79d038bff3e9529198a701caaea4dbfb60f525ce382878fe43fd6a8a0d941a9d0957d881c53bf88dc57551f41b0b656cd306cd132e35143ba06f88d397efc3e9f2da403296cf42a52144c8136387ba48eeb1484216dd3126109ecb3d410ae21aca5448b99f97e586a5c862fd53f8564c51bad855578665cd29976b48b220915f755bd0cc9dc0e8f65b04e90b8ab85c653d9f6c685552cc303f97daeca655b05bddab9bba59d0846af86e429896d0f6e913f636718a5d1793e45d1361d816289688a2cc5d43f75368239ac43c89db057a2675b29de3aca39dd7fbd30bfb6edb33b066c3ed8fbb5fcfc6892d7f46fc71763cf1a0ae356a3f114a5eb3f50e21a504388e0d403a27fc287d0020dbee1195f5ec45c09acb53a8eb6ac202e88b9198c30518a2c2dac2c03ffa8b2da466e7dfd180359ba6673d25a6abad0bd1f10064575f468f76924429737f6041a22cc46e499951d3ea94c8f10dce4598ddf5d377e9f318868ff7a058c77b898467d7ce38eaa7bded40049e7983728d988a6fb74e5cd09626dfedb12f4fd6694a374f0dbaa4f1d49895044ec85ba5b2d2d98c3504fdd074d8eb3d7e078c6d765d00213c07b2ed7ac444aeb1c5f3b4250f4f7efaba5a82ec7f6d01aa85983ffa26523564eba6ecd5d6c9aa19d15a6ec96c95936d25ff9d73cd66579c3ee1617bf321492303dd4022cedc23f7043c57ff647a173feabfd1102ba5184e0d1f46240f14571be3fb3531242ce982a182e12ea1c66f7e58e3151363cc0f7ba01f182b4c440fc177facc4cc4813828c46deb73758f6e78b542a65e7e3b1ca5548f0b8edb22ea22c769c687c1ffe1c3072fc6a91a9a37a94b0e1c828c777a2e5b4ae30f937b163a0a54894040363948d5791b34cb83e4186aa8f3bb43805f1a65d0fe56ebf4dc87326f5c25de1b8ddf3f345223a63e832b44222815c52b3a508d36c854","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
