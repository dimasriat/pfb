<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"561215b7b08071698f9ac4f90dab4b32d32e431551ce1b9fefdcccd54a2078ef2a966a12755c9d804498fc61c14f078ab27d1eed439ff91bc54daf53c04aa66acb8643f4494eff4e74dd1dfda23315ae23a7c75df279550e02764c1114f5f35bb2b3362e6183093e7413d0796cb10fe96e1a23c9ef25892e17c550843d452addeb47f6d32913a98c3ccc80643b5d981c5444c4e6601814d78fdbc2a6c80fefcd9d23f21d640a58ce5d65a70e9127d00a73fbb296d83695022b2d0a74095c8bd698b3fcf19739ba59091810cc59ac04ae04b60d94ce1a7fe605e33431ad3f47cdf553fa390a8c668e55d523c60c8acbd3d7a929b863ed4cb267e04a2f90071ce65c0f3171117a3c7e2e12175f1a58552a275dd832ecda08e19dcabc6131bec590ce64035022f7915acb876bdb6a763a1702f2161cd9685d11381df9359466aa4e946d9e6c7e3efcca117845974d548415457fa6116166c4d36b8533bf3610ac79131e246a75f1540d03a2d8473ebe74c27251cb8b066dbbff67d1542ed4fbf783640003cc20f82e7142836e94cff665b84dbd44297acbd1401ef700afd9ada621b53b1b7e27308f76bd05af81a20dfc45d52a45e4c840846c51571a3f2bdac314c4fef2a19628a6eb5a0f4429288b428818d998c76cccabc086b711da1f41391c2b2d67ba7009821ea52a702f674281fc4e7185bff3513616901aab28e8e44341c4d411a20ca60696c569cf391318dd4e9c5a11398b51ca10951e9edc0ea9460f1e2de14db9992b98c2e7e7366a0d461f03552b2009eed77c3dc8926c213495453f0b6019d2712c35cec70b05db477c2cab866fada1b41731d3c59f35d3692e54be5ae93132b6ae3ead8b67136c10a2df16509f36f446c2806f42d11cb25a3252058f62af711e4f4cf5ab9dfd8cb32b342c08ae6ac99c2b4ec6f23e43148ee970bc62e81a07100e8cd63aa2cbf6358c98b7f3637182103c67900e3570e5fd766ec7cda926b3a0c43f74ad0deb89e0f60be819dae7ca23362e2fa7f74839420b67d62b04e9f850018950ce6d3360e1ebad5f202ca629268d6627eb7290efcf39be11dc8477f10d2cc54cad4ac2c8170c320fe190b36dbef569f5394bcd96d8cc57a656d0e8802113c2b451a318b790f08d2ee926ed13ca32577edc10f41f0f23cf9fd30e4cfcd29e2d87b6a8753367a595954d21cec3f042bd1b8c4f3e1ba33c46f94b2f8f58e05f59a58cb63eb863b2de11956cf2c9fa1b5215a90666a58adc164715df15fb8ec2b507344bf8f0da7b0a8c21047e6a5fb23224a1c28dccbf7885e221f969c946b27882da45e770f6d3df37c207e5fa77d0b75cbc8ae54d05f96fcc925db64b1f00ceb51bb272c12b39af48e50695441df5cbc8ad9d9c52a7c3dcf46b86a1463f9f662f4aa408ba12f1793d2bc407039300284905e72eb8800a22ce200d7c06c04b844e3c368944ffd4f56222d33ca0cb6c7859a7eab5196801d5bab92eb31fc5639a9348272c1f989d159794be913338f582f396d11774f10139db56954dfd4f4b48dedcec503aa0e9991f1b7b8037d4a37970e6c472bc17d3562535179dfd1e8c8157037b78a0dcff04c9ed467d33e9b8365570b268f7b1d63e2aa536f7f7d57cfbd4f5aa9e75cb3a0808af90d84581cd9770b14e76b36c22c7a193f11b7e93a10b95804fd486b2d91e232f0c04f3f8ff99d7166041edb199f92eda84eadb0dea4cf14de52caded1b4af31d8a94b93d82a31d356539ee5ced63b643cd777afa9298ac867688dfa48c4d771c1629b5cc04faa464742f6da37b71a3402797d96c9bcaee8b42ae1651e90b6aae9dbb1df09b90ad54207a7ba7a777fe42b36f16dd4a664ab7d1e49cd3ac6e4a097b11d39699cd4a227990ebc9f067850e51e6b69f7fb5a091985db7de16eadc08dc403b9a84565ca66c57dcbabc19cf25c1032f5146ae49d308d98ba21a4e9708d3ded0b858dd676b27110b078b039c7256950cb35b312bc758c4fbb5e013d4baa67445342400a185dd893e243290558dccefc9447d38c047217a2f11abfd8a2af7bbad60cac28732c04ee2362f4aae56e606e4b3fd4d5e600bbca6a0acef487c33a4456c0cf8938210f1e223911b4224935aeb80bf730b218ce05b5747c99472af42830e7adcdd04e57d294e2168d7acc4dcdec8a6a80bd586d9ba908af8f1daf0283671f2f1263ffda4871164cf44a787b3ec259e0493ffe831163f53e446ac31ce826fafa20d143e44de3eed4c167cd3ad44748f94e1995d62432b58adefa93d03f22c17206da37e36aaa4ae0254e636428b82b1b76a5804e402d73cb0153a6c8d0f1381bb5093496f425d2f554cb56f2b9afd44c95f6df3798662dfa54fa8c78f25cdafac48126455bba16456503759a84d87e327bf89f16fc927f99a79c9bbe4c9b09bfa55d03e715a8ce08d79fb6f159c111dbd5f89be575cdb47f4c2a0e9c8154c55fb361ae2d74ebba15e2447981cd17e6f1f6048a17948d3b709bbedc7b8082e0633a536154adedcecc392c64377b85663d3da89bd91960b150a0de8df53af6ca461fbd78cb20288db6c799fb8f896d51d3eb0bd2411ba26a252e846ff335dc5b6809a60930bc02eacf9d24c81ce84f59b6d0491f5ecaa31146c4b31dfafc456f8dd911609dc4274d3ea5178fdc954ed16cea32ca0eefc5ae10680b66d0b1550078521d50ec66744a2ef47733c63d8d16b52822e7e56760e271f96afd12f34a4302915d28f76cf39c697579c6450d3b310e9ac970dd9420e6a2575949d0851ea59ebf516fc86a61912e0b81467c9d6599b7fbd72098a4e9f033f1230178de07377bd8c533b464f6635bb1a3363bfc2a02cd492a86e0c958a329d64c89e10770a29445e68ccc4d42ae1a93c4c01c458a07274a60d5b637d4629fe0f280baca02b7c3385561aaad81e62fd2273e3584505478e29009c889ffb97896206396945e7fbe5fbb5206383609ffd060297dca627b9e104c44fb80d5c3b9bfabc5640a484e92d8865dfa359f7ca99e391b0f48ba6bbd4898a0129e25066baec817871124e090364a713b7e39fb1362ddb1528e1f3f222fbc0a5caa63e60d03ddf79793fa01b24d1a33f10ad8a430a77050d14d5671fe00156ed26459e6e998e9449052234643fea25e1480900cc9e333cbc5031d51dc9f185c7b74e72bcb0677a6f206a96b18f42cb62214fed4920acb892a04ff8b516db7c59d4d4902d6343661966d945f7ca139e73a0be2fb5fbe3569f6352c9feac500edbfddba8d8318f6b9f8d009a77908ebfce0a70693bd9d36a9dc21f4877c3e33739e07a472a325855177340513c19db7719ba4dbd75ad6e4a44477e13ecdfd78dbe35435dea6706cfb2c3a1e5c595fa9eb4338e0626daefa27e26a17da5a63af7332781386a082c3dce1de36e6eb91ddd46051ea47d729280a15938ea5d3fa28b5545f79567d41adaf09dffb929231e09cbe74b481faf975904985e72a0ab6310e4e22fa723dfc0d2bce95f8d37c870d6daa3f4ba5e1bdb7c6bfd1688dbce452bd692aabcd07c2124f48dfa7f93171518ab3357b8b2016c62db15005d3d01b43e4f8c2318e5fcd68200d31858f3a8a7b8344d6872855b0aeb1aad8a1b820650ba2c507aa35b9b9a23573710d2dd7f5edf2080382b1717db615124d61a21541aa1e3b818f8adbb35efdb01b67b1d1fbb9e527aa0641fb7ec47bd5c3f6a281b95d06335c96936a86c3b47ba7409736dbb8b8d514951ad4f62588b569a96a24835f21567b2e87836f7f3487007131c089d3b03f2d477dac3f496d2cc16744ed3feb25c87b1d6f3790485b88a17342536294388bfa6e1db1068762ecce153e1587bcff546c8f3b0ca0136b210df1fb037c539a360da206a73a91275951ba0fce00ffa34c574b54a836b1795bc5269734b5c50dd1be614342c11cf82d920ffc869cb3cc1eb386a92cdfa0aa31c3224725644cb6ac4edb308675abf6b79ef5fa6de4d742bc78386847c059f23eaf33657b09e2670d6fce0122aa3cfd1e7748b057a5777293bbd12775110a1864eb9b9e1b1f00f85553206e54534b8147f9e5524b0e7827fb540b1bf2499b8ed0e3b20611ddd6650977d8cb8996cf1354cab86b6017811203bd6ce2124bd8843670def5a55abd2d277095b28db94835a5a90d1f844a407dbcf0527a27bebba0f75dac7ba37555bf649d7201aea5f7efbf8d053bded9b16b81c6f53dd76bc30ad1ca43732e62476e9faf56bbc4b934dc3ff0cf91f032c3e782335bec38ca97e7f8fbecdb479c67d4462ef614c43842a8f4aae1fc0c32037a03518c000ccc999f4640af1fb9393877afbb137272c683cd71550aeb8d91480e4339d28d341d2815b682f77db9881d61fb6dd95a77d176b7b98ee7d565d02a8a9ab6fefd5f8ba6e7cdb96a1a8e7fd36bf6a14cf63c8514a78e399718db583f1133c13a921a0be415d8f4e33c94b013c698136da66af1f4210855527413d7c77087596fa1ef3b44f6c77f30a74043f8daeeea8bd8817bcab29a859ef0afdba4fe9cd357db24870ea2144d594ff5c5044f57f72b52c738406710400fd1992cfd4b28e3e3288ec35eeea5a1f0570265db7fd91d5a7222afdeddd346d0c63a9b1c665e242bf6b05a7a028ed09077299d96a683c7ddc8b0f483883e22af12ba876f2316ef38a09d22e37567117c6d527778781b1771ed4bd7c21822f0b319474adadf03fb2fa47719d9b74ba73c9c008f1d7814e7b19c09c59114c84b9ddc8dbb930ace2fd8eafd8cf4599fac96fab75504b8e01f17e58d7673f7d10ca7489671c677620a87582d850c081bb13b45dcbfbdc16f70f1e082a61d37a037bdbeee7e89ae370eda66169d897a50c1d2cabcaa43e766ee1730229a62f627f672e6dc102c9582a25828d82b63c20c327de4b2585982e0fdce30050d40f9c2c6f023b708de59fe246c835bd3edcb999a5854aa2143347f05efc983522ec13814d58b68b952eca64eeb2e07ad8e80808e3b561bcc7ea95b2361b9284a62dd5e864642c4750235fef798e1e3b166ce39d83e2b0dfc6045d5f50fdcf71ce2620a9e283cf0eadc071836a4af6038df5837b20742db7a134c3ce28278d93fec35c1ad9bce85d8de3204d71a3f4ea27e602bf3b16e8572e886395e4ba3d7bd94e00291093ba2d31c78e020396ae7d2a36ea8e572881fdb9a76510e4e774be69e5f7d3e43950c0f6d7721b5d2025c71d777dd02847851b4361e6e608f47c421f6050c10c52ab66db38044e76034dd92ed750b2c8e85986ba0815768be2dbdfae739b8664ccd9d9aefc2770c1dfe9fed203de771a5404b6c41937fb22b47c55c712aff33e99542a97e55455298f43558870e2df2ec4d38c3013f8803106a74eb404f6167ffb377f69309db1278f106c6fd4da7447695dffae57450284fcfcba31c0375c4d36b2a130c25f16523ec3948390c2c44e9721349b9f7eabc415f4950805103206d3f6ba425db3726bb2a6cd7c062bca3fba22a5a6ceb6e49de6bf0f99b3e7b8aa428340c19d8d157a3821f306bb7c48c8341d64d7e4aa699109cbe24ca578e4c2e962e918c0904b4e7117164fb7d1bb9b035682df3fe56a0f9a212e5e82acc2856be9c8308cf5c67672c9801a58d64be2e76a136e1bdb893fa48d3494136b27982874f282eb4e405125ca3a2979e8f9d3678816c3917a6a4ee6c4fc70541cd5121ae3c78d2755f215e6836afe73329a1491304dbc3d617ef375cec3b3e0d7fa216c148643a9d0e0419a4207d22cb2769e2fe2fa76bd6e00ce5c6aeb0c23550515b3c73a8cd287c24d0bc3288cf8fc77b956150012991c3202cbc49e32803634217af6dbb980847307ebcbe5a2646fc94b362586399af1da091e50dba2ac9f66f11cc824a5e23145606c5c6f3bc842d5949052c4567230a85c97896735f749106010c48d5a3a49e14c8caecd1cfe11a3eecc0531030a04c0c2039cf8f04344a9f9c0db732e8182d643416e2ec707e026572eef4f991020e61704b15e4b629b3feb16babf7d4bf32fc5ebfe26d281e5e6dccfebe34bf640ea56d13b461d853fdb2005694fc8dc904dfba6dd09564a120dd42265b2e89a7f77cb325f1f5f41e940187e327d525c5ddcea1f51234740c88df47cf41160b9e8f70320a29758f393fa0208062b43c7b2ed93f592303380aef30f46cf4d117d123540a1c0ebbe014ae6162d6b7a362a28581e69811537706ae4f166cd6f7de56659e161b2ae06760de6e518151dcf5bfd202a1f16cf1ef30f8f0cbdabe3934ad0057d339bf9e4cee07eb28f7a3f5cea2426a2dc3feb37b1bc723558978783c6f699b9324236cf6746e8d3f077a2f5f4c3c922e101f0b458c625d9550a02dff716a51f2669e9f5187caa72574e5b5a3eb8f36b311f1b8abd6aa636c1b688396035e2452c8365be50a94a37a80db988e51dd1170fc04ed36c8b41554c154cbf7e5fcbfcf111fc6f9501d8673106f14d98af99d586f9ab590ae26c3dbdf8d9327c8203c172052f81a5be19f51aa7554f2fc172bb016394fe963694d20f9a1103d43ea8cc0616acd384a826b18595e9c9ca8847422f4b270f2d39366594842bbd732c2a66f2ce78cf7a16c7ac6238d4d315ed9947dcdc515577515dbaabffa2180fe1a2b5947faa28ae3c1a2088d9f565c9dad5e654e7cce6e62053db2192988c9e2079f0090ee65105e61e203b72de289284b029024ec518a055bacbdb7e2d83cca2ae420a08d0193b561c1394395a93cb70f9c50bea119140a5573082a081ce496c7371a798207bc8460c29d7b390ee2a22a9caf2c77425e26783290485b73bcd3994840e3789e04ed346d8c6bf4860cf0694fc95b0a53f205b65e10e14a8fc79635907bd922d8693427d4683b3535a86a181b5163338265be864adcf24240cc52e700b0e5e32d8861615173de40bf6ece950e24ca99b8a12d9dd9b2be0d59cb441869684bf5f7aad0a870d54c54e50d3b1c6c5d354df8350cecd50649e3e01a84e3c591ca3bbe04db8a505f61df0bcbe5807ae100ccbd81737ee98fa3b49ded14950c1a8cbbcb5b75809f2e21410a05e6554ed82dbb7f4b25d7cfa18b19abf520f9d4aa7cf793a581a04eb44a0392158816656ffe1054faf5da768ea456406ce7c1948046734dfa3077035751dd0ef65b353143176ec30abed65d96f0671b64ae1f26fb50ae6065eb84fc5e72d3802f9e39ff98396f8a44dfa2d73410427dc090c90fdf5f387b72b308c56455f5e0d5db4e04cad5af375feda610e080fa962c78a570bebad438f581fd3e2cda1875c8e903993fe6d0ec3a1b8a10f51286b5bc63ccdce445ee3ddc2ae298d120945cc9949f021055e203ac20d29678a4cf5250bba0a1ec7ab229485982c8b249170220c8ef4eba6942c1bebec43cfa10e0f5a8b0b33b7929c8678a91d3066e332df3b4665ef89e6f70e78b78c39e86f55fccfbff3abe951e42b701b1550b3a9d4e0a0e803ca4f53eb7a29a38e0570b709fb2072d67b83ff46d7293386913c0d17ef827b460c5d94fdf5c53500cd18c27bba97c53db8d9dbcaba553ec5b76d94f06fc2e8f8da09bef08c678ff2d6d232d708492a39055bdd1cd780c2c166b0a3bcfc6d0b904d9fc6ccbc020079173da72c6f55ee900be3a0be8ae8971a7aca7658362193cc7a68e28fe26c685e292feca00d1901c969beb6e931830cac11fee0ba3e01c5e6fe01d090f28a86942bc1bcc5d93e2467096d86e1539d46671f6cc1cd6bd3f9c8bf40347b9ffc5951ced92fed7b2f8165881b0aafedc9c3e65ab8659a9a4e928730653a35b7d8a3fafe5ba7a359dc3905bd1b1c63c39a0782268e28a6f5fa4564c0e55931d051f999e6d13e67c6ba2456d6c0b3c1e32cf426f651618c467f494647551e9fad45c83306cc62688633c8d054dab20cec14f6925276eecd4e598d0caa1ae25d087ab44ebc5cd2c8cd4f6684cb19e69bff122d22b3b6b88262dce7a4ac20bb4b6dfb739ed56f53b55fc039314a15039ed546af4c2291711adafd20eb542934d807200220b2fcc6faadfdb3ca710f85881be26ada721d6d7b43d57e8324e8cb570d32df102b0d585067aa2837b9a0cecb3643bb5450bb493fd7ab5e973503348fe305d9e08daca565f151957cbd5b8d4764d96d6f7ca309f6bdb61075eac773e69f6e18767cf97577d3f2052c751eae6bdb0f85c46a624a90839e691b5d1b7e0b43a796bd0c129b5e9952c5d8b60d99233c9af514f79b1124f86d13bf3e0f24e508b893eb38a0e373891211912df6d41e2fdfefa40822891584a339cc5069cf98f2ecc963947d2dfca48759f2e9f79b48b697fb08b9a7fb83cecfc8b129f2d9b997c6e37e75a9da7391bb2b005ffae7813598f50eab5fc78e1627181968eb64688ad260db7e44e4620962507cea8719c2e806bbe83c77015be443c5acc79124b57f41fcb853e596aab013ba1cad2451766c34fa36728d547be03f8818aae7d7b5eb3c5466cd356fc8c96b75830117e6ee7614c57ef2aaa00f93f0adeffb82b0ec669f94e6757f7fbc7840f6e6a0e494d3ca8fc666a88fb47dbc9b0a24c9c2c5fe6d252fdddce60a60198676d265b91ce263f2643edb6c042feaf6abe2a6ff031e1b992c29c4cdfac86708f448b72aa0aa227c0cd35a029923ce3eec20c885fa7d493bb2f37f3254f36b2facb9fc43627bddf699c613f0a115b3b9e4b33aa37bbc6a2913346d108361a44ef1c15a23eb8515f67aaa36a6abc518b7ca96f2f2afe024ee882fcfe891fea26226d4958c4af0d3c5cb08eeab1ec395882b99797305bbdf9ee8e79c1e7630d2d12146d20593947ca7a62ba08bd30179354089ed61b7981e3219f88b5bd676b1cb85eff34dba5c4b6c6f27070cb1a13925b637bc4807b7c13c1ff9fa261ade11401c2066b50425f1d86538771964f5b993a6ca46eae56cced18a2a2db483c1cbb743f940dbc5589633882efc92a6561edddc717f3481213bdf0614f06f5244be41eb177b15884544ea9520a90a065e46caba2a4370eba5215bb66857fb8ade1baf403d4de9c3aa5877aa27ab3ab3622400cf50938d01a6b58ffee7ad5797553c7ff13685fc9ad188551c4003e6f23590a4d2c0b335c8d9d93517d2c576fd2009e224672b1ba0529b7a030309d957556fa00adf133d7bc70825853a413002886221c5991a3c646eee55e5934d1e1a1c27b8a356a7054185a11cae6a7d6f41b5b049805ac1798b516d5af0eaf00fea9540b197423df9a1b7c76979bb8672da41c38b3e82a96f3ebb1503c6b5901a0ed28f88ee556293400622c80700fdd854ac90d4980d6ddfefa70661b575e59799d9b3a51f5123433a598faabd3ec0e564e3aa9dff5ba963e7d1b6090e0ec5bf212cd4b5f72065187c68150e108779c0a43ba35557534afe12a5ae45274f4be4871a493a68a2a410405a41f1e3af0733da6bfcfcb45e5d9685cfe3ed4db9f69155731f35532f3d84c0f32afb1ea98b50773d56787a3555a2460f8674a3ad4b1a3927aef9080ab4738fab467c16aba78a53e10bc4eada3ce3a2b8379473dc25b39c28bcd16c58f9e48f166e5536aebfa18d28c855f7b9acfb1e9a4237c2caf680710c77c5327eb3fe44eba65e7ff69e8489ca0b4c6824ff7e12d744faea05221ff55f51ce7ad0e88d13a4d6b0b51987afca37a31c1efd9543579e59a6d650aab0622fa56ff9244f9bbaf8618ba726f2f02f26488be4ce6eb7a699903b2f39c180d7027497b6c1804a3f8fdd85f00e18126b19db1fcea240d3c0ab06695345753c42bc3d93983d8ff435f7079eecd0ee803e8f62c809619db7d04337b2d98e9adb2987e71b111e46066ce3ff06c0b1cdea34bd86d4f427cea8ef0135d4e60ea760fe05818fc64447d295da035c9a9f8048bd459018a3b760a4bfb8727f84d209f16d419e9f54ac0510cdbd72786a4d81f213ba672e44a3230abb23125a4a9b6c57adbe52f19a4691c234022a626fc5179c308d4bd9d9901b540a7da761f8c747ac8bd2b70d2887a8ff4ef0a8c6ce40851175040e92bd4b92ae9b86c511859acc496d5435b87669c73444448dd113e1ea3ac7bca09540bbd5dc071a13e65bdf0d64c24a6676ccdbfc883c8829ae2d86c9b572449722d693ad0cca6fb1448651218fb0a85a731bf7ceed96aa47f00a155cdd5b70b21444c1decbafc77672df7edc1baf13c5f7693e6c6e89ea4320a9afc539ec88bf69d5e7a8a651325f2c0db13b6d005e86a6ae4fef512f23bc1d26edeecc197939585a0b023e6097994314973b1fc480f7b420e9e4bff78636cc8bc2248c6baf834a7bf91fbc1a8edfdd71668376717c181668c0ff47270539b9ccd8e9167dc1ad6679baff0ac6f88e67459b75bda3110bfa3e9d249a9a00d7b97279375426ec17dc9b0c801f03eb7d381e9c555c5fcfa3876fae81201da476fe3151209541d4f0cd94168ed22fde4afe6226d50365f80d8884d3179eb5caff69eb43a956afc50597ad7a9d80586dca11d5a4b2284d2156c9888cf0dea9d03b5b9ded94efce074b91c8796ef5c7ff477f073a0f48d9df5f8329ba36de5908c3e98714c91642878ecd4768330c189955f541cc54c4ff9de19e0b5d9edf94e355d035157cbcc995d133bcd8515a606d78b59ec4ad86750be02886f710d509106d3a945eead97e8c6ba2275dbbbaa107c31b70230dc971e10c5e48bc200cc9a5335e9b21b15b3615c5cc416bc2bf182937af0228f513bde2297e04d114e440db4cd54f09a0b0e0a8cd4acd005c205c7040de0bbd4f50a6c20c59e2ab01d91a15a4a17c0491b5fe8ca771fe989141711253c14efc4004f53e0d6eb419b37b8133dea474aa3d7f54500fde61cafa8efe0c9e0ecd3045e5a788d9fac81587b768061453ddca152ece4b7ae59ad847675314f4b664f5647318aaeca6fcb53775c98206c3f93a4c2e21956b84dbbacf15dcae82debd400ab34b581db6e6d8bbcc74a151d00dac9b4ffa77e8e99d395928117a09a02a01f2aacd70b27afd6f200d4a1e88ef9aab78206d965558ad5001b0313b96c447ec48f3c334ffc391abdc7c433445cc859b534d4ba44c226b8dee5fae879bc4214ab96564600aadb7dd0d70aeaccbc1f5d59bf5f04e7203ccaf12554fcf641ac84e8157583d87252e4409330850834d6765508ad655dcaab7add6b5dfea12cab279055c9701bcb173543e78d59ec64ec9468c6087d9a048773a74733c655a1a86cb245ffdedb9148862e22e5470e39092f85e0cec92b774db18084ddb72ebcbb1dfa738f9278966d6008b821da60905e5339ab43ad6202194c60d137ca7e24b0f4005981dbff9d1aa836030e9df23b923f32e3fc60cfbf2d89c3fa27d14035e25cd31149ebabdae61803246d15eba5b54ce8b489f2328b805562e78d3ef45ac813f4aa574fad1c2404af546bce5439bfa0d6a1c835d65216da8aaaa4ebe3267228c7393f466d03577699556885074372a0c113149865052de180345920f351ec767b262b4dcf4d3f4007df4ec512bd133a83175c1ab2b603eee5b56ecf1655e6b990362c228e0a25b5dc9218593051ea435e76c8be9292e07e46e43488e4e76eae7de6c30ee0c592f37821395752db1020314bcce83c23a4a9e690f0e4d268a0271a6048088e39c12e45da3139cdba049ae2ce53796b2a60c977c7c3ac7b65500025c75c2ad3ff7c81eb6d3a30ebdd592f80b3890f095a2213ca2c6449b27a9cb0472bd256e1737a47995f951adeb87476e2b42cc4c660545bdc205c54ff83c6a2da744c5244c8c44a31299fa0037666bd0de4ae493a72550cfbae87b30d9db6d1172f58ac50b2063f161da63f5158999b4a941d9a3242f6998bdc7a261b6f3d6af50d38140f9b51d2de2f58c30d394856b6a46165002abe94eff9f5c5ee49e460f110a165e6411d4e3264ae5af75b1d974c8932cc1b711f29231439de3404476f92d3c7e21d54317e5b39b0cc942eff91a48edd2caa7a9c30f8c746a1f1ad089af6afaec989b4271d719b0a45a294e1ade5f54d27e27aec28565b26448016c7d1c4326650a82c0d666d0fa76cd3236ce3787c59b34488efdc0c508404c4175384953a40748f96457f5b34bf237bb3ff462f5e587e6b5a6b4d92dcb0bb0f33af85cbcadd9cc5221a70616f967eed3f1dcdbfae61f36a12cce8307ea965b999e97e7c741e5a59a7740b9262d5151c41d5b45184d690fa4fe761cb7a2b992f8269d1f02f65cddd0ad3a97c7fc73f509966e6e616cbaa44b1ae1d44f440e278e66a6d70bd9093d3e2322d72cf1bbcd1052ba06d12be82d07e63620fa3194ebb8488fdd0f1cc15b2fbc21c056418edb8a56adfe7e863189c7ed26819da494b68610953ebd3f4c2dd1024668861c9f4527abaf2f591dc18b08480bc1035f2e3372a8d8b91367e0e1acc49c242ff7a6933dbfee98daeabef67e9417a6645a82155c5a3ec3d9e317206b03966d675012a673e219542fea7db8a25ea3a917e411d957b648164cd9ec0e4e6f07481052c817782ce2d039a3fe17be027b81fe9c6606948e96db3ff0c0d2819be9ffea1ccae3affd913682b9a7b6aa26be94b0ccedf72799c1750f09aa28ce60f997ae75df2f3916a68701b88f2b4b4dcbc1c1d5e4af1d3fd4c07772f290928d1a537c4206e4065e3857ff28d2d58da2b9f8ff0398e463907b385a559bdfe8702016d31cad42d329120e484109605a6045903a4caee14f7a5244b41387258f29222d80d1b9549245e9876d9e17ccb08fe8f0365b43ed561ef9a8623e761c2544aaec83100a44ba69e178129f41d45d4020034c7b3c09e3a312a0726631be47ed527ce9bdaf7d005f86e3de3dd663c7e0899b1d797388034607905290c4b30bf14e474b8a87f9d2792e0cf06e9461ffe9723aad7fe6d68ecfc48c53e8603172d1abc40ef3509bac92cdc9b459d88359def8ffd385d460ca9c56d34c95c39eff9f5c5a5680711b6d04b66ddefb57f7f4a8932aed5896943ca5a94db3fceb3711a2642c8b1955c8b842e993c0b0c1ab23e06c22d8b36b09916d89736ad8aef5d8a3bb91e5d8559746b6e4cdd9b653c3c570d247c9fef30265874e780186e49e4d81bbb5503b1a8aa092036c0461a4dfdf5ca23cfbc6ad9c69d1bce4c49a22a268d9fe1363c78fa2900aac5e78cf94c19c6e0242c70b7761cb95c6d43573789ed00a203af5cd13f9063cd2a603b48f4fbd37c1491e2cb38b3338bb905918d2afdd1e340441f9e7291a0990d5775a2a5302af3e7fcb91e95b624f1250d7ba25f5d00c3763ab41b8573059b0a07689f50cbad2b7d866a78cb7e7bfe5b7992eab30729c584cc13f2598ee801ec95f53365fb25e6454c2c87343b44f0e3695187092adf0bb1754e6efb00ba8ebc0f814690f209a7a9f920c4a6d6ef542b47743b4a40062d2447320f4eafa52d11dc60ea0f794219658d174930fefb4fd9be033609812dd4199f0f6f2837e548bccba8b5a949e0cead4f684cc5605b040ff7218847f6c26721bd91bbbbb3152c5899ca6d3dd2cd64dc3f94c44a37e8cac00235a86832c20ec754dc650d54622c4e7c489ec1fcff6f0a3ccde1a1c841052aeb38bf61b07b18b08c1c1847c8960ba743df494d44e69225e2f908bab9febbcde942bf8b9d85de2ebfde40e28ab0f852b56faf36801455ebf591026c7656aa201dda478ce77cf982d3225bf76d842ac32084d8c9407a7f3b0c3c4eb8aa702f496d6c12d4082b492d42aa4ad464b7b25dd19ee38dff3c6694dae3a849881d7ccf11a94329b9b0e4f5323a5312218bec89b387155548ec6edd361aa82454e6cb58e6ab54b5f1b10b0334c87d98d77ca3a412cd02b647d81d639b32b39803cb9c6336f65524e0daf67badc364b25c7240313a98e2d2f1d85f6e754074e65b6","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
