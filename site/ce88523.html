<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"239f295989bf46af118771bb5a849585a858a8e2adf1510071ae9a2397c0a19bec81f6cd0359df933fce3d2c4125c725622c976581dc54e4f06160aca57f427f8b84298f2e6debff809d92ba679ab85e54614b4e4b80feca6cf57df877817ec5fc180ba091ec77055b856842750012236a8f6a5a02a13f3151e0b135cf0e21ec28513b28ebc1bfec5aa71887647545008b65fb3b74e1e550d577887076489399affa5f962f1d3d21f7bd0759b931c3a741377961277ce58a98db0fd391f3632c6e2e25718b5ab4deef13a8290b48d5a8ec47230802ebdd0553e08d4f4a7c422ded16de63343fb61bf165bd82cb0139cfa4c343a23e74f7f38a0c50fd739d05135fca1fcade4fb490dc62dff9aa5c95b3e1724f08f1eb26604a1b18975c83ce59ee8ce2aa138a1e6dc6d13efbb67693da5751405f128f14d91f10ac6b12b0e5bbb591f79ced41d26722a3950eacd8d973e944992bd7b1f99524feff45c5fe0076f647d71de4143d2b4a74a0d663e81e387c92e153099822a692999343f4c74ebc0110f0d30ef094cefe8fade303e518ea4cc26ee2ac8f2e059dd5c000e3a67647dcee42d28e8d40a3286caf1fcf52e035cce8bac844dcfcbf3ee1fb201488f6d4588891716f32ae8dc260d794e17884a2af24865bb79a315d4b40f5d93374db6a754fa43596117813ae439c131efe36f22c360c4695ae12cfbcf695edb604eb520db4f909dff626eace17fb96b57367592a31e3a96c4cce40f39a049a0260e97f848df8de4fc5edf30448399e69f4d8ae47e9b0bcebe9c6e6f14883746ba434f8324c1924aeced91644973b7da3b6c8268688f989e61936cc1c1be774146228d630e402b5bfe8ae51a97560a234150e955c32ed30941ba3c23107c8d2a4673a95b0f3c4f03847934d42ea72eb735ae708d659069c0a9f61e8218c56f3c3a759c30bc538e8f70e590e29483f1d5cbe9dcfae405080cd68fa99327edab8aff7646fb23725af8a7797fd2a26238a356f788ae3f2a782785cd74acdd9c68f42002059373f79736d7f46b386c570a1e55c295d5d95634fbec49fbfde09e7cd93b2ec2acf7c91269ab5237120837db3fc58f1e29076460a544acae43c5ed4295258632794d9456e6515eadd186825ed5bcc18ff32074576600c49a5a821a7c73378f4f0071c9062477d2683e8d6d097c466f31b814f5db22c9bfc39d81ea07acb1fae458e83f31c64333efab23e286f5c1a00eadb1f4b231ab252a3f138327f6e8d93c246aaa5701a303ee9b7747aeb1da36b2ad2fbad365ab4709783535449eea12d1e0d22c3c2c153a50ee4b329bdcc18d6b2bb6d6fc81cf649c3977578dab9ef44214bf58803ec9655d09d4010d2a06a23045c579bf8a2ceb7b204b8756b1f47053bdc118acd2395be41f2cebddc063604da3ff91632c43dbd55066aa8dd3bcb0830ef8a6c5f703fe2e2f73987a5435dead51a580cc302dca8ecd90cba49a33763a9ffd8b398ae1fecb68e698edc9b81ec89b06c87836f7a1586d302c282aecfe25f73fc16d194213474cb30cb6cfe1ac7728061b3bc86707b3acab0aa979b272752045d930d5541e902e40fcb3871e9fb4bd3ede8d2b00eee5cc8c8cae1db721da8091b7cf3121496211a74a1d9eaf9657531c4a59f45c158ad6314dd6d5f43cc0bed4dc98bf6aa7dd2fa0a26f9531a0eb6de6971280186a6213be47f1accd11ef12ab4a1607375c6b256c1e921e88ef2106a512db7e47283f641f4a6ecbb04cfe8cc480ba4b11e26c1d3a1b6dec1491eca3583f863861f6940011524d08c3ef95da2705307a356d47f55c560b194ec7475553effdf0dadfb80ce7bf99c5f6e7a2a472ae429f07fb4c9d2122c0d8127063988650312fe7fa81831153e7fdb28490158ca9b95412a18938fdabca5ce793b1306a15ee694641430169c6d616ca37f860ca064fe626fe1f24ab116c3595ac6c7d87108f19e7a0263475c2cfa51259b9e24cc9bd64e4fb38e8698eec88e469fecb8bfd15f9abc94d76e42f7a94df1e5700ef76d98353f2ac3a0dd6cbb295c0f3ec95cf58fa6fffab7789753df76262fbc3f0124347f95058bf013fc06872b52a5f24fb9b7e30018ecae0ca9be529ee73013862eeb073002b321eb61553e09c6beecbe2a41047c23924a30dabacf73f8505c541d991816abbaa8b846dd9a34c00970917f99469a447f3835bb5791c7605e810d8414d521f714cae7cc9ec0b1a5d37ad094053d85c6f2081a6c1c2c3cfdc8812adb1ada3e43df95ae98ddda7f672a82fbd421a67105adf1e45c81fb3e79dc9351551950d0196f8e95e7b9199fdac2da3c339c27ab1849cf620eeed15e9a28954b1e147600fa7c31eb53d64c7471a217e95d7b0196713bc87ebc15864090ca23a5f462140059d5450283c35e42b703fbbf5af0ec872d684fcbbf526e04ae6fbc4ce108f7f2edc62b332bd18c37931a374a4df0ce54b54b3b1ac55484b56e8337583b1915256652f5eb4803aa6cd2abd08c70468d6bb69009eb9b0395f64e43dffbbfeb4a18ff9db368ca3675c69fe31c622f7cacb2d21ba529690e3d2b8ab91ececcd9026f10e758eb4444db424e8db72510c2ed06ccaf738799277197661b5540117ebec40489b83dc6228f17e0c4361eb902d6d715a8118f30c5bc18fcbfa8c0e5a41476fdb5bc5085407f470f02e3c024a3a6e37224fe197d5ec7b4ae86d32c2a34c9bf486cfd820dcf3e5ba18397e6f2bdd169dc0fc4a5e0e3ce9497d3036515da6716a575f62d3306710fd258eb92745ffdf9fff54dfb7097a1f7dc97737616508a4b5377aa5344d3f1f1edd196b44d33b5c5e1e99af167061177b22ffc5f595d89a60dc8c8957dfa191fc2630493933b1af86ed53f9d4f95e7bed1e70328e1cae7eb60a74594e662c2c8a57d669622b593e5fa132478cd21e31642acf13114809801653e275b16cdeee5831d13812526ef3ab48a8c5ee45d4ad3fefd6efbeb37b73837fa11233382bfa140405c8b19ddc3b74efe5bacdc5a6f0bcd5c611fafaa0a0e13fc3d2a2d605a140898c2ab04f3f89719380b4aa6965629d4ed7c7e52ffc55995580f74c275ccca18393bfd1438cde2fee7776dbdd8041b981375a600d8cbfac85cd3b3dfcaafe1c52c71bedcf2cc9107070051809beef54ae2b4c952b78bffacee1860c064e24169c6f24dcae82669b96fd0cba66ae8e8133a42201c815b73f57e48fbae1d1ce32055278c8e31fc1609c2794c05a1f41d7309542d2293747f88b9c88bdcea612d66b7960798e6e0d49e1383f10488f76bd4306bdeb33d9e019eab1389d8b69d17615219f1185632bfdb7f58741e2f3a47362a9517d1237e1a503db3c9c996d6114824dbdcf42f149dd1ccfad58b6ccd3941a19027ce6f3aa4d8e3e16d2b7dac81d3cfba566c5e3ba52ab01c0cf835a70a4363ef59455e198f964e73eff0df49c3a2f607c80f1103ecb7400e5eacce645f7a719c30ab55d6381ebab672e05b6a5034190452f3cf6fa75d8e30193194bc0df96062037d1246ef3097e62b73f1539a47255c852625d856eb9011d06ea4d554232a0862fe1654fcf3f26e5db7de76f900dcff0b5ee027b6ea297ff54834afab6cd80d10e7d2f8886df4741ca5b70fc76c97f8a8dca31a90ea9cffdc0b38df2f44f3ce65f1451ba30976e2ebb86fcb050cd61f7ad0f1c79481baa88834083764a10c3553b16531b084dcbab7624383d759c967b3ed7876603ce2729b77bba8d78724c2592ede73e8972a325f811aa3a18dffdfcda20f806f559b66b012d416a895db8ed4afe9b62f32e12358533c78a415276430a67ee507224c6ff990e7f63dbdde6a782058a90a3a9bdc29edcae6852716c87407bcf4d1e18dc83145e6e2706cc8a64c882597b8349d6893cd876f0a2a30387423224e290aa49562b13d3657a76a240c187f46245ea3a1f01e3ce747087fd7064223a061dc7a5406e641b1be9a025aa3b793601f31bfc5ba03db3c1768d272bad5076cc10c38cc06c147aee43e8c5d82011387de2cd53fdd57935a365211825f9e8d4133e5781faf3d9687b0841886e2ad66805ba0c63a27d5a1c3ed211f7e96eb6ad19d8af78d18909a2c2aea7de5917dbf8b4f6971ec5a22e327024b3913652b897319338c174489ba0d0415b1b5ba3a6755fae0c16fe4473559580e70e85bb408abb21711ab3a500f5bdbc9bde12ed0e1a73a9f94b6e8117229b529ac2f33c53b44ff23ca57ddbc9e8fae21217d507e0b19b3c5c19235c35dcd951e98ba2cd30f9b5be75747537d4a2fba64c1388ef53b735c2898c31d35aba02ed308c63a07c0d0645ddf8a6a842be303646400e82e3d822d4efac26a89fe4904c786f6d59b3575302fb38862670573258cdf94e64379012a62a18e288ae39e74f05b4a21a81c1d30de0e868e593c73127fad65067fa92e3aa71ab5686f68f2429aa91ab2b02e4e964e70ad2557096bd5ce0707be5493f857dff202bb562821c0ccdcbed9d3d18a0a79be84742899281df1947b118ba59e991efffadaeebdbf4e3bb8dfecc0e621672081570125cfa55149a40e32ab001088ca21cc867c81442c57c168f931e5a6ffc04cd592f2559c4bb7ee76ba056a509fcca7cf460a4811b73411c5c473c1a7e6c02781317f2969fdd316bc02016ade1d9e03044ea5bab2a617a04916bc2c19ed43f9da9068760b24c6e0f3965e33f777351022b37b20d932a9a5d47a2c4ef45bfc6b7657582c59d2a5484aa67b2fbcd718d36b41630f3db901e0e20ecb5c1eb8af531d0230c95cf10a7f18a91b9f2175cb57716e9fe2f5e06c7e8afa99a9a71694dc8ac658ab319a3298eba900d8ff134fbbe69058b0d5cf9baf5d9326cb5795987c8efaeba3303fbf61b390a51dcfd31f59b4f44e63f1c43f7531d02c5b5dc47b6ac5f34643274935754fe90e53583fbaa5f4650baed4bd6c3dc6edf77b5b3f70243a246998d7a44fdcfa20674c4fe2475f4f2dd0b0e4897fab4dddcbbb82ca7a7782a1dc9a0021b24ef9f8bb1c76d429d5d1d28d69de80a36bd07073660be3ef1b48b8e06cfeb10a80f50bda195e8aae4827989598cbe770153456e3352d542d21e15e80b4c7dab257a59f88854026c4d94d5b2f6803c50c32ee400c59001d78f48a92e9cf383ae14fd268dcede0491de3d9ad0b43763873825c314c3698ad5d3ca9a28010955ad9d6323aed5f80e750d9777e0b57dc2c498499c19b6f83fabd0ff5ba0be225bc36a79713b36845682cd1767da5ec0f16a29dbe3495468dab10d5653361f3d9f1cde6a4ecfc968af00830383d427fe138511edb3a1792f7ec4d156d72f5c2cdacbcca0a77004a17d4c271c1004f7c0708a92a738eca2330b0bb1a37e21ffd5af2c6ecf79d70feb329eb984a497288d69eb17655b7cc1fb30f6153a982c7f6b0adb16d023f56fdebc5c1842a4e6436893c120cb10ebb561dd4ae7a000240700cfdfddc5e60d909e9775d41282f9aa7ab3e917575dc50a6a5385f67d61a0cf9ed6de6e341ca1c4e88024effe23f866c33102315f5e7d262328b27874c91ab87236b0106122d6aa3006050e16e5c3b96d795c2efc166a55d7675975e5fa26d9578d39573bca4910fb4dc94cbb187d223a8ad2d80afdbcf415eda063e23434476a84e74500662ab92be8362646dee82d48618d2a7fd4686a2e565cf08113c6c0d7daa392b5cf17cbdcd63739c5b7ddd718785a982823e162ba32209fab17feeb0b7039b5164bd1be98699752b387b0b20841c138342cd6632c85c6d0abc603890bdd3c5f6d377536f4ec56bccb7db9f5e7dc6801bbb59a6b0b1cac3070f8393f8decf4d202b7bb8a9d170220295f1de242d58bd8a16dee2e1b19a80522b326db96284f63a460c69de0f1805def5ba1f8eab2632451c8f31bed96dad1d036972041b71739790cdb6ce570757131b942da95c2e6a4c40c83f695e07913b3345960e4e1b6b0a53c7b1fa0bffbd897c55c73ee3514217bc0c217e4bd31e424d83e625b074291b247665e11b06452420a6f471e803829459f5b8f137fde4b89f44afd55589784f012d50bd8219d92c73c484ba4c78ecc1b01d38505fdc98b94ec62147e4f3a448367a7856602ad581f40245abb448d9955fe2dced7e6bdab565c609b80a6272a046b58806fbd0ba990f8bd8411fa2202ca6cbc33d7a8349bd147ac75522d9ec39fb54145a6b01ed5dce5d19e82b375e123f2d704bac7179db0d618001c78d07f00994b69339bcc4bd0e3b96a044c9b60bf86d32f47a15dcaca24ee6e606cf89b9353524b2f79dc165dd385ee9034c5c8fe7448e2dabd17ee4d6824db79181a41d3ff6832ca47c68562cf2620b11a787ed0bf787310d015b2ceb41eee66a22fa2233f67485a0c237a4b5fcfc96dfb73e71ef271f45840bfbf5ede0f285cf351a7d19c9e9ab2e1a1449146ad09730291498e09e554bae2405fb3abf1878f26dcaedd784244fa32c755ec8f47384d434b7e150eeeeda0b2b9b04e8f7d3227203405d886c86df816789acbdcf4741f1d12ed9dcab583d389338cf1c0230ac34e1c71f36e0effd85628d2466b6b2b72f039e8caf88c7fc1ca84ad0d4795abc8c7e8c29c8d71c02afa325efbcc19548827425f2ce0088dc4145f3fb4b8c22599e1aaf81fac1912590a6923e17a5a4e5e03322bdad21d32e300f9364de8e2d8bd8f388ad99d0998a3c2ad010665ed41bc269e245e1f6fde5a7d2d49073658b2a854520492bb17db189c03e49876cef6418174558d6d912f2e8612807ed031b0fcaf8ab42c2240c9a2367a360c7ba5b3ef5153beacb2c296bd5ec6ead5c792471a8c13b0e423b70b23be50f884e53d6bad8a11577f65bc16bde1c6ef844f3a44d4d6fd9edc42fe76677539c0f798ed570936cf3bb6f8d0f4c09e72b76ab53435e5e704356a410a5474e8e5c27a2531124fef752d17c523c27e9f329242c571a7a68aa790f5b5067b7823e4fd535f8624ff4c32d22ae030456cf76f70c35c946bff58a21b77a58dc807ea519bda591ef57f8a281e7e739e2b6a4f74bac4736f472f621335c2d9ae3e158da693fbde48845ae3c985a086208091febef4cd1b2ca1563610c78353e0308245b5d21e5385f74c20eff5d8e6ca25258788164fc02c040ad71017443b6831a5dfbca9749b1d72a02fffb79d97e0f3d0b188c144bd5b8cb3993ea1193ae6bb2036e10a4da7512e38c014919cfad8dbba063d0d0cea56407e8f9fbab3bb525a435c4951eeed8b26ce9e1bc1beab9c9d6517cac26a10b9225aa9cc91a95455c9058a2809c794f73a85c85acc8220d661e1dc337073e1ba066f191a6ee183908d275d3b525448931fb852ed2c4894d3d2671ef4c764e8215cd4f392df32dcca77775b0e3d17be4781a725e6552a73712ca54a139d84363c1891b7fc87ad6df70ccbbf77f7e8834086af364274fdd24018b594e1e23b4631bd2110bb705ffc82f62e0977f70b6aa332dcb520a6fb36d60d61ba77c1684ec7634c556da9a6e85d242baba36d4501770dc3266c22b4539999db021b656342ff08478f693d2506f2b5fd4b0bcc1e839a816f3b9c3f9c67faef40575f9aebc896a956eac68fde58f58a4e332da2790f8418f06f91d185e938f432f0a77f8c058e090410bf5b07562a0639d1ca0379db6b06d2e0b2c7a5cd8403961b172369c0131fa5d58dd876b4ec11c4d7dca382267728efbe7739da1e3d73895f113c3c3bd5dffb021352128e4604cf2062c1a3ee979c0e7297ed09222ce459f2513fc6c12be7866be77890310dcf23fcba96fbc15efee2b6623410194af36ef5d83ccf383323fe5db708342f03117618d82927f4f709e7db64bc6f3e03619dea84e33c599e036548bc94c4837dea250c15e1f33e7e14616ed18708d828afd050fecde0820651b9679b8486aa2b697bfc285bdc1066bfcd4af965a3ffcc5038174700e73b4d72e7592ec281f11380254945f3aa2caa4ce2e5cbdf6b2f301e682e1d4829f6138a504c43947d283e98bf31ade08b8ae701e7c3eff7a9f56802bdab04a64f3f1369d1ef1f4137b1afb666bbdf7d501c475b1183d465568dfc4f80f66da9f6a55b8a6c15b553d246c9ea4d802c2a600d3deabbf42cb770bd69172d239945300b75895e6a04f37eee28c8815dc7791a4e921bfa7e81f2ad73eee1a229a2c0bf696f42073107d3de9ac7bc892adada024d5ddca63067a986425bdc83367d4565187d66a81befa14a39abb57dfb1e7da76fe5440a460b2a359dbbe011e3fd97b7755648c546b0e7ce12eaaf4df88f308d43092fe086c698ffbff4e26fa476ab7d915eb31cf60808e08cfc736b3669b10f14dac0b4a0929ab705244e3076d370bfdfdb54d22f7324801a38b7de3cbf02a3727ae18f5f1070e210d6c7eee535aaa9b391a12c7d970c619c79dd0da902fa5d6ae791057c9792f51b2905e948c8774cfc8d81be327dd05040d3e58ed848062ac24cc0043097f6249d411535ecd838e75d4fa968d75b682f2d96041113b90e84ea5f0a23a8ebf6699ecf730b953e1eee5c119d95c8a692644e5f41ff75a7db3cd6a4ed3fc65f581e37077cee60317c0ec9bcf0f2f7bc61022cd43be07c4cd9b0babc4397a715a64f8c1913fe4292ee79264498f18fe853f107d8218b0320ce8e6b3b6895851387350c688e75d8557f3c9108476c4b9bf7212b1991b99171dad394254bd0acdad6312854fbc45b3fc3ef8f53b6c5be3fc2a441b4970316baab271ca1652b530cb52bf089e23e5d04adef78c1aa5e9220155ceebe0f743a6dcf291fb798604027ca6f6ff591a4b4f7ce1e7dec0c370960a53cf03d26c75c3153d66f8aa039f601817fd531be780771f0135d47ec31c164bccca19fd17a3672ae2fb48e550e41f10703ff5fd5e5f87434df31d46aa8b08d31b52e974d2b76c736431748c0f894c6540b4e8bfe70f1406d7252b22fb79548168ed820cd4a298194876164020f9b959d20a965c5ad2de044982458960770d69f80d2d902099f639978b8b3f0a904babcef6af17476841a9f8b620e3da03e1916d305545e86472a05a1665ea4d221a6978ad13195ed77fc5d8a133250d44e58ee100fc8314be46b32696256a1b4eef4920c2ef971a15d931aa09c2e8368166726dccd88243a68b65d1bd113f87ece5211068efe7de98a851e8411533bdd907ee4258ddf76d20d248d9a2b90c4b5cc7f766124966d413cbf9e46bc2a59f334af828ad4805e2a7e1f3a3ca39850ec02b38bb1bc7824c60b2eb65ada96be3c18a8682790847cb5c4eeaa800e2abfd23e7d9d67a2b25dcd222664e605823c7f22ea85374265201b4448f47349fa1142a9836d004ef86ca2e0c98ad7e62c71c13ef19180473cd45c5f87f3b19aebaaf7965b2dbdfad5516729434d587648f07bf47c960bd726c5cd81f5dd48973205f22f3ae497bb6b3f110171780b79a6fa023399697a3371be0fbeaec4a20ef0a8c2459f79a2fdbfe8ba112087dd5094ce70d5ffb047bfe6eda25b0e3edf153b9691eafc9d2e2a500b3abd2b04c07a40f5187a3220164a5ce652d20d49124bb5347c61626971b3f9f6b98d14affa21cbbcdb563bab28216e45e72e320633f3413e98b35017f57bbd519d24e6f09b0b89d59387a624d466d3ac607ef8cca8e97055bfc3d5b43d2ba0b9893668c75611e18ba60d36289a7550b3b57aa2ba970b103b226af49cebeafbf39888ab0e582d387636452380d27e9915a1b8497dceedf79ee28dfdf400b917e962f26d8afa769561eec2690c1cb6b91469eecf654e042bd343670fe985b416bc94f10d0a073fccaf6fe6504f4183a3d9cfa171a863d46ef2a9be52d46c0855fb45393ae6ff700378f458c2dddf6112f724103bc77fc33e403914e1f78cdde0ba2d84332a0774f7d5953aff3906ae654aac846339d59f47b47ace92594a3b1eb87dc1f307d9d98d267d488b483bd9099c9f0791b883ffab28e25f09fcbad188f298dfe020a36d99242b7cea1ae20ea5f9b33f08dc050ac6636f99d2f9db5483767d6767e5a67265a0da0f57185ac7a79c56ae302994f02cd7b06cc8f9d5ff70b0090ff6a76769c1c90a500f26d9cb10e4262bfab38bc46bc4c84736f210c4d7b0e0b637fa7b72de902e377a966ce3d29f1e433666f3e8455ccb7c16bd680c7e3b93cc8ffac869751de7299faf395fbd7a48b93443400ec5d333ce3009934071a0a4c0f5386f687e9dd3248f3e80a23feb6edd15606b4ac54f08cf9c67bd69bde17023685eccbf466e3ccf2cae50ed409df685db45974a2b0b26aa027b21a0a10b2326856bbe28ec59e0f68e031086999187a7cf9ae5c3892ce85f89dba2c5d0cc2d3eb9ea07019e2494f15bab7a6c3b7434e316c396de3b4d378e41257e4f2ebb1c62fa0530e9853eec7f6e2339c72412a4f2c318a8ff6b1f5d47881e2309ac8db8ee6065b979b76a53807da33988299c7681adc6f93f0d72ca674cf40d94f1f90eb9c215f0250b3a6b39e5e8d47725136705efd723e3ee831a558ece19e6e967f58f7f482ef9079301fc80f4cb71002dce8e540370eb82f5d853ed5fd0fdbc59765f646623da93fcd05a38bfd265b3c9eceec13b742686631b75129233276cb616ed6afb03e9d6052b6437715c6d43c2effbf8f65f6c51540fd4514b0c500a001cfb882b70d97ca1d90279debacfcb8b280bca0e64b23245e337c3978d3fec896d1c1fccdba2c40ca302f218cdb85a5d1b5a44632d535424971c07f9e2cd2ede4cff7b877eeedc16128365eb04f9f9deba71272ae5ef2d88096a918870cc4aa3ba875a2b007221fd9e2ce3b1546a59ce75160d59bb9492027fcc3544c13c6416590481e16c1c05ebb49bcd116a20310b621952d867399b6e8ccf97d55c5a04f2b2ce1379156dfabdff4d2e94f7cd3a68552b538ce4eaa02227d656705c65d444167d042c8867977d32ebf21ee621f9c609d617f744374049ecd345a41f8014be3b5b369fea2299cdb839ca6843f31c2367537dc5e53309e2184c12d342847a7a653482b36e067745be8a3dcd1df87b958cf25b6ce84dac06ffe0ed6c7f2db027230e32968527a7178025b1a3ab4a8030c54a95467a8931965359bf1d4efb7d9277f32c3db8f8a6029af9c1fd4ef8366de308b1a6e66c992ca0def132d1156f8c94279e80bde992eb109ae82cb0144bac9d5f537b525b52afe1b1ac21cc21bb1c9de1b363f03727acc69076c6ba4776776b1f8798c94d3712f189e2e38262a712a9c0f060d36d28fd0b4266d293dd4aa928980f74a6e0bf33083403502c1b9937e85d56990e05e3c31083b3f22969e43519629fe3775e5e69289ee6a9b936d0db6c5383d4d0ca1093f7a0f8e6c4864c0b8ed3d0fb59987ea54d30750a5394d7b8352f15f57db15ccb50de3e1021191ac28bd51d99edbb2e13e54e341dd066d468658e6b0e794083dab55fa76c66ceb42279a6419d4b026d9d46563efda20277962d239c810c85809c99b2318aca7f03ac0c85c762ab32030991a4f981f8f16e85faa424731e7ccb9bd7724f7519ed2244e082d3b1d73847402a149236be3e13442ab7b14d7e169c26ec17790f4313dfcfb25e614462a16b607e56efabdee989c487d8aea0087d3a94fd4d9bfefc2e88fbd8fe33738e7ce23176f5dc70dc9a18330f3f05aef5ed3c6040efab8e3553f70c16cb0f08cf6f89a6634964b0f89515383a6d9e2eeb4f6d9fc826e549e88ef62c4c89b86c977d83c71ddf23a553f7a403b35fbb89e11257bf625ec14c89a59017954f24d5100ab454f35a805c5e53249ad2630cde70f7cf8b425584b2752ef60c22d289727628915d35fc692817ca46a11f07652125cace799ea2e10b066ac86efaf5b73726a1e44538e2934f2c875286f363cd1b83cfa55e5ac8fa7369da8611a127d789fb985df9d8c3c470578c12c0b77efcc2cdb99d7b4f1f35a86d5945bd442fcaa60b660025ef2a2da7ec7d37178740822d023ad96a3cf5fd0e2b30c7c415449318e4ef8f94604d8b8419bc8c262447664a7fa220b4fe0cb01bc61bf7072809eaef6e9a15728d6e04018df5b87c61316774c3ea6ef73c8ee5e3727283de54844133e24cf8928ff5ed6803d53afc9ac4a7c9e2492999ce324934d5837aeac2382febf7c32cbbda2de575d9ee0e867ab7889c22dbcaf93dece9c5d680ec6df2f8da5c18db9fe4b8ab5900795bbf5885432e51a581040b9c980d9fb7f47b9909bc044573bfcc34e9eed6d5153ab613f02eb189f7285b553126c91fcc46773737e7ff25dafffe890524033d4772581f375f76d79e8aa60fe677c304b9f834165ca684acd8303af71b961074130dfe26012252360190575740e398287fa2513e224f1c463999b468b7ddec73c8e461800436da59b99b28b10a2d9b84bc6d95443aca6e416ad92ffed0dcd5854794e4d7243e86bea660fea8a51b745b6da6d376190aeb5713bca0dfcd2767c7c10f2ccd3cf705db5cbf6fa7b15e171a02ce8d756c71d755e51c099a99a520ca4337abbf75262aee6053119fbcfc885239a6fe59b3662483c3c64063049f10b5b3429d625bcc12522d96d0ace408b13b7620ec43774ff1bb670dfb3391a148099d1db1fab048d1cb30284e7b65f3c07003745a3dbc22ebacaed9f3782bd91d18a8e91e2ad3b2dd9c2d9377edde4daf238bc2249badc45a07a2e82bee2f003566c8a598f5d851a438c57f792aa59df4ec5dd420f98216b05bbd17dc3208ff93332a0fde10a3d905d27326b889fd27ce197ff5b4d094acaa1ac211cdceebfa1174b52f87eafbf9b251faa51c9272493054a95378fd0198311686da5030964773f40cafd533ab09285ad9d02b7a2d99628adf1b05b95e3f852237142f3dfa99c87083a7758cb33c889414e1415a5199dbd81670974411de84c8f19e5d9d678185977c7097e0090395b1d358eb365d451256e3be102c1175aa5c2302aa8ef9f7ae67e8e045dfcf5f9a74fe5dcd644d814c15238c19daa3260c10f6bd98b81a4716267a0634ce759057efcd8cee9a651bf202217e26c389d46bdf276b93dd24838bea8394e128966b42f444116dea465c48b7c888ea7fee4e87d12fce2765159d6041a289a0fe5c3f70ae900c9705a4a2afd051a6dc4c0d6d6b3e1c9ae11cabeafc2551766cfd9745e8202452667e75a37069fa954e3b3e6b3db7f0020d10e6b0d7672814d74257a95f33fe4249407962a3156eb92b478d7af639d2ef0326dc197e76a76af6e30864a13af0ac0181d3ede72153e75a93f6c5d2ed30b8739887d1fba0c883e2b36687bec73e780e15176a79bc90c52d7c9d68cf45e55d40665a80a7e42c084772aac7ad36a6db5e0243b0aa8b4b40d5d4d0433ad086a9a7976064ae5310c0049013cad1440a2f026d073a01787bb28fb4d20d56619925e5955ee7bc27cc8fa9263969b3bb45c527daed7ed79a74dd6891659c946ab9af4d4da1c50f8fbc97deea22637fbf378665b135b9685c0074dee5361f81abc659653db22acbe1db0cdf3f511cf88b2d75b4195f019f107f2630e729bd818ba53c89526ec2fbf9b517fe78dc3064f61a699c292aa5460e1af383176cb396bcc19bf0c56b660ccaed930f4ab67bdda93997f88b92c9bf24fa11a75ee9e48e67928a737d723cc3e5aa32c8746b4c623039338769418340d4d5ce3d1dca9b645a23fad2c93d6a533f3653af2331e0a36e4dab8a40a9fd4c465c54bd6fe3479b4743eebbef14c501612562ebca1a29bdaabf1c541b3ddeb8d9f350516645c8bc09f91d24231d637cfbb96c6125d34e9b96891e7219c42e26469e3eb7482cf4d6cf2b004cd808033aeaa2b1a303e885d5bcc922410fe4137419fd70f66726bb248431cec1f3d720dee8fb3c797cb63f02e4adcf4440bf03f2263","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
