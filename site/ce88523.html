<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"789b64bbdb81d59445088d93090536c3ee85c1d08df1a0ad657df3c7c8846c612d997466fce30b6fdfc61c0eb244036616672abcb5e13adce185202be5353936f9474fed97ecd54ad8b2d94ad3e758ef01dcacf01be5ea657062a9bddc64f7f5ed3265e8f38308d2ed44fdc62267d5407b333b32e41d82aaea8d04a343777ecbe8882ea30f0b9366d332041a9a22612538d24e3fa0d6cd58b62abc3ae3eab033c742282832b8d2cbe5864723a0950f636e5bacf64e1d7b1624ffa08a699d81f08ae3c4ba881cebe8a4606e6a71aeed7b93493173956205f0849a0f2d9c64a7a8fc7ab815712b83f8adae8a8d33b1ef6c7ff043d394f6c02d0db079d364d27af562263bf1470907ae6be35c91bede51933c10f45252ba192118f59cdc41c69242e22e943965608582108dfc38f561b339d9b75ec08335e79593bf4e3e9d0b857897b174b73b9147c4d38ce5097728e0f15d6a13fb453a5b9e23cf3756efafcc16f10627dead0bfdce0e6f68dff93901faf8f84ec391b08db7d6dbd2c1d7f5071ce31ccf44dc44f304c13b9b64e082085cfe9f6a8ea9812fe9ec4afe84a46c90cae966ca30e6eac7dbf41d38d052206ec658a3125bdaaa2bac10e2b5b5a4e0b0f6899d48efbbe05c7a14fc35f90f320c5b6ddf15030a429f467f02d9b43a329f6d6ea0e15c723ab190d3134b07cef1f1bc51139af27bb079f3b6578831d01806ad9100735e9c36badb47b70e52a04e456e54b26cfb56f37ca695881717df418750bf2a6658bc3b27c75be9e89b4242914556793a529b1453e5ca728de91af322ca6bfd2bd0617620edcaf7505f4c45fcaa3f467ee12f4dc33017cd7b84f7964b98f5a9eacc65143fe6b9001eb60e2171b41abdf003eb20b78c7b20dbbd85f88cec65596b9c0796cb92b4788021488bd4d578da891a38928e18e4aefc90af569db354053235bca55af1b67b7f077a7836f4b06cddb0ff30b1f3aff515dd3ede1397ee73f0b590836237c4ef9cc2862f75e87decc6d4071c1abd456b1f0b780efa2ef0c0727a3dc97085ec690dbe1f8be4d72b8d5cfedda7bc0696c46085f64c9854e86f5d86015b75874a37c2191f55a811b1e23a7f0c2fb7dea14d9b6c6d3625cbe3784c9c9f0a48a6ed177d1649dd9a86b072e1e30a6406d0e1da4da502f1d856465c919fc8307005f6fa27963953ad0c120cdbae44a3c57b68468e21e5ad1de55712a433e36880ad2493348d70bc586f0f42b67905daa88bfbf333135bb983b0d3155441bc9405f52e3b258e69f2bdcefddcb0de41fe31bdffac5c1ff7fc5569613b0e7a16d5442f38d61a03310237a682f5410218e38321b1098e4e32bfc998bab0de614a15a8057b9295b0cbb8d7f0fb85df2f2c0839fb0dde3e6d7dc63977fb43f2fdae64f60a22a8490657048bbe92f296cc807990024745fd0d20374a2d81e2aa6b9afe80d65049b9abf6f87cdc65edfec6a38ef48980cdde88ac4c3609faac2c9c909196a5440dccbc0db41abda81f23c717af0db7cc386ecc61c8acc47e9dbf0c85dfcf99232617cbdf2de8a95a2741251106d6f35c29b70b63064d90718c2bb16cf5a4ee1bc8c7321ef96b7698cdc1586dfd4eb3b0322b86a173aeda640980bf03716b41e6e88718afa1990c08b7d3039cb91bb21e49505378d4d75f2458802a4af0b064900e73b2ebf940144bdaad444ffaa89b51fa036015741fab4a9a2c528854b9853ce7d1f26ba66e98349cdb22ff7b608833cc6e2c787c433cab948b9a5bff0fcfd8e9e58098c23dda4c8084780ff7059028ccae7dc097df156bac7d8fa777419762b7fd2a1fcdf17620e2b06cc6722fac2343e46895731834f44aa04767d7476f4c7b5a1f5ea2ab4d69baa6a68b0b2fb7330086bb69d0e1290ccf217aaf2c6755372361cd99967ed0b0864d43474ee9cb343306fa71d363dc9eb8d402dc1b0c26fe4d3c1dee5d34b7cfed462b33a4109dbf61c69bc485620473bdfcf28464ee97d02827d2c3163afa9805072035f482efedfecdb3f3f85d6fc1e976a27e4cb2e69b7c1b581ed792e5b7fedc3826ca910ce1d53c48cacf72cbdba376e15918344ca0788974336ee0ef6f65b164a46d6e1073e65e077d6aa75ec928a5037e18b8e527029df30bcbd84989639969ccd15a686932a930e5f509f314131bba27498c9c1ca88438cf1afe24d3147f748ed56e2b3db32ee10ca0dda3863f2c91ce2ecf224a4e63438dfaf6c0c9bc0e3d1756d3d2f9639299ded880b2045b782f2af5a1d06d764a0149a2d595e91d468681b4aade43d34d6ac5f3f0d821ea4af136f38b244b4bc1d034130660f4a59d481d005f548c307dc65b0751ef5c91f66bcef2272b3bdb1a3bc02a0a4d4eef1c0ab61f4321feedbfcc4e300c55f77c672f39276eb81711a573cac17e2fc0991c84b68d17dc3f8f72ec2a2fb4e59e838ebed5199c33115ea15eb0ba2db7abc867afef4befac7da78e37817a1e03a0ebc883ae04eb3233083e8a8f6d53bab0d4e84344966932d180441380f574c3f4650c019504bdc2dfc726f5f3f36c29161f7511ace9e36f257c673d34103f6bdcac93cd7d508799f4c31f5de1277ccc5acb6cbda32235682e7651079a8ea865d8474566c91bb345a3a153b0ea27ce4fc9676c22e3677c728d76564ab86a085ce833122df906f74fb8b24e23a7a7dd6d7bda28f8b3bbc8343d9ff1d01b300ca39c1607dc02bd9a89c07088c4b899f334238eefc0f8c6910a0eb9ff4c11a57cdf6dbd2438ea7385a556007259d35536fcaf326e2cacdbb7b3f9b26b7396de8ae42776eadb6b4fa95a89253c4f01f8f222cbac16a7feed9bc6888f9b3c53e00d5d0d5d84bdb09a4c39ee7cfd1a6a576c7d7604f4cbdfb60cf5918bb1f05168bc8bf92289462cfca93538a51a985dffd9a2559eba5bb1465179f8611d2732596ae741eb6265d4f6c1ea79ab471a42b7657f79404a98bd811fe393d63431c4671468a4f813aa476dcc4f113f5cfdf36a1fa504a8020097930eb3a2cfbc214060918e20fa55b44cf9be5b24995b1daa6ce01e3acd4c5b5bee723be726209bdffb4911b645235a6eeb81b378f89234fc877864ce031d51717ff458857dccd262f3256505425b67a6233fd8a12e6a5d0d6ecfdbe63d1368c8fa0151906a0832434f9ac0cf27be9ca09c997b60acfa6c0b68303e305cc97251e5e56368809f4ec20f55bfb3baf10398a02833ec3d7938f5de1b565fbeaccb4b2af70224d95e5358661401f35f8cb3f013c36e8f3e047d21a40e210c687df6de72aa38ca404e127ca4b53cf5a900b2e83893459df80a32da146e1b3a11d72e8d302dd059573ba93e8f693eb29735cdc3b62bfdfba3303af48afe8b3659ace411f860bae1916deda7a25ddf962c4b9f27320a2d58cb50f9749e3fe8f66d495ac71867dd8332df2063cf1e016d5b35e7a7baab673ac75d015d23636f248565dc7ec86ba3cb731efc877ca19782300b1ac1ffce4319d7c312daa7f80dd9bf09a3bf452690efbc6f0a31f4ca810cf85044905cecb8e87c910497c2e44f2ac7a97c0539206a1306fe32c34484d803d013406bd39dd08faa9049d1dac18ad3eaaddf9ff3eb38ad11df2523297d9d584ab436db71ac6b43afaadb10fd1efe60358f817915e1b172234b06420d7c69954851d1376fadc9c40fc3d5e962c7adbab1fd17a4bdba0e506b95342d40573da9a6a3ef0d49560cd1a7bc9c79577c13e901192c59178d6024bdb262891c7307b0e43ad74d255d70c2c8cde3a1e23ecc57d6dc625a4d22140cc6e9f82573d94b4b9d4f94c7c14c109ca8f104c5d21bd17794b0204881dc94160e22355d1752140c76671220222fcc2c62e6f89382c633e5c06a838a16f3cfb17ec093ae0e7e20103aab7fbea9878ab3e8f504972a050aae2b2782a54f8737babafb25da59c94ea4079ffe83128b102b9586397faf908f389dc66eb53204d89abb93340afa5b0be4e8201f31fed90b00d9da6c63ad9745bdc30bfc9424f760764725aa205177d24a1da44cfe0db5ef847025a242471267c637bad2488e60ff0815609c3534acc287f6b84c971b740b6002650e2986490191753f5493675eeab5f601959fb36d175d6afac1d95f717e2459f672265e201440e18b8497809895787840f76a5a6b8b5b0f9b90f5957c116dec577f6a933c4037337b3b724c0b456d561c878e75ed7c254b97c9da01771b4549929383e442f6c4ffbadd59315aee1c77c9acd2f310143fe8daa0c4500e066cca98ddf805410b71081dac13c622ac6a1a70938ed07db33bb405a4ba41776e30b9038df7393d4700332b9123330e214062cfb0b0e1a81296d84c0dcc600d308471d6906f3fbc9ce9befbe69f71f272f7e07e5a9a231dfa268fb12352b5a5f0aac6f770ec71dad6928ab4bc984600804b5fe9ffd62a1f2327fead583916f7e3c319bcc4b5da11dd3013d1601c0f0afe1c6fcfe28a82766a97209ae231484ffa542756dfaf791e4b04ab3f4401019779c2da851d65352169de575ff59e4b82e8eb3f5294383cfb59d3e7dd22c26c1d6cb12bbbfb55061e299e7d1ca0fcce9994a62813283d67e56e22af4629356560094e50d84e8d7ec12a2b4a03fc2983020f0098592ea1d8ed5acc3ccf49cdec41e1e555e2bbcb468d5ed000d6ae7459f687ca4902ad37dd8deef08d3b64606db4686fc622214f57755e8cbd645946704c9e35bf92438a30921621ef31d25e3bfe20401c01be786cb914c37562f0ba7c4a200043b78b8899a6960c883be62309ea0c423be482214b1d9d4e68c3f783ea4c3dd99def806f4edd960419a8e0bba279505341d4373def2d40ee04fa32e500687ef219f2e6e4d6344c8ee3c388f5c0c24978277d9b17afaa73493f6840c439f895f5af175c2c33bc09b962b97d7441734da15ea12d50b31407d9efb9e467ed4836ccd2c7299bf6b5cba58110d12db6d4ab1f0afb21880887ec0edafea3886d619416e148aa616f25adc55ca0b47d71195b28e53c53b803789134daa96060db27c3c72f83fefaf097e8a666f563e104f8318ecd92911a02487878ef74641cb04389a76bf5bc277e905f475911837456f17c61d9b19cb9e10ce71f172d7e7f8f104a0149f72f6bc5114d7727dec7715d1fa0b24bdb27c5440b6b82500c670fbb2f46eedbe46a79ab7783c4a50eaf304303d95a63da885003756d547c9e3c551aa12e59f03f70b226e86fcde8ef57a61c49fa22ff0d371b5fda284d0918d65e646ff9f6ebf08581f7379e0167cfa2e1edd42d9c685e306d194ca1f1165f4a22b1ab27f926832e0df9fb0ce299526ede0290196e0ab0733d60c12369e9d15b3d128a5dff88f9286f5549e2758c700faf212c436b401341a2154b51ec8a7cb24590fb2ea070b697ead328da07f5e1da8112aff139996c7f012eaf730dcbee26f45a7192ce06907025222f5f21479d6171f936339e38f136dffb04ba3ef8ed36d885959206faf8699e0a8b70e7ae77dd84a58e5906a8a63cf904130661793cf1ce3884c6c1c2ead2793929020b3b3c1c860d35d87ba9daf994b1691673561e697879ed9a44b8128e2420022a8782de8a73b5cd03cd27c7482ba21510a4294316cac2c1a855bb77a644e28ebf1fec333cf9bde21b687173a474056a35f85f8eb7418cbe8ec5a5b1b6c0869738db8e7e259c58d4d9034c2e5f72bcb97fbd6d2f14f8eab6186a5fee4dc0021b4e30988605c62caddc320e8c0c95b10d3c46c445465df83b86f1e59f5abbbf75846916d60d72d5afffd110ab461a9e5093a236346c8676e78889586239cc35384c6383243084b90387c9638e607fa35aca69f81a8c8a85cbef7a6120f25b14524ab29dd0cd75104ff0bf4a3055a270ff7b93f89b08ccedefbf7576c01b7182fd642b1ac3dc586fb6b7deb29b74a2de245b76b1eddc1d8335779e5d219c3e831c607bc79027f8eead4c69e40cfb602b2461cb5460189269f9f64928267d0928808e8c058a0d5e571a07e6f8658c48d8acf817efe7d09b37b84aaa812b2a7e8cc22d2424319826ce86922fea41c992663a47a705e68cfabad9f6fff32a04ca0b2939b1433bd5d3244e27eaf5c03dc71c9f599e4c1b62a21f2a65561f64e541ec5c364b935c2d7d32aa4f5a8d8fcc8eeab6c2ec085e8cb9877b8d69aceadd3b0a015a0ae79ce30bd1b7f1e59ff280562abcf03b216f08bb6548898e7d9aceec04993477ab9f54401babbf8b5764cf3823d0fea340446e7751a838017eeb8f1fc0b290433b672cee94b1d7365eb3037c6820b3ee1fb329d4613a4c9d251dd1eea5f04da732dbcb2c241d6ba04c7b7613b636236468bde0c08ecfbc92207534a12e12cec5e4a2c74aefe51ddb0e6192c16a2e17ee60f606d0121c221d45321539075a569a60bb59f253d1ba1c53740fdcf439260f1b0009f7994b7417c5d44affae774f4faeb2740cd4472f14b0582b11c2d2be8a7b13f75012f93c36296357aa97010f397105794994b22f3ea76dac87bc7c8fa1e24836bd4fe07cb0774e024a661a4aa899188d7e0d994d3825893fd664119a6008f0cc0e0a8a94ae8a70be4202bea25774c036466d2519f508e8ab9fb871b1346517a23a2db7971579f9f67365aef76a4fa01b5d0ed0a74795814a648fb95a6aa64e272cf6656a0937f8c194b0eb28dc91b4646bc5b1902d7cb520730a973127382dee28f193e6336e48aa325c6ff402a13c5288667bf92f24181d99e5dacf5f04df5ec725ceffa192ab9b796db8ca93398f0404bc69d3ba3d03803ff45f5af3b3b8f1329983dbd340de9f6528919cf4f28802ad03f6279fcdce9536e981abf91bbfc460038737bf26cdfad630bbc878780a23495efd9ff07dbd29e9cbf17950acca8bd24b7ce4025475eef081a5d855b9b1e7a146e7eb6d18c99086bbfaf9435fa3ea491576fae906af42768681f121275bba97f1932fc89b30de77f05c1d3b27afaebe9369ab5b9c1cbe229c2dc70737796d0804840f8e04111a4d59e0e265e7d45a1999bdaee5cb9417f8bcd10ea39841d247acc0a5aac4b351bc7135317d77f3b1ef8ef46e38782586bd60085deb04aa979347039101d99da73fc36c9bd3489421b36251e21e44fe9a98718f0dac4caa68b72e0021742c730fe088201eda75045da7e30704a94e89be1c08bed43d52f951ba61e5a296884091f058d152b8d9021082a6e9f2f2b5b1d993db7f42e98d9df9f8331761b1d091d7b466198b94fb534ecad74989cb4a6aabfe90967897f80800ee706ebb0f6fe25d24518e0d514e8c6752e43fc2efedb75cda8359fcd61d16ee839e4e412313977b01e0ecfd31658bfa277bcacfc6160e77703523052d3d5f93e9ea2df67616d90c3385a9e6a80cf41048c26856da24273c266ebcc8fc6f263708ec626dc08379ea2a0cf9dc025d2c0bbbf1b553a87cd0e61faeee8ed490fb850219b40e2c94759a32aca5580518367ba1b0172b45a939c3541050b3f83d60904846f22684d3faeb176f19b19a62566350e44f36c7b64ec28f302dde534e6b7b8ee71a55a7fd24d96a76319cb8b0054f05bbf4781cf415aef427f1da53c513ea9cf5279b3702e4175d2eac69d2577d66303c6e55969978d466736bb753415e7f3380e144045dd5323b511b43b1bb416f1adacd5ef9567a556acd97df2c0bb044b2ee8504efb5f15f62b2522041e8ef360fdd5a78ad1852b2063d7bc41ed08d3a1d2ba6448f4e539954b1ea9182ff868af1f86ab5ac6a811e552ff56e5489de0514477fbcb1717ccc683ae1e5a91ff959bb4a14eb04f9655931d3e037996106a0ac3737a6c1b74daad48ef5d7bd14affd8f1c23993e0c881ead25aa7d8bf2745b9c9ec1cb54d9e69e02bf5a8e7d1a8239ade94c60ea1faf4aafc96ce8b111b297ef00da87fbbe696f84967672e2d9893376d9f0d030050009f61e9ccdf817806b7a13e47843cf0292e89f3984d1462fd52e497317ae7c28f0e197ab896373f52c1bbdc3fc255ea292b5a07d580e79f274e70ef63a5e44a2ad590fac8b60a5907773010fe21ca4fed9cf3dbfa4178976abee13d55c0171a4b3db64b52e90d9fb30099a5f3f7ede848efcf1c0aa24808b3b327da0afcacde5fa9b9099301d3d5baa9b85c9e3b67a76e877573a79c22fff36ed4f25af76fd305e0d0b1a7b92dae4abb4898d1d4fb2b314da60787eb2fe79397664a274403bc546f10993aa295b968fcfdc4dea2a452c9dbaaa533806a57a467e81aaaa2ad956d43e310a2499bcbc71676e08b297d4e8c161b398388d38b126af832bb2753f976b472a122e40daa8ab44e0a03f8a64f33aeb1b42834c07c2bd970c6e43b14899c11c6c9e8924d8d80042704452e49f5f53b610484b03eb184b92505fc47504fdba547e8f0a048a7abf9e3b66fa6f544fe2f18474cd9fda31394d85282eefa6c8d56c76669ffe0e9917b1725f004f4fc2a9d0a735754c72d7641079b9d9088380fdd12c257680a2bcdda8ba78806cc278087b1552eaf09baecdd5bbb1b92816feb948a991d3fe8fefc23a0702a66096f5bfa567fc427b7bd5abb2103b29976d14bb206dd7c77aece2b019320326b7e2f986694f2c0a0cab850dc925b0cd01a0aff56b7dba91792a5cb62b97fb16fe9592dcb22d5d071839e3f5a42587c2705c2492b82308acf423abcf733a57dbe6e81acae0424e46d320ec09fc36f2363e4ea871223a213fa7697472b95659c96e89338707e5ae98c26119764333de637fcb42283ae7bf013b1e61927b775d49b68974c3f4635fb40f41cd74844464f2906ad66d9784096f540c060179bdea9ac138b58143be5510d4325f9655134153dae2d3166bcef7fd3541e1806a13207bfbbf516abbf446029bba9e5f643a3d7afbbb7e35a4adb3b781f14f9c93b8c6f20095af6355809c702692d9c452f3318067c0954a50066c8e2dc3a71c6902e60852351c35387a2e7815ce4ed89401a56c270dc6b143a78b86713d88ce104cab3a017846a8a4e24aaed3bbd44a4b49c127ff21285d7cefc2e4913854cd1cd5d37d3450f4839560ce5681305cd48b9afcbd8fa799f1fb84c1cdb751e1528ec81baa251f0e73121f011e724a18eef1b5e36eb837abfb278c33b04ce91fa474f012636b9365d77287fc8c2015740a6a069a58a25918a2a16364201e9fb6c5f3d299b790c20b913e26617755151a6592d9b39aa708fb5987f4d5c09e97e4ac4a3667c003f5b8cbae9a75403db1866128e79643231707dc33c055937dedeb8b925d63a73cd5ed0d5baa4076aa5d860200c6fd91672d7fde21779732426990df27cdd44a625cdb6ff1b7a936b03b0ac87ae196a273ee6a4550e579c1d34ec8173ad1ddb0baa30eef15aa8342bfbc8d2817b04f77c2dda8e67ed0cdb84be3bc110bbd7e73b67b95a8d655d987ecb1222d39947ed66c51eccf6490be30d55377038b98e025675048b28fab07ef7d2d2f93185888cb37ff0f286b3c70bf30f582f2946ffe3eba2d3395ddf285b47d1aca1380404597f977cf8e12a05bdcf7eb929caf446fca3306f309b32e73620651b394b3a0c32dc63ed0f112fd75597924625f66cbb3c7fa0158ad035228e7829731c8e90e139ca93a968c86fa8163502e9011d6ae2aee66713c6ee111808230921387eb065f7c127d041350d3f7040f66f3a78fd5afaf0bcc79ee78f5a79b6e1ea8419163ef2cca15123b3dc5d0674e0ddffc421db8dca1372bb6e9cd6bb92652e09b5457b051d9bed5059368943e4f51e62cfc0e38403a0dce255673ddd7fb3f008f816ec93ade23606d395bedc53d0c0e69f994cdf63d0ed355fe561fed9dd3374eaa4340d0367cefd2490028b7d0008e9270c343711f8170817e069a2e3ae101eac024c02c300254c2bbc191652a7b7c6fefca64c912b55a5268fabccf31a2c942e70a393065f9d728786b1075c71abc80df5d795558f297a20722511ed4594b99b07118ad7f2b9d919ce24a199e4b06a3b4cc59e9d730301c391e16f2aa0cc77406723d01754949a31dfbbca02c52363545f4718a510a759c99d181cbc559622ec842bbfb85cd4e94713d8645505e904243169cb782d72160d3276dee69b616306421f2922be400c76e8fdc45d2110891733ea5254e7e39e09952fcd92db9da9e900aeeb5cdb65a4fa3ee2c51b92cdeb512f5ef0f9d83543a390f58a151bfe29034da914b55acf3c5f0f6701dbc19ac1fea10af4131bb989db3fd21c6eeef004648099397bcb9fade15cb157d1d0b1b7f57e3d5361c7e1aba5d131d3edc48865889c227d38ee807c64da87929d9b92823925fce09f8d47e447ae7c3802db8d3bd74ef8ba5c2b561106da9ace31191c2858c725dc625545e2df281867998d99f97053ab9f7160dd139a02db25f8407a11f9db33c3e5c1bc8647b6a7229d4f84665e9d4440200b713487978d0bf7a692e0512851a68a2c0ca77e17b6223579728fd10c58a2ecb9753ee6515226d92d6320deaed300ab17bdd529cbcb3265c44ecb3d14d3ba7c5dc8f18994cbf5f05a1ae8fdd62b06447cde2cca1302d657fd5e2b341a70b6852282dc5207ddfb2bab90ea1ba5be9b33f2523f14c7e0033298ca1c2447ca6e8ab7df36e03978e34f19e65d687c601f4bed2767cba3fbff4f22b483794fbf2cee447648f38423e93f104b61d8e5139b75c353899197a0f1c0151808b0bb30198d911c46843200f512d09b2b3deece93f1fb894dcea55e53bfe5f75636dee8ea720e9f1cd9b8c2be8006aa8e26e74d8a3edd0dc6e0309a93e1d53d04597d3c26c25d77c7f061f80c504878604a3d38fab1ce67f1438fed68b837523e650b2d155084f5e5c651ce82eed5f964cfc722b02e185007ac98b5ec38443cd488300239f89b71c4ee61df32812cc9ee05e4cd5a2140d082e67cce859295ccc4eaf346d704570fb491c6ed08d41264d358484a782ebc8aeb4a8c9682be7453acca218095a0fd5063d8d3cccfa4d041a11d7c10e2a01222239dbfa0096f56214866fe4639651887d7c7a0607d8b05cf6ac4c51122bfbc605816a092241aa2d9eee3d1626b3581fef80ba21bc9bf575818de065c47271e341931380deb630a019182b3a489879d373784b75b36831139018f46633751e60b533f2ee7f3506fff2ee8dab6b581ad37f370d891a53cfacb2d81e257fbe3fedd7523696accfb6dff600ef2d29f4818723d0e5dfb4bfd39ad7e9ff4c586e1c809180d7273ced3af8d750196f8a1a07420fa2922e0dd4f5537ae1807e64db80a02d6f55d83e6d7acd5edccc85354a77ae5559e47081320a41540af347e4eca91f03ab01a1b736c6c958a52430c9833e83003213a39043ccccb0618ce326788275e49fddc6e53338902159cb4428486173fc26a54107ff00c588108e9c005a4e7554bb3cca75c4bab185d518f54645bdbc4872c76182c5fdca9c62190f3e4955467ee120fdb0602977e31e69a8c0269236302c4f7e59cbfbfcce32d31453390c12e835e8d4af86d088870730ab0138f245e1df357695c4e763c01a58090420c69d4c06e19709585a20b5e8e04e33d6bb90aa1deb861cb3d65f1bc8ab77953b88746f08916cbe0d7b49a299eb5db48a6bf6e6e2fb8d29e6e1a8a79ed7d39e48e7077442e5d3f1431ee849299bae22ba6b6813a885d394dfe4400f51587afb6e2bd69f3a573517bd57eafdd93642869ebc978582a77c53a775f3c188cd6ba0c7fc1397e9d80c39afcc6ab3128514fd73aabae63ec3d790a67c7aa8f4e4eb29ac191bcacd1464dae7e3bc7a5daf9a5e589b2adc18f042c661ba8fc2cf836b960836f033e0087378c79a2a56889b04e3fc608a1ba115ccdda46a356d9458152d3e2a0fa940775454cda62d857e3aa506db7815ab93cf1e9e763e8a6c0c122b8cd4081e95f35620a6462297eb669344644a7ec9694abfe425a6b3c1e27e2b1e5a8224b5713e1eb43ad883673905f042dc92b869e2605e67bfa92b2bc39727340cd230068454bad3d2dafc5ec05f123b697cd4a102d561aa6ee9ddb36b132521bfd249a013e009d75e70ab7744cd4ffbc23b2d6063faf2f042938c0de072be53fd9fcc6899353cfd5205f5260ed0ddd05c765bd2c4fd621a92a7160958966382e9d13693aaf72247d551d3d808089a1b3fd839fb42d7c8524c486db78abeed5d5a3ba3cbeec253f4458976f8ff2e5a6d4804e3e5f91c139deec9b52106c81be747aa48a9a3f516937e2ee51214d20c29f969487ab61ee5f6c7344671b983df0b0f854f253fdf13c592ee3ff99b178e13d8a259497827e0cac83e8ed578f33b565df4634f5af339b34360ce4b13cee523cdc2776726db20c5a635b7f169706485bc4eefbbb3c37efaf1403f8d8b1f1a65e1632cebbb396c9e404272192a8a3ea727d00280dc7187dc25869a0b062667d58b818cff2f769bb74aca1b77f911c6aec8bef14b3ed52d5e8b2492a49c836ad82699b37772b75c2f03f47981316f3ac53e445ece43b46a04e233e678884ab7be165525add47af3f6a02fc95ebe68c87b57e3993cf22faeae28e7827cf704aa4b78ea5348d19c8f165f175c7d3a016e62d9682ba71ce88926744caf4715a9ce78b3d21e084d7e5a34996224fea76804aa3a5daa02bdd7674ebdfe86f6b9db9ef00378a87251ca6fd999b2c53f04b5febde34ffd405df5f7e41436245791086ecf2573767267ce04724fe16650b39231a24988b4b268d8d5b0355c78bcbbc361453e5d93bc7b82d3c3b98e51e97df87dd461c4f141855a6547fd21e90a1fb216be06e1d72fa96ffc1a2ec8389c74bed0522ac8e8ce29b539a79ab789dcd862a19bdf1afea24c4c834c1b08479be9cb178b6c23a83d8b06c02680b0a00c653cfacc05690f5d2ed7b0d66ad08d72313688ece8be74a3af72a8efc224563700519659984c39b67def603a35bf15ec5bc35b5d7352e9ac58eab12ce7a0e1a40c9e29ab298a2fb66f9c70ba26aae5d4f3e4280eb743f467b95c1544bb290aeeffea4aa088f34abdee2368698b26b979efebb2e24792c929b5571a084005fa69d883c4a30106dee32faf3e6239dd4a943bc53816502cdfc54e13c9138addac5f5809a19bac21ef1ea82ca9035379dc81987a55ef2826f9d98702d06ffe85dec329a10401e845f5b12710890073b06537dcf4f9f310ea7292d8a1902b5aeeb341444f478855a75226a5db79fd0257e4ada66c3a61063a352b18fd8a37e044e0f86df159aef5ceff3f67ff5c0529cb746abc3ac541d49aafd81974205126c1d07cea1cccf9b44aa0c1e75fe97fe076e7347c704b1ae1a46c2173037b4197a67a498541ba14a77ddce6f1e767c37243f75331c4cf44d48f7ad7d132850f99ef1e334ffb4f2e93152f5bc92d4bac307c831992bedd43f231cbb92312b699cba25c6dff2daf261c14564ed7fc97b2b9a9d162604e53489a9f7e1d1ecad4e4062eae66eeb8002fff4ef63a451e71f060aa187eab9c1eceae04dd4c04e1f4fa4c73c2ba837cfd485b210634e55a0095ccfa06b1733264f6e55ac29fb01c5560be59a2d9a7c66c3d963a09dd604f8dbd63d76494ef45d92a770347599f7775b5abfa1c250015c88bb3be60ea42cddfb5f9486eefed58ab2bdb5c7cadfbd9b3d7151ec03112e6b48134d6ff6eee700ca5626e6095c07d5351ef90438583cccfa397c5f75b7d2e5470c6bef9ca9e4b9a211352b2e1d332a303442c74331ccb9a6b9282252a58b85a379e04d101f4bb62f63325da36e5bc72c3239fd1e88071718b8f23d2ab8dcec0e33ea6ec0a6c41312ebc35b97baadf71e9ef392d283d48bb5f334a40065eb916eaaf42c8b797d5009814579257b07255b9fe0fb23f67f3fc3a2dd3dc8a5f919d432f4726cc5665003537175db91abecb5376d2a6678467ec82be1c","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
