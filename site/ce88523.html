<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9e800cb63af4cf76cacde9863223b447e58372176549d43c6e3746b9d197c061c906f3279ad49a91cdfc926ab7f5c4bb0deca36516b21a7674c6ef46e8ca854ae48da8f062dfdde3e46d6678a0c8ec05bc2c971deddab5e24de6d61bd0b114914a292ba159456fe7644a7458749eb4a06298c0581269a24cbf1e7b7d2d58df59ca1b4a65ca536a003a0e2a01c714ebf68004e50720db0070fd3cb411513e098cf8e9162d1ad1868c37de96356e15859bb03c14f95f10bc7a203f8ffa72ea2006a1a4fd553e7be9f18e1dddc4c827ad97011805b8107662b454c2486bb4aaff7af2f289b860cd9fbcf3c45e766e06a9345e0af116145bfde66b8d6aa2205cbaaca38f730cc41d6728b12da93b5906c1ce01714b143574df2372f1613d7beefc47d36cf2e3dd9b57bf8be88e6719a6fa8c48974c64cd038d02f5d412e4b6acffcb4b95cc3bc00a72ac5c657d233598a589b603b0a15d2dbd7718cb8d2aee7d0cd5e45187306686f850dd5fe89fbf258896fb7045229b08f0fe864c29813f2373a10d4c6853b1ab7be5ca3b57e74b79b485ea1c9c35d3cb69adb4b269e78c06d6b444aa3f7bb6aff04618e699930935b2c188bfd6b246740c79041aed5596fab075dfebe655b68479702c61a5aa34ab6defe22bf05b16e262177988deeb2011005fd18d4dd9f84d5c22515f2b9ec6785bb97588a10997046a2f4febe8e81cc6ec95c72295b2cf33fe7179e5590a1fa90c8d938be5f703fdcc2dd5f37b09e1204bff60a3b0d0618d617cde1a470217a7f11993ccae2e4efe9556a4073d8f1730947e5ca4261d21ee6bd29d0e32bd8d19f6419bd0a469d4fa3c4bb86a1adca8ca3f35cf7c41bcb10576c98be4c4b6b64e69e894d52222ffd92920c53b8750e2aed29fbbee8db8421d2f6358a3e42195b8a81d5862c555dc53fef2c2a90bc01f9af40721e1eed8ccd7c5082c61df9659ddb41fbb949234858d22223cd6f8ce080fa3cf3480a4fb552503c15b77864f63a0e156759fb43fbdb403ec3438a5fd7c4478eb85fca3faabdb0fa98aa9d6099db9fb370c7194aa145b633b9e2e1384c8f101fa1f8a2475cead42ee43ac92fb696e29a66cafe0d9035d35ecafa19a043ef673f32903fe71f63c77b69fe58c54a4e9029c08ffad52e2bfe3e35611bfd3e7936f0111ae9fb27f34025e5da387a35729281c10b0af9fd12abd7f9eff24b0850ec073649d98f6f9e666b3f76e889110b84acee262f5359aaae1d43295e3241426915f1b6cd19b0f63047544deb1d0832fefb0310674b4dba09e77790f61c9ffb0a99a1fc91062364147dcdbb938267a67d68ecdf3a1529866a7c1dbd0bf2b2957b9e2e336760a5611e56d3ab952ed86d71aa4368b9f9e7b2678fe93a57e17d98b907348ef8331221afb7970aeff092aba57877dbcd88258e0d6912d510fcb4c4f632a171b6c1268ab8ca42583d64ffe4a652ab8ded64c6ad08bf828c9d780c4ea1a4c1f4b1dacd4f7efedb00eb7665573a6144054fa15ee66f668a82e8fc8941b5b498a7b631972a20bc8c88a96126f75bebd3de2dcce10d2c45dc9f7c33ca68f0185094ce5fc168e3e5c92733faa5f438293c916843b8be13312cf0fb3cbae41949fd08209669f4c5f7c1a9a8906930f19c222a4a09d3947b5751d7e635978dd274d23adc89556053dad77619969b2d50c928b2331bcc563a53aadc20f984009ed829e92a05b1d71f96887494f026e12af61a697c7880ce409253759c5ccd549a752a574f19b984d888eff239c13942523950bd4857c9c43aa3eca5b428b63708deb8bc8b40927afc8d7e84653a2e032d337728d2636f371ea08f06ed20d1c81cd45ac68a3d33d03dce280476bdb6a46ef4bd2f6461cbe996f9b72069362facee746edc38dda7c1f448012d73dd6a1a256ab502edcd6e12645c55c56a333edb5362011b61e86ec393cfb65336bcd16b10759af7925a33f637420bd5aaac26b0e39afaa6d129ea2122b452c6fc4dbc9cba44b142b64b4c530e31830c11276fe605a7b05c6c1de2fe7eda09de0f6fa54a8aca8062e892f132952d24835298a30d557aa724d86a909f754dac449e5a6e97f5db682854b8a59f826dc64d1bc61f1b9c6dfe54d4c1b7c46767d728c9191d523a997491003f9dd07cf2dba82703eb9748baf2673789e9914d5aca1177a8018edd2d27b439d0c1d90f65e4596b050225182971ee8c433c902e1981d7ee6e2e264c0a6feaf013627fe15e99d3931a3e56e69ca8988be53be0975a1fb8489e182604e4f56e39ab1247cfeb9c5f3a94fd21058ab99822681e07cec66aacaf70f9a43f9bd7396336cc46ab54cf668d8ba93a1799147ed9e293d4f08913e6b59f10b67ecc1f0dc20fb9047256cae8cb6309f1650505ade3050e06a9275fdb40c5feba5829408ab8e953265bd3ef817bf5fbf5045651914f72c447141170a1981fd6613a868bebc44a40640386ba5b09f2f8dacd7001fd2e939c9b6b4c33666850fcfa596844aab2113f2f7b8be6fad8692e62a7c37ce63cf76e9a3b314111f9fc4e80abda12be4f94d6a4b04cf73268b8454fdd7504825ee4301b11970f90ac198c7ba9469dc5911cf3915f3e40f0b37c2070e52a63a8c45390eda1b63a9537ad9e4b3f89a546dc00dc54bef130492466ff9c54dd06d0c1221f2419a9f22772acae64d0dd26978a3abe2e6ba17481b16cb241694dc50d054cc2fb407d5f820c9b70ebe33e897f3c7003bc0e3d3d9bca77c2eb872411f27cc8d8444adca5fe480f84fc57178630960e8928cdec4b0c483e19e5f0122de5f52187ad7fed59ccc4afa957005446382ff9df4bdeab46ff57633566f71fb0ca1c72d820df993910d263f41f3410963daf383ff310a161a43bdc59ef982daa87127a6548cfba7b4159f39a7028a318bb9c6f3c22fdc1734c1adfb1862fff608549e6a73d3ed7fa5b9f4ffa586842f6255e672ba3bf5ffeb7a314dd21790044b2c44468f951a51ecf81aa62da53d38a56185e3c7ab28a7ed0ea48acb2adfdab8720e484d83228194ebfb7fdf8115538cab5e2796368b0e2f5bcd5ed7c3df53c3075c2806572aa6816a3cb83ecc5d16ae3fb1d2cd1e8831fe3ee8f8be40ec5079ddb4b304e274ea9e12e87ffd2e8ab9339dcc464284414e1de54b83e8aea0505645157442c6370e7eb2bab618b514cc067ab0561d1f16016cce6c7f2bc7c7dcc7bd5156f85fee21b4947d5080382f9a8648b31bcc5ea365689a5e1cf8bede9503d9e0c8a9a206f29251c9abfc8a198d84b53f23585a4ac3f514820f89f1fe12a063795ee70b5ceedee95e179072e8a36efb06a39a054e7f352757f83539ed079e97accfc5462b93779decf6733c5bae3ee4cc4cd495a8adbb0af2130c83aa46ce6ea81ccb87978daef890e918940411d50d6c1d527a4ee45389e922c2eabe29d8dbf91968891d82c503c433cd5f1aeac2bbb865c1384de4fa3ac5c84a35ab9d6f670bdebf09e8ee703e9af4476cbedbc3acfa4bdd99e86220011999a8e2faee2b50b624b7dadebcebc62b7faaf400110c7c0247f0508c3f4d60aab8675f52aa900e1300014730a111bee3ecb0e0d66c7d5bd4c404bba37c523970c7abf1ef0cc2baeba9e2100955f444f8e93960cfe35300a36bb68c6b91de15350c9d175e9061a8a38533038d6778c000a0cab7efefd08d4ed0dddea44f2f54094ae04753f7bb8838838c00f264ff328dba60afe17763ab1e98d0f246c2bda44c64aa502a8c8ed94668a6d2edfdbdb070d69c3db804527f776c4786d3c5e2a200a6c7db29cdb33047f8c6def279128ccda4c50433bcae51f278f57365af80b7467e477c8739dae4c5ef19997ffcee1fc9f0eae486e7927d25eeda20d63e5e139292e5e162bad8edc4b79c074e71691f79ea3333423ec065e4bf8c5f66ce1da1c55fe86eb528158a95f594d576068ebe880134501338c10c3bce0779fd7dc7b9bd0db37bf1390a533beb587d899901d3b5d3a96be61c5c1a6c83a12280631f4a6793967e29b339bae671d348a20aca9d6c290cf2284366054d6b6cb190737ec34392a93ea81afbab4709d602a918a85e844aa7c26912997ffb52b6c113132ba1d4522e1e3826dabd45e0a15e4c359589807214f3034c9417d2fd3cba33747159a3daedcd3068b264838b8839ecf19e05ff7702b2989fdc1ffca99b33929f35499a0bf748f82f46d8c58d7a2b7c54f06ec30529da862af78e85b0c92165b012e43cf053e6c416f8a22e34cc230a9d4da80a0cac802e3809fa7abef8e64ead9b0d019287feb72fb7872c1910bebc6309928742482275cf8b4a72769d9da1de65be57987b42296ba4bfc95a11a611d8dbbcde94c89c271ee43b8f3addd31747514809e7e503d2d28683e95054847e435d0f6a7212cdc3f91984b10bccd081ff526ebe79062cbce90776c1a94d4649900d9836b570ba7b176c14e52232578d45fe9056734000fca4662d33ed94a4c9609b1dc4dfb91e4db6495e0b38dabc9691fdc4e5ffb5b30853c0a1ad4001c72077e36a77f5fa3a31d7c0077e09fbefc4bdc2e5c41c726f08d9e9de48fb55bc75f943482a99bf25ad760bf2fe447557d1e3ff50d58ff05c545136237c876672f8807bcca69b317766c303789067674abaab479775d1c767303ff006c186da6f8dca2c427ce5c7aaa367e2065683003713e8a6cc102da7b92e20057aadbfbb9b3b6e6339440c96c72b66f9c4d7dcd4938fe0868eb59f6d2ca23aeee7b753b2f6321b4d19ace42ef26a745312b3f94612a018112727fb1a67e6de41c44307de9553c6fa879413afab6fcf72e47b1b9857e1d771e608c2657e3aa38d642470e08c4585580a49e250b5418aeb8f3078659af69d5aad1e8d543def22d1a7ff8e3ab5f9e8ba7424c6a3aebd73b927db1a316babbe7a50f4381d06e5ee34263f67e1d6c07028b373050ed699171b89faa0a500e82ec3a199f545b7010eb87c28b730990c95606d4fa823f3e5ae6386455d78442e4785537b8e13e6a082f7f566e59646e1bb0b88d0f346cf52da9dc66efd3cfc5337422e66d71fbbb43d03b73defc39ee136b017b37a7d54f4a93e6f57479aa75022f53c78a9043459d51e29e1fbcabb4547fc137d0f939fda20d0a62b949d9cded5997e5ef1b47d3a73675239cec6e4fb97e8bb32b1b2bff126f76adacdfd25f55f2fae75922771494114ccd0ab8f36621c508e341b980072a25b0f1d27726850dd831adec50307017786eedfd26554034d77dc532b0fce54d699adc6243e0aeefbf1bef4e5a7820edc765d37b1b6528318cdb4839f67a5761eac68fc5c5b8b0b739bf30bea7398af82d198873e9aae0a443c2244451093895b678a9c5110bd612c612f6be469aacea8c256cd79a3c205e20f9854ea8167c866ed9d725da592465085704298bce944eb7ab15cb283513b478c4e33d49b31fc7c394bbe84e1c3f548215822a4df0db31e8bceeae1bd8508afc0559e8cf8b5c9d717c7fb32fcc20a1f7b3810b41e715badafc6122878d09972385904f6aee14603e4920744635a0292449e203dbb2d1de96a9927090c85352336576f0dc661d9005b67373714462198c4d0510c03ffd2478042a06e9d77d20b6e793ae12c88ac9d6bc8e3caeb02bbb061273d6f31824dad7523e4f1425bfd0a49642fc91cfc1cdbcc6e3b2ef6eceabcfa97a653ee3c4eda79b8af4d84b7b555d3a1b2160c6d56295221814db7250d561c751650c18dbd7f8310c1d77847297a3dfa66a1f95e253853ad8da1f3865ccfeadd3b1f6df8ca9b55ab4eeca6745e13a26d8137bd336003ed997db9678544f401c711ae4ae3ac1f307d9ff1b591b2bb88fe13ff2b93f7c72d8dcc6124d0ece232d65b2f265fe23e0c439a67c279c14b6f383e3c0ba2bb0db3615cc41e5241642f05b9b965d5e0ccbb119627f128a06388aadc0ff9d23fb7b7c2be78e173d0602c3561d3cdc7a135f6d0c14145c1603b619b3b1ea7e7b7c902cabdbd2e2b8ee731eae332374ccd9099d8c550a9a884dac87b923c0ab09580767a5b735107de5a2560d4dce3b5afa7cf7c73ba382a4e251fb52c6f1f81b118ea438a9ec192a24d2c5f5f6bc0e05de5d58eb936c9ab7d902830ce03020fa588f7727d2b8f538622d1bef72bd3ade0cee4a661ec49c30512720f07adc743db1d4accc31f145b472a7b017a19a6a9d4c35f0f418ff3c012a405b253eee405dcec264ae635623fbb63cf75c48546d053e34c7e255969a42bc32a92e930520cdfc5906ace98b2aba7187c3e8e399515b636f66816337370371f8b35c2be01dc7f0ffc084f128ebfe0a405972a1076067de4b2b9c6934db3e79c07ab33a10294bd69d59c8a1fdcf86a1e73a281d560890d3b6928592eb0aa4e83460b433b49c63d4b3cd02216ff26c039a4cf596d20bd2afa10d40b3766b3e82495e5e9fb42fda182609601b1d222ab973a124189f511ca76ab23348aaee015b649ef482271108f87b5d4b5c2a8cb8c5e5dedc3ad3ad94277a08b03d7aec3c5e4d1b9df31520c4e1e2b535208678cfc19608786e811f445207d9c783b4734fd4d69dca2cccf6bea535beab8ba0394ca77e17a41f4ce98cd65343322135704a8196ffd24b466693763336a57bdc361fc16d2405a0ec871b15a79b3720498d742c07bf55f5b268fb2768b12d09cf652c783bc85f88beff5e1b0f6e6e20eb6c17cfe555aba8da5d3135f776351cd3e7a26ed922b055f01eb13b3e337041ad3b1ccf8502e75b001ac71a91d606b145030ef72a8e6cbf41aec54ec4cb758ae50e35828457c464040d715dad79fa3d53de3420c742ca69ebf61ed2014cfe5c3307ad8dcd2f5630c7f962fda91e524621ec30a8f959aaa6d82406e6c3593bfa1a2842ae0358daab440c6e3f49325f8d4d3e8cc0e92d2ff879e0f697b136e2d75013cbeec7391febdce55192d459016f1be02912adc59b552b51226ebb458898269e6465c35e540f2ef834279d0f2f1fbe859defe127b7f1a1c621b9319a9c2437dcc1fbbcaadecd6c8ea54e09c03fe9e7c4c4ba90ae130a30cbfa9f160ac69b34ba6816aee8129f08372c1869f3e4c3ef6ae137969277f2dfb38a5174d56114acb48c91546df353f5cf174543f2dc2044ba16f915b5736b60d7540d9fc5369d0b1585efddf2b770622ab5f5957651d0af1037f0f6687859acec88e79fdfd9785db734dd1a7b357cde5ece46c9ea6893bcff703d95d2e9b3533a9dadc5228cb77e69b6342b70013743c3f9fba4e9c7358b6708bf54fe96ed93fa5478b3c6a7519491a6f8f2a419980ea48184c9b2a2bfc51d82a347d3e922ed71f6b3d01f90cc2fffcd77aee0575a79a6a59ab23cba3b85bbb7743591f18d2ebd82f91fac6edd7ac40944b7990762295575139ddcd97c7b4f927a2092203eb2aa81ebf162356b082779eb38bc7140410409beebe470684ccbd754ac88b089408029dade01e88cb8043447ed568f4a54c3a8239785abfad91279c2946a1ac8800e92a0451ea21592e6b4e5f0c3a212ec63edd6556f830d95f9d3cff1281a88d1542fd7dcf5010cdcaf6a05251c8631b8056ba6c6ed816f270bec60e2350e7f47a732d5c6a0c10b26c23bc703833afa80e48528a56d86791fd9af6662866858158bb77dc16da77d30617c5083dfbdc14b064e1d74231dbe65bd2cc8208fcd5fb65e30c3f1d8edd33167e2c168847a3212a8edc09117546f898c6152b957af4ad9b2cf13dd2127e27157907a91ff288306dc8bd272b575babf9a196a54db777245d88ae0594ee0104fe8fe89363cb35244e0fb2e442fc2db4f502da3d29f58f6565eb51fb541afd1d01197a571c1e811d4e95acafe8e48e75edaa24d86e351b83528bb244ae156e566901716ef04fdfa730f644f0d3267201f3aee2a8a117fb76bd4e910edc4a5429f8a260c3fc90f8c0ed49f5b60bd928ed9c3eee53a9a8fa905e4a819b5e2c39f05d270fad59416c207e79def305bae3930c68dc7c7ec27164c72bca302a7d79c50cab1b369b6fa69ba3ac73387967ca61b7fb0d2464560798a8f0dd097a313560884d447aac210e8987f9ae24638f10eeafcb6ed532cc9978d0c23775de4cb34a66e2ec3d55583860d82b59fddf1c93c99d5bae7ef5c95cd5bb42a6e8c47faec15301b343d54d2e1bc08589b4a5d954f7e09c4b9b7f6cd11172c765a7da00e83cdb15fff534b520c97063e831de5b3814b468a6fd308f25f828de2c79d08f7dc33911e1844c446fe0e04900148adefc2f782d77106aad38f766e4bb299e0cc790ceee7882ae918c668eecc807f3f31cca7ecdca45f5192dc4448a7fb9727f387a368f30c0cc3300fdbac24921c7b4979ce9aed8a43d4e0e12387adaa72b96eae378ebfa47f86572a42b82e1b0d9c93ea16e767c5206a1e3d21388660825e689ea1553f950bc8302023d805c257bea5452626c8b94b5d122e6fefb8f5ae63f4205d0e099b1d0ff8825139cee5f1e77c6c7220b7f8b30a2723b5d2bf8e1b3d3389989a541c4ad4a3faf084112f58b52321351df90de2694eb155225928f4c968739b7fb4be9095a661f4db0b96906cf2b69c543b4c109e99991f3b760a5540ce2e62bb97ee080aed30a4096b45ef203810d3e1cd98938ed9b5d12923713eb2653b1712e10e9151b8b98ebbdc32d9779176bc61c133746f6d0a32da901aadc831996901d7e6f076ca7eacbeb2f20687fe07d249bcd127327eb3f6d502f54b64ea419d675c73426105571fe1d112349af56f65340b6ff77e478a440640be0ad0469d0404cc96324232a6d39a0c1da6f040babe142a637ca102260eae379b9d06d491d2c1f27403153e6a970514eb1977f196e6248530b0f917a3e90c08ea165cbabded637c54ea7a80b3d3c2c42d2358b0aab1af46608a873a53522c0a8779619fa21403aafc300bc52f7571ba93f06d4cff5f17bc9828ff21538479f420a366a7be78abfc0c245304dfd98d4b08de658f66fa428b1aeb48b5720b5fd2519ffc34d220e0d1b8a4740dc9548e9b9ec1f9580dcfd5fd2704d32f9e39528424252173bf8194eb1a229bec4dae1222057df862f9d5af21d04050ebc8747330bdafc48964587841499ee5e506aabe6411bee6884e51d9a935f633ef5192f67fc636b928016510d396159cf143835b9566b10473675a3720a3bcdeeefa2cc3a5bdf5b5870267925fa63b079ae7f717a86de2b8fea5880c8a15fcdfbb71b9c9cab33945e13479fd2899e0500c92a8e5def6608d0f1f2248ae803580ad375286eda2de633aefef2333a5302991c17a03811e7d46fa6228416fd0a5f7b6e91f947d4a598ab7cbb6c9717ddfa724af909031e1d41ba82e802b163d2afa2c7f7ecd4a805ab29e5bc48a1eec94af673072c3c21bcb2e91f5f6733b901aa46a2460e52dd450ba85461558d98c652d630c2273f1a1bef0a89a6d9c656fab74ce22cc6fc4b1b4e83693be6eae589952628c84fb6b0f93b6028f1ee3610ef64899f5e2bc884235a3848f9ea4b545e2fa1cd67fdc5f723970e8a14cd1e0aa1c37ee55b8b86d55b85a622bcd8d13b79148f23c3ec7835fffd08192365ae950eb0f66ea2792d60ca6d9dae9877755dfdfe6bda75fa2564d535ae6d010dc59d797a95565c6ed3acb75e570a5cabe45d51980104da687cf89cbe86112e5a9619eaa20fe3f0a00e7442226ffd4fb5adb29c0661ebe06ad2a4267e87e21c5b433692efe35b3c35e3500d57aefa77edd870148334e0e8362949b39c4f60953147aa1a13196aff08c8b3e3875fe686e08d85247d04abb3cb763cb4f8f1283a2ed0760906ff38648fd02e39d6cd30d3e885d4eff33e5127c960c773192e87d400549479a596b7e876eac6bfa0df3b6a0f9ce32f8d514bb0dedf27f91909ac9592da5b46a83be94f5b22a58e90fd8691e5f638d11d96d366ca67c401b807770274c14029957f8c979b969f0bd76ef4f1ab8d13b14dcaa89cffd276e04c428b9dd68b8e088289f77c5b7f655d4d1ef6739635f51b244eb9633562fbbfd6aff9f09d4cdb0160b63e0e25c500fbbc475d468870ffebf9dd392f0f904ade5b4a4c1b95a5885cda7330b88a1f37148eb8cf8fe167a8da246c423fa8035fa4cac7a00aa540c5ae705af4cfe7feed8c7a9c38b124f50c16f6b041835debf865f4a5c30312724eb1b6308b447c57841601c34a64b36fe4d15a388e52b0c620f8396093420b5814e51f22003b04be1602e3ffab567adc03fc39f2f6974bd898c0836aee4aeaa7572b0b44cdacf62d614c502a304bf267503e503f2850d134d0c0a7960db3de31240e6000cb0d01b0c19be8c56e0ed535ab40953c99481e8371962c85a4f485ce5c2097cb47f7d9687d87337ca234438527c91d7d3568c52f8dca682a42a7630c19d72953cc451a167f7a9b30b477b19148d4522e0301c957959f073aca236f35107cdb47738639ce2b64e25c582f8afddb104055f52e1000598aaffa3bc7a2f37004638e89c3b2ec0ba817bf50333b0f3a8400f37012867e94a801531019700ac88028f363bb73369954ee56675aa8f1f8de49770c96f59d414952a09f661ca7622e1ed49d8a945a162338e7ca6c9248af06b66f68df04d537341fb84d83b08ba3b041955c64b534e9489544732ba7273489cedc5faa04cc5b1772ed750a84b035afa0160f423c196623baeb03cffe81b452f8bf2e76f6eddb80e2519e1201e30e2e6374644fad2d6dd6ddd1b1331bf69d7336dc33216fbbde7c69ef1dc48e3d35d05a8d134f70c3dbd5ebe69e363826f5424b8f8d1ede03413b5a46430814ac0de68e89ae3caac3598cf5223bfb441e9e3ac35d11734c2a2c7872d4fbed7abe8480fdfe503243936f6330b753b60482b8402eea4b94975f31f3ddd0a76e280602bc127943163a5605107b9d6ce5fee8e52678710c9692e168177deee0d7988fb3406b006ce8366b60a270c479f1d3051ea8955eca737394069889e38deec0ec744c3e59ca4c61fcbf4b95a6016566c7e0bc796e3a05e99635fddd3b40870ccc441eaa2a5b57d69f29deb73a7f8d96c81506562798da42971c20c273de9aa494b726dd3f4ca52bc7f4100ab233db8a7441eb9ca89d243da0c952ff1b769675719e510c409041a9eb53a5fd8d95d5b0c8187906892433a40c42dbb0fc86c5a78c41310201f2aa64a8f6a2e20ea8f38bce46628ee5a8b1988f4731cc6ae3300d06becc232451a8481c97f8e9ca77ece683e04b76e401f2f05b333a190dc6cb17cd1c4e71cc5a1e015f69d5cdc28fac89366926892c628aa94c95bb1a8bfc5bef2edcebc62af133686c6ed171c1a581237f7e4a751399c0239d033d7750a1f1eaab145069f3c359b6b04fcebdac8be5430927c169235992d76c733ff10d38c1faeaeb763c834f58cddf407f26792d6712c867c38962ee173089a62416b3517d144cb9cdb204d377daf8a20417b91b63e370ea3054927db5d5bf3e4889b89eb8b1e4721962d7197740f39264878658ad04fe9a8b32adb1110c849b44a0ed86411e6adecba5ddfc05ad4df3907088e2fe49305b1d8a201b5301bf1b155a4f8ead83fd59d7b576b7ed39628ce7f3787a759eb1f68039faa957c43e7592b4b305b1607bf94587275ea10b0e2c548327103ea52ec75142ccd50986fb52191153b40e600c82745fbcccf39700082122bb958c2964dd65607b754aa2d3e5f9afc5a8ca6d629429fd85ecae1c8237a3c025e7199eb6eea06093a8df1fe60b86f674533b7b6c0d8a0f5600405e3f5375e77490c02c18612d046709a22340e2c3dc06a66b4426fb743058c6bfda2affc8098faff745fc0024dae74cd55438aca174d46c2bfc93cf2d026961d91c5a9b0fd067aff7c33b308b8850201b37159143674a9a82d1cc75ba31b5da54e06a044ca7522552c2f3f83f61ea6b0a92e0ffb8ea3c6a88f6e9acdceb9d7b69392096607542c2c55acc3f9dcc8e62ebd862eb848d7b67fc9cdafa483d820e8bed5852552900f0fe0c7e7c49e1ad577bae5029ebb37022acfbd7e686c2097c5d7d639b2d60d3868f992cc84346f4ae44a18c58ba25cdd9ec87a632804e1aa34022b4230dee96557adabcc2d5f0a42c6fc4f02feaff25b4dc5339bbe6ccec644d1e1c032fe13a3d149572a044a1226a2adb6e6e94c9bcb36f51eb7e777e26a7f8e0210b5e45e7538496218e88119b08c251cb036b9eb4c596264726e3a3b1c3c87f3b478e313671babe1520129614e3a9def71d33dacee7d610b2b9827b91327ea16168a0187a2d32718f51af37a36693647f5b83b489f11349b7040b0f994f04baf33f886451bf1beb25a774165bdc7e95485576e1facb2b04c681b3900798717c0cb1f6d6e8a6bbd8fa01f901772609a9b476775a6b37960aaf24a49512a339ecb85e7b15f8dc44876e48fecba433378289e7c212cef39d2d13b7d961e74afbc77d8e2630a1b023b38641884200dc571c70f67e162afa63000ff5eb4dc5c177983c6f9542f00dc990c5eece065b19cab91eefeed7a043ff8a3f5b8418aa0385b6ca974cd48a23a05f78915150feb26240e574528a804a793e5531ee46e5e99c7b8fa13409e049810d2e1554c56230156fe672e4491b1c423522ab90191904a641c26bd10d060e0fdfbc265f80ac9da40fcf4a4df9bcb13d1e5d2fb339fcf45db00d6e73e0fd764d0e5669669ae32740319e3bb52cb3448c04641a416d80381a66a384dd720ec6033eee2a95c731a27a45cb651f3934782689c3987db65146cbc08c9ec7952ed4293ddd7219be3678c87fb5164da2c2a7731b566bf120733981d9f4f7cc0ba2c712a2ef7854418a74195fee36bb61ef8963c3be9eada235d7a24361246064864dcf6680f56c4c1fbc61b17e32a09fee4b8772412a0572269497082760cfe7116a2230e463beb65bdf8c13b9636d367c75e502515db2d6a02fea530c6af578f8268c60e5d52c188a941d71c425ad4f0688c54ce25ffa480b8ead1d40faccab67bf293abf2b930f1e2b529a022ce19040e57ca5d1e98ebbc577a165a9fde7b02e2702e5248941c199f10bceb8b9ad20ec1f096430d4bf83ec2c02f5f37feed2d3ae42912d9d4a69dfbabdc91be3d675b25583a15e9ba301cb42d53a29ab6a88e414cde15eeff39380582468d38aedd6dd9a8d2cf332aa62feb257456b82013dcc144fb7acfb1d618b6dd49bf571855800c67febd593288b5bcb2fdc81217a5c24c81fced98b3f12b289a789e354daad9ed33bd034cb23b704a98376c8a8f3864a0e7e112ae0f20931f0a33e67e884bd7b6cb72019fd37edf8642a91bb0bdf865d2d7ed18a715be88aa81be891f6dfe432c6b7ee5936b7f706391e44ca943f2658accae70be09ce72afb3210c10a35bd187d0d35ee63e08b0698fe6682553e5880f9f216604a358f4b55a8ee928eb1bdd774a6ff244ae89f289330ef2e14796c1e5d8889b4d7835e9cfaf7110adb437c553d0749c715c92f9cc29549da5ee75778986de06b5e810610568523c00994ae5b4ffad784b814136fefacf029e5828877165e8aa695c174ee6f0bb329fdccfad1e2da0ccecb10890d50cf7e06165b478b50936561c39b32bc8b4f9610c1fa4b08d18f677d3c56b1c6de7c066231d35e93e419b33a23ce64f06c71fa0be1132eaab234dc850b97b42aad679bcad6b074522e5c7fad780551e15e01ed8e4440fb4053a0ec23d31d6c4126ca0df155604e0cc24e4a942a56facd86a141d4a54030705311b87461d0e2750c9c98a4c8b6169adb4b59095391ea0adca259d0c796c7be14113f6bd32957df2e9922067141011aa1aea7a19700f10b5ac371078268b65bf36f29e125be9b2df410421924e5255e9270c19b2309d4402f2d9597ab0d21eea46a14c126fd11ffe9fda616997b","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
