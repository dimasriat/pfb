<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"978304bdb2b0e7ba592f37e178113e2b285ca685e6a579d1893dd66013a7a3441c210b1969380f3725cfacdeb5802103c6fa8296b231d82893fe806d4938f72a4c79b2679e19ceb05ffe4e20ad9304e64afcccae05cc0dfcebe2fc8aa1c891e962a0876215e5dbec7ecb1967f736b7b700add80265a51a5212885f2674b208f2ba7d16a3254f03a83841fa2b9e2658438d0d2eb42ca1e318297284fa6ad03b5f8d11b4fbeb8f985f94e3009d7656afc96bce861ea8338b9b609593d7500329c750c118f327d24b0572bce344c07ad032bf4307047e47a5709d783c524c0adeedd2cb1d10e52bc7f2fc962258942ca82a241bdf5d233a5c3fb92ac58fb8bccf5d8ed305f344901d2b39f01feb6ecc3e1e1b8e99d3353595ec6e226efc26f5c80d4b8778b61ba648c98dbac70b0cfbd92a021f79148185278f8f3886d3c4b328da6f76c7cfca777b12979e69225cfa1c167a641a5a58645f57761de2f828268ccb92d04f2bf03e47e3aba805cd6b0a6f895a4d8c2271aeb8ccfcb52d5644c44c467202a269d118083c6b7ac43735e0cd6a51bce17641746bb49fb8c65a95f4c6c9f30808dd289548b05db0935ef372958999284f89e77c3905ad830257dbcf529586c610b6e46d9e8daadfa52f8950bafa7afedc7a35e2d1febb23e575971c5bdab57a5272e2b6382782522f61f4a97bc51a7366528640679e0818d88ec6b1e39a3dd68b55b2734af572844db6cb13e2cecdc79de9a1ae87eb565d2d283e72523db3a02f505c30b359f5f139b635656caab12a1b005c06db5f19febf0967140995a9a8822b97019301a0019a8a446b27288f3188024f293643927965e863cd1a8499f52ce23efe2edf4cd700591cf34bd277199046545d006e43e48d6570bc07cc07dacd3d994d5783cf30469786114e99bbf90422635eb18fd606fe2a61a91aeed2c482de8f425c62a9ca31f4e75084a6fdeae70836ba9d775877f7116bce405ad7b65a927af5bd4039de4c1b79a68d261f13e5e4cdfd6001bfbf41482a981e6673c7e826cb3dc4261271a0e5a9efa16179d5119463271f1aa7ee22458c42d9851a890bcfe40835fed9cbfb86128579827ea34c4695abe8c1e7afce610604e27b97193745cf2152eac6352b0b8042680989210989e511b6aa1137b7aeb0821910baa3ab060f116bbf4bca0ff40c5293af4e35fa5e7ba164af2a94cc9c7dfa2cef3cfc2ff7e6bb25c3a6b5b635fca296def5603c267aff22a4f87791087d73573625bebcd1eebca845c8a8f6422cc8ddcaebd36786e69bf5cfb4d15480e06fffba6af43ae7cf5b01745b790a3e13c3fc80a40cdfe6abd2e89d0d0486eb2df3c4b72ffa30f98994d7fdca1bcef6c139d35d4155eae777730392481c7c0b47ec4a99ffc0a6b5fc32142e54c71211704915e73ba9b927f477a4fa35269874a82433850203dd42a835970b967ded7719ee7c76afafea1c67a4681cc29fa635be9f8d8e97d8412eef050cc0e9d7b62d408fad1ade949c194084732b2b62eda62ad2210ac16f38d00f23fc285de6626f6c5966aad0191d7a6a9c8ab78c8956dea0d8659b5a81ad653255f4fc948aed89ca23d22746dbc25481568a6cb50d43832502632702ba1e6db7bb1cde3219b26abc299092601a2a055beafef99db63e1f01a5f3e9896dd99297cf7546f97d5f6cb125c1a44275b09a8764e5edefe537f404ad134e4c121af1df30dc363a06735ff2e5b771741debc9091c3a0721a7a9aee67224807c99a286f686c53632ac21b74ae803725de51dbb91f1c0f6421b93e12b8efb4f699117a374eb49fc8f72adb305dd4bdcfdc25828773e08fd47fdd1d38953211f6b1c703c629441307c6ef09b606e9941f53dc4b7fb5b04dc1d83c4d50d6aff6e8a3b5c6bd5a1dc70d7d5ceae1207b238c16674686bfb39647400d27533b9c5b1c8199f51de2488e4feffb58153cc35dc9d47b25b364b1e8f73c39bd8a97e7af81be266148000342052253f1fa54550c98a51c9060edbca9dec15b2bb08d3b5d35069bd4f6e70fedf565918a8c80299143e36bef34cf17846b62a812e25e4da8482a2933f7befaf48960854b6a393a4a27a5e737f5fd2c3a6ebbc44296cdb7a0f66c90643e8133bd8c9aa1960a7c49c7a7b3816b384c0932c0b27cccfaa987eed70bdb2d0ede9be20fd1eb8005e868d34c34ba60571d2ffcdeb006a4e3f7d9426edbc188d68a82312fa692b92e6bdc9b661888a7e7513172fa658640f929bb825dc91a46f79bc8783c1d5ec41910f29e378c41b30f010f43de914bd514d3189525351630743eb5c5b0020ff1ca3ac928229ace0b977e689628bae86b8abe733357943dfc5bd99767005478a38d3d9a9fa0e7efd1a3627d86795314ee6b83ab5348afe440bf50001366f7dee057c20cdd7702cefef3b9307b13d3c7f494aed308275867210f1ec97df9f630f4c76f811e6aebda749e2f8b11d22f3aec773922831beb5cbbd3c7f27cb3ecf1723904ffa8066f9a95ef1101e67efde4ef80108e6a3fe71b1224e115fdeaa7882ec9d40d5e2995654dec47367264d390142626d445051c2dc5fc70ec1241c753ce674a24196a86a6dbf06172888d8b8180b9c17ca6296d651eb869f34afafe5cd8ed327d5cf25beea6954013795dd81cd87580a5463097d857f539ae75298ba23cc87d6e05dd94eaac04a064db3278d50752c6189ed463a9fcf89fc698af16489bc90a456b3c400d661514346bd0f12c62429bf013ca46109d0d554daf799b11210462fe02e198d6400a41294e06cb4ab2a933f7082c765fc1b1ad866d933044404ea393185d17878a36358269ac487b1ec75155f68f6ebf7db5d9cc3e1dbbfce499f85f15232eba9d230949b28c4eb89d8fcc05b1681bd377aabc99f4f061740f58a7209854f54788efe602a675f729428994b645975470ff15fe3006bcb5950308679f3a1260f3b0d3eeb4841eef96c20cd8db6cfc45a8788fd61a276cb88b4d5c28b069a06a6a0c54c8a516189816079bf7572d6d1ae2e4980313390796e511cf89486a5165848aebe2f85c177a7b3811ddb725abd796ed9244eb59064662a9899cfe235a1a32e60519507c79516566178615c0f661b61d41ba709df6e05e746efd31f14cdb1c1c21bff695f19da5d4300005ab6e37f44787e599e3cee7ad50b65680b8e00f44668d514a05b05856dda661f1aaa7fc80d9a048c9f4f7d357fae863066e4a26aa75ac30a81338ae8bf6d984e34c8852c8b157d52e988ab1126cd9fe4062bd8b297f58169153eb117c34b21abbdcd2c0f0bfae83c367e98cd72b5e4426ccb18c7d723671f35d81aadc631807f7591d13cd2280867b40409baf4f092cbc590d9d1bf733f8eafae8a800019f88c0fe2e13ca22803db61ca00ea7a391f9f0bdd9c5a95c7204c0d63d6089374734f80bf4b85d61995250b6e7a81a21a5d4b4c6ac98470da12105aa69957b58b7f0c6e2803e1b3be1acd6ddb98a6566ef5cb6c4f80a092510eb579b7591f6560de4a80c4d1de4aeb541cbf8c4ac31b7fe4628a64fcd1a801da27907e9e7b9b65bed47fcb688087f83509031704d3bf9aa70bf998af381423540bd1138c7587fff3c0eee8a8b1c2d85751e995a36c9aa278de6d21b64f56c52d6bb4aa2d5652396d03eab049a487040d3130c1cef472dd86b82ce6f9e299b8d1afd0cfcf50c6fc5630c72fc1db70738e63cda23c3ec5c907c409c709eac5c2586b0ef95f2e93737322ed2a63878d7e9ddf58706a16a14f461c2800ccc4fe6e17d8e85fc800a2b09e33692643a727d1b00bf682953026774421d0e180b96bed1c332fe49155e7d333f685abbd57c8cd7cb92ee0dcbea9f6d635f69002de3bf762eff64e3174e27c6b3f87c842924823f3bebac2dbb35376cdf25fdf7fb9d50d2cc4f10cd46d2ff1f2aefb44f6530cf5e0abb3a8a617277b2a95d9cb34aa46704efeed861d6e0c48abbfc64a952f64c0a740da093b4aafb0dcfb9b0cefbfb3289e833c04abb119cc0a338401ea4a50e2f3a1456f6b5adb8ef23290c35f88f1f5972a60c253999dc0299051e023a4192984a223547cd00c1a0f5ec9930717753b9bd6eb27f7a13721b94810c4f84b99eb7ad05b332ad52fe26667f88810978e435d45c333d79cfd4063bbe2d00ca2a787adde8d9f55450342bd5bd70f50087acc83bb2058b4fec8ce38b09b86fc6d28f22ecd500928b4530541dc23afa5ec6474d6e583224cf19868f64cb595db7d08474a1324b7ead11577bd2b5f774d5d4f9e5b7ff292fde1d691b32276cd05305491753295cc64168a881132db0b30e0df655b1a0d01de2c3977cc0dc09b918d63db3bd335683dda60a0d40a048dc8319b45b13c8e71c9bec977311beb583981e6e47cf3f014e0e332faaf40300610c3024221066afdd332312a1c44cb58b9afa945f90a373d4853cfc76c0d7f56d258a15473ba3d8e57a41f66ef11fdbe871a8833363dfc0c858f9dba61b86eed84af5fd20e38966c35ee55000af63f4b61618f38a9f67d3c6457984ff4409db3d115e2070462a95149c299032f37cfd6be749534f8fd1109845c8b62a749991a062558e4bb13a177c97d3c569b3726ef47b71d5dd3f518d6c055e7963ef5ad6d3b33710ccc1c67c4fde6d30f5d44f3381797b512991ad54d2e8d44c89649d621112e6de10bfeacd27e77b1c9f1f35d443a39260a69070cca21230d05c719197be6093906e1e600f67dd5ab4bfccefd618fa7c10c6bc2811ef6e937a513b54a681f8ae7c9bf4b7ff976f3a9cefd8f0d98a4432bb0bc711df43a29a6e99613b2e057b0cfcbd4cbf27c50d0cd35ca826c20522a35e33fb7a19e4713aa7565f0fe9c0ca25c112a9cd0b2abc80a2fa7b0b6e7f9edf21ec9c6e75189bbc20e24bbfe1efd50c670005fc716a054044037a0aeb802b3234d86f7ee5375d624bc17b9c1edf5fc8c242079fbf2f5076df62a23d9806cf471ab9fa97a06bd70323a687e21da91d06e6870298d2d7225545307cd50540dc357a1af189eeb4836543cf11373a36398e7d4880e254c2e59c6100c164411a2d275a912f89d27e2b756a732da5745d7ac2c2aee4966ad7dda0a46ca1925b314827bce7e2cca9ebe92ff4b9100aee6e3c9ab5b806caeb45449a5446a5fecd418197eb7356e0e274cc84bea7a0277626147ff52e1e84233e5336dccba43f872f5cd17fc88b3b2f5700b2fe69940563da4792ff4a46586a71223b3649a16410d52fc4e6bba12cd608cf38651fee3ca8c4da4160199ed8dcc695edae11f4ba50f73aff794df3b530504d2e40b97ee33cc3ec13d399029b95a05866bb6645398336da713267fb18b87f8e8a6fd0f300bbe26b9b0155208dda913817e7b1020593f400c577e1e0d420f1572dba18ba261accc935310a589415b752110b9c72acf12634816a734fa4176a146f77e2cdea2086acd85fcce8a0f2aae9dc538c6d7f980f3876f2be89aa680a2493e74765803882eaa040f011fc2b1a9697e3ff7c90883caed87e04c032dae55e020d93841ffe88b7a52895c05286c8f3583f1ef432453a20ed254accbe3bc6c9ef33a0e30a3675108bd6170976cc46ed05945229b1c2a29ea449f21d49af8e76c9464ef00ff94fb86c10bcd3dd55c7a0b5a25c3e0d5bf71ba796d6f834c91fc9c5a868548ee30953159f3e627854dcd4c8f9ce132d4906c945a79b39ef64c9c579b6ee0f276fe96cba7e38ce708a29978add969669c08f16cc9cdc806f227755848fba49d9fe2893767c55df13c2537cc617d0bd18c691dc041c211a26350949c631291f41b1423c755e2d9d1eabcc274a06ed0ebe8cccf45aceef132bd92d9bd9efc4f3ee8615ffe156a57af745b7e934aff58e0dadede6b95374fb147f3f128b33d4954382f294a3cd7f280c657a3f177de4a387ca4dc25160add99cdf1d774722e23d228a3fc1bc324f577a80ed849e1ca7ebf13510528deb7ea69dfc10824fcd66792ae40159a04b143ac142d13d92ff7a71c498c031c7db0442dbe06a9165ab29f8ca8b66b0b945b8b1edd5b1531a2a76e13dea506c6500276d19d103f3ea6e98d08166fdc0ee0a425d957bc5b9614c619052a0db8d6fbb97823150761bfa14a0ad07db3263ddcdb0f22cb54b6ab4979b363b84e14545b400f0c42082483ca8fa477cb5b2d86e6b2e371b91a656aa17f81af968bcd7cd56364ea17bd0932f8f7c80656b9efa0aa2c1b52e8c8890d140b694fef26bfd409bae8a0db498b66403eac433027f990b7154659c84308ff766f589bd2ccbda5c3e7dda77cb3255efff7c4d42f6acb91763605ce01ab177e39d96e509331ecd85052f9c2cf3aab8ee6a5c08d0f129b0c483c6f5d534cb795b434a45708e22c29ecf6d3c823f79ccc2993107cc308f2c35fe8f747fc8b1340d65cefdc5490747b1e0569b71f96420ef77fe37f37870900c5a696cd19a163f81c9d7b12616d467eadd7c3dad277b4715acb6f1ad8dc294b953d3a77a9845e3f71a41e726a9bd620cbf0791b77ed93d03cc2e810a0a21125b80879205dfed94d67030f86bf8f0c6c19d9cbb87996d6d90a0ee1297452ef71c61bb5239eb028bc18a860c192a479a4fb0ba055a98822f5b547642ac94052af237fb66eb8b4f936444aae8bac6f8ef6f082c442776d6b9b329d88782f09d6576b1ccc6f1511ee77bf6950d89774d67a6af6300f06ec363cff94e3e38456011a09f9df557dc39d299edc3b69fcd7ff0c32e502d40a8d0bcb84082f34c1c708364fffb40afd75c50ede7dee2a048fd0c30c268bdeb0bc7d609a691ad4cf430369bec17384db3923fb5d00eba33e2f665f4d4a0f4b5836e6f7f5a7978ed15046d0039e9860b552537bfafa28e4d572d170114dfcb612b76f786969b88c5c3e8079f94dd48c08a814a5ad6e7cd0bb2a95c5d9e3ca603bf8ad9e03c0fc3aad1191e4ed850785b5ec1f1dffd0b3ae185cded0db96fca0bed306fb88e68daca7d95e7104375fb01d54a51248f48d0a23e4e4fc5b2da44bec682e5d158aa40b051d25a1f4959b7be6d9556e2c45a250e1767997b767e8585987f1d244082520ff719bef2b7eea619b4bcaa309dbbc1c9bfe641a48d23f527bad13db9bab85490196a8a779b49f55f699582149fded08461af0edb9adc465464bdb6df71e9e31a35b4e2372f3be30c8ed3d3b87dbbc470635a384396fce4385a41e12265cfcb783f591265c3ff6ed7eeea9e8bb00ee448f2e9b691600a2ebb8e2d22fd17235d3a96d9cdc94c506de873e994b14fcac401da15ed569a2385261c61e97c56cb89a1260171c4a5a0bf1b24d4aee92a9e804b3b28cc25a397866dffaecc88e6cd4ac1954fc4c840002d23d9f7a8dcd26fd6d6d1b4f1c3bc524c0b29279e1f6cae1f46cd7f74250df6e8e5367eeca0256f35d3fa53562c15011d63705bd43d1a9a6d9421e05cd67d4e6afd1fae6cda619356765ebb2222e58fa2d20a934d4c256331d051b4e1cff7afbcf396a33b3c98da965f2a61a736a1008fb9543be4251e09d324862e9ca0f7f966397d772a7b749777000de72e47a49eea1d8e57099ad865ff44110bbc3830c9bde7dd0b3c4309802e35e675ffcdb380a964e77b0522b0d901e6aecddae67ed0d316391b38b38ed1f06317fefebde2ab1cef06c3b98d3c3792caf4036d07f7f8a88dad9504cd5645b5a5c99ecec7f9d7e99db0cccf011a5f28290427eea6a4cea702a1ec40ddc8c7ab14992d014125b504b171f7f678699bec07fb1052db5dd73a4910179d322cc7d8c6d9c41d1b6d31c29b0dc0511269af3ce04ff943269ee05d6d58c3dafd627ac18af6f4d2c496135079d12139159a6db27dfaa080fe06db038e6d654fe92708587830639d6085a7515f209df92144b23684450ada3d586f68132996def62274531f270057b0b36bfcab0d3474b858229bb1b0f19a1a1985f3d8e3de240cba8ab32275e85e7ddd9c336e1fb6ef40850a0eee17fc61b860b2dfc6cfcf340cd6c0c91271fe6ec8cd4c69fc88c627710ad0b20d663962813fb4a9b90d82eef9acbd5c0db024a1f904404b15946543c3e4caeebd6f08c0f8604609c96af183f205fc04c7fa25e119ca0458a609a8ad2bb464a21097c51a1b0b09e9a1f11e490d9e46aa2b479f45b68b6239c79f6824c16e9025904d7ca445f96983d9a663c9d283419d6397a1f7e953ad7cc948cbfa7c48c5200b9f4ba9465ee87e41f0a96e3c185f36d043c12b400a8ca0f509ce854da63e50bac2ed8c2e9712d368130640914c51aee8f897c2295a56df8d38acc8ace1d2dcde692784a80d2e40cc9a2d0f20c7cc111de8c638b0b2791c6b06ac5c882bf0823bbb29326fe3f4adec9c7e943a85ec2ee99f2e791015338aea2487841e7dd887e7c21f82f83306721e6350ab367968e9f4c217f5b99885cadfa16ea218fc414b93171fae31c6b1d982f43516be6480d2f09dacdf96802e8a35075b2de5281d525ccf767b54569051615969ea086cd8b4cc681ef81ac1232af232b5db350c36e1b3c8084d955f274e2fba9de68e95ff4d551e4ffad84be83df0ecf1226243ecbaa0ba92e1b87bce98e93298a71ec41723f91bb9110208027a36e85c2da3fbe9fb28456f7a250f3d23321ce55346ccdd5b5d3636508b9f9cb7403803a0e848f0cdd50a4f9b7303775ae30edd70d6b91319c90b45ebc8c745e7e5a594364ad00e65386d3b9fd9632d851279604cb51c9fb001645bc91c9a2cc04e282f228f63f19ac2fdf72ac78858a6a18eea54449a3186e98f00dcc383abf959ba81131db1afd5a25e2963345886f86f516e8e958bdc98c1df58a31dc12d9c7f710e211ebf6d4c48a6bac039dde415e504348d1c72fccc64fd197e7836f9d9a4758106fc394084a502efdcdd93dcc5f566c13c8d9ff79192f53f7f55f987615b4811759f514fe2cd98fb8e40c7a7eebf25e646f4109476e2b3206556eb7cf4315814eaf7d6e461e71d22b679de201753e59df057bfd77f7c4b4e3cbc3dedeee4e17050c284445fe971c1f3479efd99e7a47e087542c286cbb003c6f8f76b289eadb3102a83751e481734adb598ef1eaa7efe115e894ff5b043f8e52376dbd4e682e2b786976f8eb8eb8f349eda7aaad882bb0bf04ff30e2edbbb9103fc79ea7b5c39c11819d53e02bd7da3e74e7c8a3b3f17816487214b748373e06c1138bcabde3a04c81006d645ecbf2e4308f70bfd946fa0b92f2402e726ee2635246a072f5e8bb7f0e1a33bebec78ecb2014c767b7f7464a18901813e3af3f2d46096e155aafdb9ff796f79e4e2caf988a9335a4a0e3a2b31e5c9376075606752e16640e88def3bd1ffb38e43dff5578fd032d829d62b747db60637a1cb2c26d86d7bf0c90e5491d0c1d1e81feefbcbf09ddd1772dbaa634e729f0fd3d41044496f8900dc6e80bc883530bbf99e3eb43ee2528e09313a5a80e099e0a42e98b2467730e427812b7193f2945be682d98579b6fdfb828636a33f51f63194e9398739ff8372f2b90eafdb13be399e8bc5f39a8bec718188d07127090dd3a1de2848d405a8ede9fb8fa3039edbd7b7fadd47ee7492e6c48f694e510eeab3bc6db8f982a9a41043dce95e1457c9735e89a48d3e816c9e6c0009fe8de86bba0a1bb88d9e36d574937db4df4bd9f550f553463a3ff693c8feba5db603d980c45bd01cee7849d3f6f745d0c7622d46a1e50f4268417abd0c3c28fd249bd31c300d094c4a100b33d847356cf9dc2b31a958bbce37eb1fbcf9bfc3abf0db9e6282af8fb06487435a5289e7d21fda42e188adb64c2099e589694082b45a05ae2085c84d5efd74ca30e74a8685549e8ef66a3865bac1db8b233a406e46d8af7f9eb1f7a585e6c3f0a09a659b5fe982241c31714c9fe8398fe1c779f1de8bacb38aa339f019064441b0b188f47ef06be7d5985f7561e2910b3b4046ceaf41c5b22f289624d44bb79c6a254fb55eda728f4a81f34ce58673d56c30e9442a985e0bd8707ce334e2bf0f63c84740477d3454d76ac884453551f1c1b65f5db41282d67af3a6204d9b39d001894b51db5da5b30921a1d82faf94861021770500ec047eaa6cc49448f9f9919bc740ff91c30ee704f5b815aba314e04ce11df609a26da22c27d69cd86d2e9ee9da2ca950a9b4e3a3b47039445a77ec08f64688888b50967e89266a9972fe9f788a0972b110282d3a4058736c24b22b078eccc4a4f64c00f0a7cceef2ebd2f9e5cc5bf638e2ff4efbab878fb7b68b6805ed5d1638dd427e295df73f074f78a15e260dcdc0c5e679b98cb0ca3b1d57901849a4802f64bfbaf9b906fa87134a76af5d6692f329d505c079007eebf28de3711459def33337b3b68295c6810919c3eabec43f19847a53dc37a8b205483dc49595a6a0808a77350ecc81366ebf4d282d1df34705a34fe78bc540065eb2a69bb7eb88c9b0e1aec607b55d48008c01f88b9846d7ac14d84414757502afd5e9e087892580b1a0983a096b953511e675025c91533915541a09194148f7f475114ce9608f82abec1bd993433208b9dff7147bda118c6778254e8a8a9c4d1def16f4e0d0fca4acf5d9197e4e32f7c42a80c65f240142edcf4171d33f9c908c8bec9ce3fa64a125abd6668481f0fddbb0412ecf8cd1c3ca88f48a4b2192b8772a9c556bd5c2f106f93e6ad57948bbf5b6038c79b24d0543f5ab76a295a84952890d59efa54403d442a640c3bba527b54dbe1a4ed8d82f744de684af99d0077cba9b159ace542547cd1cbbcbe81d08b5904380f4b07fe3b5c15763ea64bf203b87bc040631e5459d2ffbd7462d1bc0f622d696e10807155247aae2bcd7a3a3bd22ce0d5f93061cc075938a6866059d8931b6b2a680f0b4e0adaef2769ff67c342e2d13b09af6cb4762765e8cf524f4b40dcb03e1811b6c3ff922e6d369752b3e661eb6c7b3a74ea8eceba9005cb7bdd79aca3b9180d93fe7e3e405129f02be8ef27751f62d2350736e9e0768087bdc228d41c74db12df32fdeef3b21206cd231c40ca6016793c301be3cfc354b9fd021a11631a4975f7499743d5ab3064c8e7e1756b1838975d87104f4aee0ffcf84363b41c263db7cdd3381ec09480633d48d1294671c8fa7ec471660c0beecd4cdd75cd9899218d6dac3ba90b985809d33eb443327d49b0b3bd594d4f15a28ec41bb0adceba52cb2eb1c87d5ee0f39ce5bf2f775f65e2f8e29643a286bd250c4c12783d0e02499810e6b38140f958f83636df5c8de84824cb1572f5d042ef5d4a268e46af72ff47bb7b6d674528c72cadaf4979bf4a6d7c7ca688c62b6275f5b0fe26d3b693c4257f6d0d45a6cd5624c4e5775a4e8e309baeb361bbaee42fb46bad9494ffc81fcef303758aadcc018a1e0ed29f8c448df5be63489324d4c06052841cc7ed0fc1ae607ea756596fb1c1765f7032d33ddd3e5f9716413c1cf252aada1512eeb095709f3189eb9d013272e9732c913caf444c7f58c930332d64bf282caf9c1001ef9437bc4f84262b65a3cfd21f290b4381d688a0737980a364d694cf9a57f8868b70368eff882fb7e19a639b9906cc93dce71e9c896fc986d5b2da258d226dbfcbe0c387a7a17088ac4d2353d0221a7d895186ab243c4c8a92ec8bb657926fbe3c500773b8a34db454ac1afb42310c8028d01b6862c38d60f7ad1290e60bfe5b0b0427371c662ce607d0fa4fed1f229ed68315780fde2744d4139cadc7e88b0c488e4ae7e4e0c0170d43575cb02262aa1f3a26eeae34926e35622d6bfa4bdfa468ca02c0b5a53a254037647715887ff6348e971da269a28577ebc72c667b2d41d5125205bb6860c2a1e2e3d42fa4bc1620870f82a08d9370b22dfb837f1165841727607ef5beeb261fc9fe579bbebf7e133705e5b4ca11186bb88b2cbf3cf7fa300ca208296298cf0e1a42a56f74d55ff68707aca390186c3a5a54a8f3e350a74b90120a14499c39de9fda7ba39241777f108d7a07357a44414cb2423b55aa3ef3915daba54b7c45a0ce1a522f77e032435869df5bde381793f596226a6c5fbbe9ae72f4bbd905f025aef9abe15547f3e40bb6427518c5747c74303de73e25392a73494ebeff00bcfba9f9b2658cf47d1f220a08c6153e41261a1860a57a79ac56ac3e16db54bf7e1bcc643794e72ea48b73701493c5b75a8069c61573962c5e8a2d13611816756333ca2275b29710e5d24b30adb4d429c73736b7d5666a3b4441b263fddfca085f876e7ee3ce2f65c808e9809828b73a7942bd22cd8a54da8d0b5050179e40388e5b28bec9c116316c653b1ba26636670561eada6f5f41a688ff2eaab94b52a0cd0ae30103bed5788de6c05592443cbbd63a83e35dedf57f19f041765f2a1cd79a18c87ae2e6e2d8215fd0713b9bc9a66b6ffd4bcdaae114278e128ab487c21cd312c0d756fa1496d8f4b8d2c70f5d743ba6270d7760584097082f0c7b4b3c4b0a7250d8c6caab818b8722b17a1c4cec09225e114955da36c4d27c425bf447c506fbfb8e912204964f2e5a1f26110b8165077311204694214c4d971ae826464b333c7aabfa57c5bddbd131edcd27b1aaef1a20e1f13fde9f334e38eb2431637542c075a7f0972f9a852c8d095c8abda700b0edf2421605f7c4229fa6d04780677e23e9f503cb2f0345dd80dc6f08be3b1a479a9517652af9f1c2dd2dfe11d76b790ae159cd353ece6a10bab863bc672c56c7ea1085","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
