<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"eed336317a3a7c5664509c017326c2006fa7e92ea303aa006ba3643211f95e7d8e7d76ca2bd9fc62baa12c085130301ca7220e689d01586f32e83877500283bc3bde7e195ec6ab46b6fb96ef3256f20c9f09bc665201b3f9def8d9fb2c83d2e89afa433697e21661bb8de8c8b40bb425e0f03f5752ab6b4864134c9422dcb8c019cab36c3978c820be024ba9cce31918c18d1d9ee4bd83c1d563ad5d5172e1d4ebbbd1cefdb6b8118ce5e352688c1d634150cc2959d3ae9b9dab130211a6ed9d265e352eeb2abac4a574d6f347a0e59a474ad0c07432aad88cf66ff7d25f0ce223da821d41137db61421ddce97dcccacd3fe32bc8fb4e817826cf5151d54bc6deac54575b9ac5080a4c0a9e1d22c7859889d1c54669b5fe7b72737df783afdff8ae8f333d99c1214842f054a38789de750704e41c5fb4f8db6537d0e8c44715982ed9ed97f5d37124355ca11e66cc41753db59baa05fe91372bb3ce69d943472e7e5a201d4599522ac9f3c02369f182d0c6e5073fb47ba083e81129421f3a1b7789489454f8af10c26a0c48fa508ab1f73b70c74b526f88e3b95bb7326ce2c21506a63b3db319b6656dfe14a941e9bd7031ddc6c1a70f846d7fa7dcf356de006338c4818bd4bf8ee813b939767bfe6ee8b19f26ccbb366962ac470ed48bfb3b916f6691eb151ad4f26bbc2177da628f3ec6774942205c698acbc93afd8a5d7fe9b18283c9976631ceca8923b024f966a2f0f3a237e1c4f67b6bf656d8d6ece31fd10954c630f5a8036650012c165eede83cd1ad26951b097f602359820dfcdc342ce703ebee89d074727e5f6025bbd6c816734cbe469e23aee066587a52a765bcdaa0fe9a36ff01e24cb82d4ce679d542e050e4c57f91c093f24416d85c7ed36216410e50b3a0c44dbaee7c862848fab6a1e476a440c697c910b3a4e1dab46868d37347d8add6459c7eb524623ed9408d8e3e5e42264434095daba4fa23fd14f80c4ec64e8f962b90ad25506fb18e7ac65ff635bac7daa2cb7f52adef3aedb4803c4442b0f2186e7f76f2db9e5ef9b63c4cd5bda65b0e9b4c9241ab2b919bccdf3c0a708b33bce8bddf50d85c3b7e1aae86e62e504ea89fb34efc73ef5e6e6dea6cb7cbe3cda8f70f186624c94ed9ae255b60213f483d657e10c502aa2b84bd468917f01eaae5c6e1471fb5aeaf5830a65ebc8d823b4fdec8f274080550c4d2fb0c922da75335449f882ee12f2e49dee243ef14570c3706f5a20e3f947a5ae285b07d975e66fb48345bdf1187b4495700d4592eb573d00c8d8cac0b3c5e29b7a68ecc62374a603993a2b2f3924922864265e857dd0671e7614fa825345276d6a185dbfd09395f2baea212a337c3f1824c527abf5a568191b92246d511e0f54474fee14ef65eb9f9794313b00419e7cbb361d32cd8e4b39b796a4f43c8f400b5601e336442c735687a8379b89b65f43f087c40cf6548349f929e70fa8cf3493a937c31c55772991099dd3f994f08da442337475a024e5ea20e7111fa11ad106ef474bf58c927e106b4043db151ba2b3f1c74e0435203862dedb0ed028aa3a21cf6178aaff5b322b01eb3cac82284969f45271acf23bedb74c551c8de9f9f51008fa9f098bbbb817e59a66044e27fae67f8a84680a7745a4971e15623a716d6299ceba21209a912953c7b042ff6c0fa40ee74509be6a4e41f4338f2ef0b62fa1fd021f0a437cf87759642bd66e09ed48a82be22da47f8961b64e40c6f4352e1acc685f2be7ed8e03a103565d0d4a840cd7ae6a4278d2156538ce49d7a274e901a1ab551b15cd55dbd53bf4fff983afa40673b4c86437d9aa52948e72b54af14a666f6f512f660829371a45c6559cef9f77ac5cf9dff42c02a441d847e5bb5382da217eadc040b411607b054058d03ad51df7436cb94edd794d53ee4fb8fdbdf2c2b575e586713740a08f6d16d6a77c65ba98ea11d431f1947e60dadacfe2a76b583a874387ed106559c84b5db8848dff915eee1e53873e2204ffee7a1ed11c410b29aa3143d2c15fb5ce1dbcdd2db343021d3364266dce9830a359d308c7df07a30cadd81bd4daa5fb65cc6e48157e0f68b98dced318f23bbd7227ed3568162af5d37378ce33c0113e943f34089a0b442c9b3121961dae9a8438dbb8e13e68d6b8c75cd181ec3e291f069706f450c9617c8b95b223f537a3c76d19521b1de7ae36bc762ab143a0fd78bbfa86996840f9c6c301d4c6c6edcf47a8529f0040095b656c84d131de87e8f632f14d5ce55fa3c3fad586332864edf531f8cce73a5bea84eda391c556ffa037deb9df7101667ca8e6c7413dde924af393e06ea1656ca750c6e166b15c1638d913c5ef1d57878d04fb0282bd8339148990e91f8af0dbd4b60eaa2399ff57732f10387674b563000f4a3b2c4ccbb15d117ec2f1afcceb83cf903111025b36426e3f89cc358d7755963a5becf0b52d4d998fb28990ff8ca4efc717c5084e18083b62d3fbfbf4529622650f65e25b6ebc01f242032dab49b5c5b9e85a54ddea0ea6881068489b4d69edd267a0448c9c4c71ef8a2a5119cbf45ef78eeceb1ff36bc51924f84a956d51f1d1335d7fb9131f55f47f8efb71be66320e1f102005b7032c44fe4edee1a0a8c3153e5ae5aecacc422e0b54c504ec10d89cdd5148546f9d8a50a7a0128e81649bcd0746f7b213358e60c61165e21592edcfe9fbb436d91158ca2499f8ada5f283a559bf1512252e0999307d2ef6e9bc5b75e1b0ac6cc76fc1d2c930712846a2e34629276878aab9e6fcd9be51a66168682741050f2d02ac20a93a14302dac30d0581b34506be7a1aed803d6ae3b258d4141fae35791f3a1a787806f426f67599fbecb50bf72098c0d82c3375b96c4f8b0e6e48b0d354b37420b3f24bbe50d2ee982c416307cdfde6e031abd0dd9c4afc0035c478e3d39cabae9d1d2033411775851d39935e99cf3666c4e4a86de07ef2ecd111b2ee61385ca28d609277721cd6ac0d090747d567020d8da7a2d091847a78cee9f2e36b374bcd33cdf682dea38a2ae8852846dba1883fa447504a65f0dfe005c4ab99a0e0ae8126a205444e734611caff9b29c5d8a5302ee2b30c4ff6a32c22188f32e4e44481d074d6e78465040c1225eec378de3205d18d8b5cfee0d4a43e07093d49c9e57579a551e8e8c7383a72ebce327fcccd9cdd34f24a4ecd3935d904b1bb77b94fa642ac3f53cae836b713a6d1a46f20cada657540e4c9e2c36cda75515b41762e51075f0b91d28a580a327d277cb3c312d6ca3a54150cbda46f6a37c2ac578d634d83014e285066e84157c09982490bc49740f47a470e772a2ac5bc2fdfe8573e6542cea1286546121b79fc2bb4aeeb41f4058bc81770e5878b6be2e74697177ac13364af8ec39460e1c720755521325e22741ddfff86e8ce67785e67b91a4d997edb5d87c8afaa7c9a6229b095ab839245734a98c0df6e7ed9108fa664991432d4c7b58066229b25e5afc184793f41ff83ba345b80451a55c3ae31d4b631bceff3988aa8321d7359ed2c745c6d79eb016b8af7693651af8d75aa3b4eee0ff433f88f6725eb9304f493e35dac276f5959f284f62d17364e413efe6d5e818e1a7b32b4e2173fcc2180543db7802a14f1d81c325cdb2e26ea69582f42c9e05d5b2816aae550b3606ceab6d9f8b596d2abdfca9daa2cbee687b91334273f857a5d423f950bfe2b18f71437337dd370e0b05b54fed348f5da17f677989ebb43061a382af16913a64b0a0e215bf5f90e6445b87f8c79392315c503f099a5724bab124341447bf43357b2d107a0572b062d3bf44dc8f7e3bfd988cbb92d7eeda06bcfe797dc7d00686654fa45dddbb5b8e9984ac06e029441c7a232226891d00b4f463c549c4c9e170b57b578446d3e53debd0558ef47657e15d48f7ca3141988c375b820c8ad5a8317c2aacf4a9b2df5ff426ab3864943f27a41c0c269c8538ba20be1e21fd8eead14c633ac1280fcb38484da96e26697b7745593e05c31b25fcd3c3bba7f04716234fb4b70a8cc299a7a243550ae89447db38400ba3216932963a36670d8043880fc8e9ad96490f2ba7ee9dbcc59706f959916dc14c2a89cd0751c7992a7c83e7de0466c99ebc84bd1068fa3017b57043f0d0c39a89695fcef79677c1bc61c909bc073beff681f6ce7a892d906b1007f760b0260badc00fc1cc2f6532814b51298d4da8a8ca5e32fd3f8a69645a368f118e59dd9ec601ad3f619811d9995cf8deb9d38f598d3cb73f86d5d485b706a416f629f2b836fbcf58e79c1c45cda69013884027323fc6aae24c10f0ad519e8eff97e16697993bd0ef6816280f251416f630805baabe4bc05ae1899c65e98d6ddb3eaafd99fb69afc299ffd1b3f9e45d09129a83a04910705159858438852d57b8cbfa89d2b60b3abc0cbebd6bde86c141f0798630984345d88c8cf34573c7feb81c2a1609d1d9a92e4e88092b58aa938e45f9fa362a47ad33aadd74c91d61b65f8306e6d9098324943bac13ce621708a93f3bc074fdb2a341af1acbd560c147544dd5a5cac79a3ae07fc720b90d2974779a2f10b66232b3f3de1a517bcf6d4777df37a2fe4635b97dadfe91c216de4fde3b049fba5f4749e2336c5408b58ef16459cb3d3fa59d8ae49306a0107619a07fade99364a60d77cd7bc3122d4f19d0d175286004e44ced2f79fa74be1411fa0249691766258ce1ab714771c292806588174c948c9472d3b9590b321ecb9816b09b51fb887d5be1d6a7e9079a1b4bee60cfcfbd15f05771b8a22ea63a8a448e6da16a77520d9edec1dcbf53dd70bd74c196ccd7ee408c6a92c8984d48db0733342d931dcbfd55262b7c5196c59b2cf002e8b9b62fac07a4b984eb2226fa65a0a96c6b4503691cfe8f8de2565a133fb0b3eaf583f3f7e7f2aa0259ed16ff2f63c4311ec5c1d5744610cd09597010a2c181f831c311f4dff5866ca55dabe6321096c89af87899265396f00eafe35ffe0045ea0e1967333dc6e8dba297665ff653e72c9bd1b689e919823c13c5b4613c7535a08306364691fd068bdd85728a3fd1546c0403eb02f208edd20fbe9367b3add9d0440c267c48aba3fbc4e112e4ba5b45511ab6da22b27c8b20995d15e092d57af055f5d55f513ca0b63a0ccde25a8d5ad531cf32c87aaad9a9f6f7b5929354cd04c0eb019419605d0618a508997f96bd09a4ee6e539d4652efcafbb4f2507d4309ba4dd06d6bd1440dd851d3c46a24bf3073ec5f2f34b39023acb1f29823a412245d20ef7bb472a297a590eaab8d7714e858df3a03424fa3c833a63e035d870376ff6bc1b2a7da8646726ab331e02c90db787820c0b054ffc2316b1b3b3ce9cf5cdaf8efc7e04236c29c886932dc6b2700db11d169f92e4b1c407d61c071bdb25df78e4e76f9eb4b6bb02ad4979eb54fc6ce97e1bf8c849b78dccc4dd92ec1f5631b2c25584632d6ff4aed50f19fca11f6a63c91ad4d1dc04119b2d43725bdf59f1df855879712a77191b1668dabbf561969a44babfe63f223fa2c8decf2ae3c3e7c27daafe54cd646d1d6173892b21dfffb88ebe196aeba59c474cbea487272711932885662b11ba179440bd1e97d7f50241de8d62fd2cab2709513d579cdad7e61f57f0e36b919a999260047fa2cf7fe56931f60a68ef27737780185812c88ead23251f16e0ea07e28c68d8f995bc1f8d29e5a13b9d0dac6d6cdbc99d05862181f18bdbaf5ea723567d21f33dc4331c63f4776555c4521e85544391ff6af77ab0255a1b1abf9255bb80394b42bea6ddd23db238eb0854d2e4f543d06927fe52d9639fbb1b23d8b43d9f68b02ba4b8e28cbca8e7c0ac374ab70e6ddcc12da837472d1b700c7f544139c1e95bb7077e50c258599037b2a3e27314386b8f6894044dc67ebe6ae658d90cb95e0e2251bd1eb967ecb934625b80a750b14020d085bd7e6723abee9d3fac68b0743ac19a6c6d204be08d5eef0900f9d465f275b2f5c2009b3ec58b3b701130d9113f77c142f768706fd9ef359ffc39d8d5be2572f395ef86675063e3e245a3be5289a40e0cf83e4f38ea716eaa4e5b4fcdae0737e0c810b4f4a7a059898445ae3afddbbf243aba828d8c76b1e6fff3f9bad510e1402b517753593f76221fee5e9b2017bdb87dc8f6a08eba8f9bd313b6047742c833fa6d66daefe5918c98564e9ef111a749ba81a140cf191bf3967eb3eddbd46dd234a3f1e6724f14c5e1169becf54dab44a65e8951af599843f0ab6485235f20e62070937d67588d0a4f8fb512cedb9756c31c1ffdadac4d16cefc272b08df00fd6a2b0dc9ef3dc7fb803d49f1fb573e22d231655cb38a8332bccb6ed0c114440ccf0e48c104964b54ed2a1c526f311f72908829f7713465099870a58fe514811ed417cccc13dea4e93bd727ffbd33292336b481af0aeabaefaa8d39df294798ed578a45d73f911cf34fcf0cb8b79803b4a1d5b4151d422c46840b64686f9e26dca97151678301eda03d7c3ba0e92e6db8961487ac6b1d535617988ade23189a82eae4fe9fac679cbbd56642e6000aee3c78c72633a5459e1a90622088ec75992585f7b504f15a5591efb967b790c35d59b8097694cacd6e3bdf329c9753ebf00f36e04d67c0d51554151c1a96dafe413bc86abadbeea2100aac69f5a35d5fe2b0ce67c0f429224d623fda0d386d54f3f804683d109d932d9dd22af705fa22409fc4349d9920b7e280b844eae87099d05b70de94a6a5e5d41f2ed97a57194522260f31d81d8660c4a900c48cfd5a02c091b8fab493210c9e6ee9b686a06f37d7530d13a11e5435459380fc8951b74fc242cc40234dda34fa8298aba5b89d7736de32460d3222e8b649e3717dd3111c6cc99ce49de3c58fab12c0c051b6c75b2140abbf2e07f5f10accd27e6b1578d33d2f185c12bb299b5adcef1e053c11d0497670b411f5c365736df39335172987497cfc74e130d2ab158b7485b6cd7d2b2dde8d5a62423eee8bfee378b910e6527727f311183889dfb7364fe6f669669043a173c82721846049e533fd9e8936c83e1af4dd95a69eb75d72c47ef47fe4c46b6e393aa60e4a006e4a625856ef144f84663d943da11a9ac3ac4bb5708e88c4d8a148134905a30c6a1724fbb33a86294e6218e997dc8be10dde192c3cb3b366aae4c61f891f8d7997971a83249d422fd1c0ea8651f9239e9ab5bdab481822308a84c3dbe72a3918279faca7d670579982e112f822bccd23bfe24b34f68d70776cddc088915c515348ef3f31e89f01ec45d948ba66526e7dbbea716c03365c3b91b4b24383943a33e222e7b89d2ead724cc9c77b96f39904cd1367b21742584964f1b4478d9d52143bf33649614ccf961b1cde2b5170eedbf23ff66e16d821f206878b330d9486577d9b6b1719bb3cda234a939e424e586a9e458ee7ad37b8ebd9b067a89b4ab8b77135efd6cd089541d81be931cbb4455cd7915b15ea5007b528c914f8d32a22c4a2e7732034dfcbb0150cca2288f98ff65d594883da969658a36219fc8d4b70e62b3bb5c770a1e769940a388ca6e48ee21492cb71513b62e303e3d4cbff9b9739fcd25d2e66be01633850a6e72ab2c8ecfa34c87b375c24bd8d26933c105f56e92bb14157a3007961ca8fcbf4b39bbc3aae4973a56015625bfc5787d94f82da91e85907786dd7866970b7871b419b9f2acc7077ac634be58e697e9068e7af7bdcef3dde12302f1e2468ed2f4107196d24627b6d02d57b0c7cec05100214ae567416dbfafaf47bad4114a8eef3b0eafe6a2a15281b80c308419686c28c9d4a83707a480a15ee022455d830f911ec929c9cfac82f8ce6203d6de2d2702f5310b64753a3a0bde0593ef19f6870679d8280ca75ab4bb9488c31df55459912753c657dc9db64a993861fcb10c4a8afe6e4e00454ff41fe5fed93b46ffac3b3c43aa163d8bb65db273f05cb5800f719f08e7eed2eaf220dae009f3e13e9d18e0b538643736630c4c5abfc282e76815ec12ab63066b9758be39347f582af5a2e163484001399fe73f79f8bd3ffc3b005e7da29044a0c525bbf404d9e6ea1d97e4f4f93e2af00a5bb051cd0b975e2fcaa5212172750a8a5722944bdd679379089a3b4e6d4bb07bdf2666c4bcf14555e0e73b849d332549a3e92e0b1f049b4dfc74cb9c759b9caf41cf13584cabe726528054bc104b95ef349ecfd033e49203c07ae268a3939878412437eace349c427a2a8fa1550db08fd3c3282d893a751553a47241e563bcbe6541abb1c8361f2181c65effe567165d38c6cfb169dfeb487635b98587f345762aa32c89bad8b17cf125573b989fc0d747dd8c223288bec84b6553cfd977e2ad23cfa188d3a810bc68064cf2987fc3009c43d54e2c16a1fbe6af357e484a4d866afb8b8dfd666628f71bc85cb1d2c06862aac19d6e6d63f98ff44a1cc648b5b06edab089d5bac11c2e3f4bf3d1e1a87c651eb50a548ca5030c6f631d7a5197d083cd91530ed70ecc4d317da576632da52faefe8c05ab1a6137642c2e574a9cbc628a1fc1a34f36a83f1aad6e607e1d29e2d75be549a82283d8bd4771faefd074259c5aae14f0fd5654961aa7d149e0b5cd356ae7940f4401cb0b7ad3c750b7101fd570ce1c0d54e73dafea037d18740eedac4e423eea676288d5a0113abcd1d1b708ecbc0ed6aadb33de0fc0c9c87930b5755ba1ee2b24ed9ec4679c4353a74ef9610eb7678a65213254a05fc146b35272c0e75f7a954a06840a361e7b04e7b4c072a6e918a0014a9cf05d7f9a0e079359b2d353ce4e859b1ac2e270309949d58a7699db16a037debf31a664c64903bcdb456b79b374179c18d134fbaf19223ef292281168fad3b32e78ae71e72b17ddc9ce7d3bddaff30d7d137ab4a4110054f1121047bb42874da11a4a9509f8cf6cf8f68d5f71330786d53092660512e1c256ffa9256b3a28498ce492428054ad9d780f076190b6998c0177fe055e336265bb8536c7886537d8b44b821b4a4d3292eaa4163e323d6166b79724a4c3238f58c9ecd97a1d453ffee2d1ab6a1976df44acfa1fea0aefa22c115beead88d262082be31423ec16370a616e26945bd99dffa1df5be39f2d6bc09159ad277ba337a56c68f4d874f335fb2c2552bb49249813392a440e48111378ede4c0a58b1451113edfe5af6b73dd0223e9d2c1dea9a63b44a52fe8ffebde526e5afe6bbf8a700f2b700da6309e53bb37635ae2450e98b19fc25791f9b14c7e3b1cd027e3a2aaa26a715ed244526a10c142351db31720f02531af6c47e2a8c48ee0f0050ded59e0a9153439678c9122dc25d6fb9340964700ae9a964ff6083b073a9d76be039dd052b87f340c64b51c212a750a5fa56e0fd7d87ab5047be99c88f3a43b933fb6ea20374db05ddffb5c1b55aa66d54fcf4d5505bd7618b76421672269e39420ff95af3ea0c34aba2c5d1d37506ddf98270e37ec4e78c942aff377b3dc990780306fd0f7ae6b2b29ca5714c04c4b53124acdc7f34f79fa73d48c4fbb45fc1903a7dcd715dca22adeb31d08d734238287149d77dca1e4fb77f7b5b72e7be2c937613394812a25d3275555c3a51bb1a3b00b7ea7e5f138e1cd373617ea8b8279ca50f8a0dc642002adccd0c14130697741b6d1687a2de290754ab9be129bfd69721fe25054e9c028d187b245efa24e48490a3e700fae8717571efe75562854cd134501766647f931f3f71f26ad02030dba6cdb16e5be63befe3f4ac6a199e0f7913e67a9b95bcd007e9dcca91677bf9bf4953e80f4255411d84e0afc4d93fc2a530bd659583fe812850778f3bb19e39036fcb3f86362d46068f536026159b923f00474a32ee7a3ba52cc932f6c8a1859f9ace693afa6659dfd706b30e78f15b635ad02c89cf782088fc302668ae24a73726d744aade8b3d4661150b0c1feae3f064fafc94757c52cd6517b2408cebdb4d6dddca06532e05de86b1ba5171a7fd4b60d3803f8ded7b892907b89a060bf89e1e4a56ac9ba0be631a6f953e15d8f79c39be95ae22a42a00197822bc7dd16f75f2565f07b8815006e06251a8f7cd08e57f79bfb3d7eb97442f1dfb7789958b2038cc76028cccfd6854d216c0ebb40d80c262e7a632ac2dd259ae015807a6011995a9ca292af3b4ecdfad5c5a59a9a0ca0827e5b0d5f3726ec3421c6ec6b8ab6931b23b474c4579760d0a5553f49075fbdcca1aeb1f7c5841aa96dd6d7fd6f601791e7b7846006a880cdfb7ae55b4aa3f248b09612695e95fff2af22d151ca542446f2548ea6eddf677d860494682610c08968498a12461d943ec23ac50e9a611fe979e19aa4220d543c5d2480f38ee97274593b6767643130b3197279d8d07b54da9541fc02269d420603e7b48a379dc83bbaa8c27e68a3cb56f33c613749eabd8c95a96e7c4ff9c5ebf2b9e3ee2816df820827888c7b7ae4892d7c33295a0ff5482c0f2d953a38ad157c982f6cb9c9e2ea60d3d0f2f9b01b84614e7dbc8e3812ab7df8bf47b1bdbb1538bda5d0e708116e453cb3f71ab09c44926925bf050668b5228438b24292877ed88151d215cf095c6766eda9875c8cc5e82506ff32ff24ed8f1d724a86d77a28b9e2c8f870fbca8ac52277e451947eef14b62fc327c77ef42887e41f2badc4009f7a1887ffc63c1ce11f1edd1acfa0b9792f46e3e429c7125e759951d8e3c923b93d857d7d6f231e657885dd2a60ebdfee8c012b89ea4040d7731c89ec84f53f19363678fa84993251efb1a050b20578b6aff939a8709d39c0d4583e27a0f3bdc52e0877f0c91af5138cd91bdc755b58607797057ae6c5546b39d5abaeecb9df71f72538553d25147765c8685385b1be971579bcfa16a4f13430d16bb2421abe5fa1cdd26315082a9e5f5b0a9c372b753f289dadd1a1810c29d61269bd6f6067d8a396c549290c096cee25ef1a91377cf493c385950eb5be4d6501b1439c457ddf7541d8f20074429f33cbc5577dd086b5a2ceabd07766b47c0c810d48e60a8ed5cb4b0d7c19ca662e5d1c2c67435a60d5b81d41b7a99ac8ae261e6e12f80917c89637a7fd723912155999f6418176a0f59377c23076784f38b7b3b068f2381016850c2b8b5863d8c4e0278db2293d69ee4a8fb326968c81526f560ef7c5c6ef4b0cb1a17b0c2c4d73c9084d094cd61762561a6e79fa969e0112a743dce142580741b1431c07908155d3c01382688da434539114bbe40429e553588a7c55f70e78738314aa7b5d02c1ba9edcd268e3729de7095c0effece5626e4e69450b489eb64fd49f57ff7e1d02142f71e7f8a1c35e207b8f056ce4da66a9d89e18dd3efa08a36dd675f7ee0783e5e81c21f231214660502363be4691ae6010b31427127fd6889acf134fec30083f6b76d25c1d91dd0b64f1ce6ff409dc855d2f4498f8bf8846acfb495d6ace9aab2fa35f083b4a5b41a6a77e856b5bf05621436e591becaad57e0088cc7d2462eaf9b28a373fe49abb94581570ed485970ccc35e6d487b8cff879f87f0def9b6492a92b22c74516b45296cb8504acddc92e0d672fbf0ce4ba32dda7d489d0ae240de3c88d1b0dc96beeb9a0289de712e00b95ba61c0a86d118e7df8bf8a4101f64d9239d4c858638be88fd08bbf864a394eab25cad46446c1f9bae940965f4674c6173e9c3bf16cb9ae149bdcc00a1135a7a95257ef291bc69c020d5e9be61a6b85260cad24c49197ab779821b16c575e4942d3ebe375cbf951b09489c29a1f5aa9cc9d08d090e7a357e09b4e09129f6ff21c57df230b75fef1c84ecc284dd62ca23c07dfea7b36a4275a1feac7efe488a84da4c1a17cdc4d33d4d508924cfd487874cd9fac8db72428729ab45abcce1bc99e6036a122bb9d718539d77ae950cb28694934d70f67ff99c267f302129ecb3f8c5da8679d624b65dec08e991ae68c494d5976de73c74cd8a21a44e4c44ff0b8c8c51a398c34b6a262a7cceb70888f18729a8704903bf0cfd8b3b53dcf13d1070c1443bcc7c6d1cf2e3268fca533f3024e11ea8ae42b869df6b691cf9734b09cdbcc72d996f2f483d3e0a667065cb068642fa5fc6f9da97d21b89c1c98c9a106f85825f170ddbb13524bf94f31c7ec0ee8384d1ec9a806f2b56e00230311e8b5c0ec04db362a3b8a0853d4438f2a6046f7bb743c5dfcf2dd1ca0365faa8f3e1706e45e805fe6a0f525e1eaeb3b17e58c77b71c34b0804de3d38d644aa353f54abbfe9def29a5716adc963c27f5e7ab11f37a96603f0742c76a6a74b72ca1555ac56b33fe5dfabde0bfec916482f2c8d325affec3d21b0d2781a3eac9023998f9d3b3a0468bcf4603eb57eb70bfe5a3f917d919f2f271c4ab30acbeef840d53f94d5926a32e87a24fc6aecc2ac92a477bdb033601d40bfce6755249551aca680adf19afe109647b757239e972970d7e13a8fbd4139d52463535f5f892f136f7efde2223c2829aff4e3445fd2d0df2178dcf751b304a027b99fa7f8f2c503dc0ac3b9aa91332e3ebc8c8128e1488ba0060d2f09df7a9b844307af593cd11618de0e7ce28a24bb6d460515d7cd53bc7432f73008b3064e297d27a916cf3baa886a8af7c15b54260e61c1ea38145c0f67d0ef41ac13d80a74a60b602f942cc9a818bb480c98758860e389b065294cce3cda0e4676ab9efca16a899d8360e91434e1a1f7cb665149f0bf56cd1923599e6ba8d2b7968a828aa1444a95c71b4a8741509e50a5ad91ce1d8dba8264c6d77cfb07bfda9e480e73ac389899cb5d22a12126aa199e0ae9f096c366b7fbf4457346981cc25466c0f2f350acbf7440c9faf7077334a32aae7e5dd2d93b41a7f7cf284f8ea82ab98139913b407532cfdd87dc03da956021339837871d01f189fae34c74eee8fc1c0e6288a94c6e5e1cbf02acb59c19239d8a6cd00eda7de9692d476054d5bc8b91e0adf238b2ee132c525f0750f745814882159cb3b6f93e36e28d49f342b1e4c6988b57cccaebfda8c21c2013c996fb68918fab0e68dcfc72b92558ebccb85f6ec4e36907c5966b6bb0d61dbf72932e131633449fc6ec311b3ef3607953dc9d624da6d81f04fa384b041e000b2d52103c66fc0cbd53f18519ea6dcc876bc774178980fe014432e2841ec03284dca372c748d3f00390ab7320dd970b13399a38b1ccc1949c26c05488347c001875947f129dc9b9b68d73bb1a16a72908dc1c31cd5e3c86b1572e69fb2fdeefbd0c118696e9b508ad01fc20cc52ce884bef1e13c44d00ff25af1c507e12ae5d4f8e80edccc49e3e648e5112cf557fcc9c361121054480d9f7e156cf5532b48138ca5082c5f19ac7ac13e57320204ea2f5961b77b302f5fa88dd40853873e0b34a2a632943cb5ae047907994deadf2e23b5b97ae5342338aa1c50502d7f3f6a3df7a22cd3fba0624abd5a57198aa0d9c2c915a95d856ae82dacdd614787a1df8dbf8417b9df0a6582a7f855d45594176f8ceea5f8ec49da6f708629ecc7e41c777401d422dfaeb473d84fbef0d2ae02701cc78422d9233a51bba250e06c950ac1e4d5e7627d2fa58223bbd0d308b7c7e646b7412168b977a74800a6fcbdd677809d0c8ebdf01f9cdc00127897c50fc3eacc0713b6d4e4d43a65647bae7cb0c5e7fda6d7ffa80c119637f6c1a2271f8cc6270daa4201fbfaeda2f611583a65ce87d0f1c44a73f4672fa223220a143c3b5f184180035c3443c8bac83b580c84f8a83ef342830c8c991779bdebdfb31354d204e00777a13c9fafe4b66178f4b648e33caaff75d76b18b8b81534dc1d85bd5a2ae065bfbac1f24f2d38a9e1504ec9acb1ffffab07f35b52c75757c71f1ec26ac691f30a77973220a40692cf42366863e8cad094592a7ec5c830230","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
